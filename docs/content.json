{"meta":{"title":"V语言中文社区","subtitle":null,"description":null,"author":null,"url":"https://vlanguage.cn"},"pages":[],"posts":[{"title":"循序渐进:V语言0.1.3版本更新,vlang命令介绍","slug":"vlang-command","date":"2019-07-18T08:01:27.000Z","updated":"2019-07-18T02:46:38.987Z","comments":true,"path":"2019/07/18/vlang-command.html","link":"","permalink":"https://vlanguage.cn/2019/07/18/vlang-command.html","excerpt":"","text":"6月26日，vlang官网(https://vlang.io)已更新版本到0.1.3,同时发布了linux平台及macOS平台编译好的二进制文件供下载，windows平台暂无，不久会发布。该版本修复了vlang之前编译会报错的+=、*=等运算符，同时也更新了v命令，现整理v命令如下：1.直接运行v，将进入交互式编程环境(REPL)2.编译.v文件v file.v 这里将file.v文件编译为二进制可执行文件file，如需运行，请在执行./file。 默认情况下，生成的可执行文件的名称和.v文件名相同，如果在编译时修改，可执行v -o &lt;程序名&gt; file.v 3.编译并运行.v文件 v run file.v 4.细心的同学会发现，每次编译完.v文件后，不仅会生成二进制可执行文件，同时还会生成一个file.dSYM的文件夹，对于有洁癖的同学来说时难以忍受的，其实只要运行以下命令就会只生成纯粹的可执行文件，不会生成“烦人”的file.dSYM文件夹 v -prod file.v P.S:以上-o、-prod参数可以混合使用������以上内容若有不足之处，欢迎朋友们指正！","categories":[{"name":"前沿资讯","slug":"前沿资讯","permalink":"https://vlanguage.cn/categories/前沿资讯/"}],"tags":[{"name":"V语言","slug":"v语言","permalink":"https://vlanguage.cn/tags/v语言/"}],"keywords":[{"name":"前沿资讯","slug":"前沿资讯","permalink":"https://vlanguage.cn/categories/前沿资讯/"}]},{"title":"千呼万唤始出来:V语言终于开源上线啦","slug":"vlanguage-source","date":"2019-07-18T07:01:27.000Z","updated":"2019-07-18T02:46:59.571Z","comments":true,"path":"2019/07/18/vlanguage-source.html","link":"","permalink":"https://vlanguage.cn/2019/07/18/vlanguage-source.html","excerpt":"","text":"V语言正式开源啦！经过漫长的等待，Vlang终于开源，当前开源的版本是0.0.12。目前还没有提供已经编译好的二进制版本供大家下载，只能通过源码编译的方式（其实作者在6月18号短暂上线了一会macos平台的vlang二进制文件）。Vlang源码编译地址及编译方法可访问：https://github.com/vlang/v#installing-v-from-source。现摘抄编译步骤如下(P.S:如果有的同学https://vlang.io/v.c 访问超时，可以替换为https://assets.v-lang.cn/downloads/v.c):Linux and macOSmkdir ~/code &amp;&amp; cd ~/code # ~/code directory has to be used (it's a temporary limitation) git clone https://github.com/vlang/v cd v/compiler make # Or build without make: wget https://vlang.io/v.c # Download the V compiler's source translated to C // 下载C实现的V编译器源码 cc -std=c11 -w -o vc v.c # Build it with Clang or GCC // 用Clang编译C实现的V编译器 ./vc -o v . &amp;&amp; rm vc # Use the resulting V binary to build V from V source, delete the old compiler // 用C实现的V编译器编译V实现的V编译器That's it! Now you have a V executable at&nbsp;~/code/v/compiler/v.Bootstrap the compiler to make sure it works:./v -o v . # 用V实现的V编译器编译V编译器源码，所谓的语言自举 You can create a symlink so that it's globally available:sudo ln -s ~/code/v/compiler/v /usr/local/bin/vWindowsV works great on Windows Subsystem for Linux. The instructions are the same as above.If you want to build v.exe on Windows without WSL, you will need Visual Studio. Microsoft doesn't make it easy for developers. Mingw-w64 could suffice, but if you plan to develop UI and graphical apps, VS is your only option.V temporarily can't be compiled with Visual Studio. This will be fixed asap.Testing$ v V 0.0.12 Use Ctrl-D to exit &gt;&gt;&gt; println('hello world') hello world &gt;&gt;&gt; Now if you want, you can start tinkering with the compiler. If you introduce a breaking change and rebuild V, you will no longer be able to use V to build itself. So it's a good idea to make a backup copy of a working compiler executable.Running the examplesv hello_world.v &amp;&amp; ./hello_world # or simply v run hello_world.v # This builds the program and runs it right away v word_counter.v &amp;&amp; ./word_counter cinderella.txt v news_fetcher.v &amp;&amp; ./news_fetcher v tetris.v &amp;&amp; ./tetris In order to build Tetris and anything else using the graphics module, you will need to install glfw and freetype.If you plan to use the http package, you also need to install libcurl.glfw and libcurl dependencies will be removed soon.Ubuntu: sudo apt install glfw libglfw3-dev libfreetype6-dev libcurl3-dev macOS: brew install glfw freetype curl","categories":[{"name":"前沿资讯","slug":"前沿资讯","permalink":"https://vlanguage.cn/categories/前沿资讯/"}],"tags":[{"name":"V语言","slug":"v语言","permalink":"https://vlanguage.cn/tags/v语言/"}],"keywords":[{"name":"前沿资讯","slug":"前沿资讯","permalink":"https://vlanguage.cn/categories/前沿资讯/"}]},{"title":"持续排名GITHUB榜首的V语言竟是C++的孪生兄弟-V版毁灭战士值得点赞","slug":"BEYONDMA_94978528","date":"2019-07-09T00:00:00.000Z","updated":"2019-07-22T04:55:18.457Z","comments":true,"path":"2019/07/09/BEYONDMA_94978528.html","link":"","permalink":"https://vlanguage.cn/2019/07/09/BEYONDMA_94978528.html","excerpt":"","text":"&nbsp; &nbsp; &nbsp; 最近V语言持续在GITHUB上霸屏，而笔者在上周介绍了V语言的一些基础，详见：GITHUB排行榜C位出道-手把手教你玩转V语言版的俄罗斯方块，而这周我也持续关注了V语言的动态，这次带大家玩一下V语言版的毁灭战士。 &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;V语言 VS C/C++ &nbsp; &nbsp; &nbsp; &nbsp;访问V语言的官网https://vlang.io/，可以看到其主打的特点就有 C to V translation &nbsp; &nbsp; 在具体介绍时其声称可以用快400倍的速度来整译整个C或者C++语言的工程。 &nbsp; &nbsp;而且还举出了使用V语言使用vector例子 #这是C++使用vector的版本 std::vector&lt;std::string&gt; s; s.push_back(\"V is \"); s.push_back(\"awesome\"); std::cout &lt;&lt; s.size(); #这是V语言的版本 mut s := [] s &lt;&lt; 'V is ' s &lt;&lt; 'awesome' println(s.len) 我看可以看到V语言在语法上与JAVA、.NET等纯面向对象的语言比较接近语法甜点很多，API的调用也不像C++那么刻板，但是其内核其实是C/C++，这就让我们这种金融IT的人士非常的开心，因为纯的面向对象语言都有垃圾回收的问题，延时的不确定性使JAVA不太适合做为量化交易的主要编程语言，而Rust虽然也没有延时，但是他还没有像V一样在不进行改造的情况下，直接完整编译C语言工程的能力。 &nbsp; 所以V语言不但具备了C的高效率还能能与C兼容、最关键的是语法掌握起来比较简单，这也是V的核心优势。 &nbsp; &nbsp;V语言版的DOOM &nbsp; &nbsp; 在V语言的官网上提到马上有一篇将毁灭战士（DOOM）翻译为V语言的博客PO出，不过使用V语言编译、执行DOOM也能让我们进一步了解V调用C、C++的机制，其Github的地址在github.com/vlang/doom。 &nbsp; &nbsp;下面我来给带大家整理一下ubantu下的安装过程（V语言的安装过程请参考https://blog.csdn.net/BEYONDMA/article/details/94349691，这里假设读者已经装好不再赘述) &nbsp; &nbsp; 1.安装sdl库 sudo apt install libsdl2-dev sudo apt install libsdl2-mixer-dev &nbsp; &nbsp;注意这步在官网上并未说明，如果不装后面在MAKE的阶段会报sdl::mixer库missing 2.编译doom代码 git clone https://github.com/chocolate-doom/chocolate-doom cd chocolate-doom cmake . make chocolate-doom 3.下载V的调用DOOM工程的代码 wget https://raw.githubusercontent.com/vlang/doom/master/p_enemy.v v -lib translated p_enemy.v cp p_enemy.o src/doom/CMakeFiles/doom.dir/p_enemy.c.o 4.运行程序 make chocolate-doom src/chocolate-doom -width 640 #640是指程序运行界面的宽度 5.p_enemy.v调用C的机制 &nbsp; 下面我再给大家展示一下p_enemy.v,我们可以看到如果想调用C的函数，只需要在声明加上fn C.函数名（函数签名） 返回类型，即可完成，另外调用__global标签就能调用全局变量了。可以说是非常方便啊。 struct C.FILE{} fn C.memcpy(voidptr, voidptr, int)#调用C的函数 fn C.memmove(voidptr, voidptr, int) fn C.memset(voidptr, voidptr, int) fn C.puts(voidptr) fn C.printf(voidptr, ..) fn C.sscanf(voidptr,voidptr, ..) voidptr fn C.strcasecmp(voidptr, voidptr) int fn C.strncasecmp(voidptr, voidptr, int) int fn C.strcmp(voidptr, voidptr) int fn C.strncmp(voidptr, voidptr, int) int fn C.fopen(byteptr, byteptr) *C.FILE fn C.fclose(*C.FILE) fn C.ftell(*C.FILE) int fn C.remove (byteptr) fn C.rename ( byteptr, byteptr) fn C.isspace(byte) int fn C.atoi(byteptr) int __global video_driver byteptr#调用全局变量 __global screenvisible bool __global vanilla_keyboard_mapping int __global screensaver_mode bool __global usegamma int 具体效果是这样的，虽然只是DOOM一代的画质，但是笔者还是很喜欢，玩了一下午。纯V语言版DOOM出炉笔者会在第一时间向大家分享。 &nbsp;","categories":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}],"tags":[{"name":"V语言","slug":"v语言","permalink":"https://vlanguage.cn/tags/v语言/"}],"keywords":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}]},{"title":"V 语言中文文档","slug":"u013604145_94598562","date":"2019-07-04T00:00:00.000Z","updated":"2019-07-22T04:55:19.545Z","comments":true,"path":"2019/07/04/u013604145_94598562.html","link":"","permalink":"https://vlanguage.cn/2019/07/04/u013604145_94598562.html","excerpt":"","text":"文章目录 介绍 Hello World 注释 函数 Functions 变量 基本类型 字符串 Strings 数组 Arrays Map IF 用法 运算符 in 循环语句 FOR Switch Structs 结构体 结构体-访问修饰符 结构体-方法 纯函数 常量 Constants 模块 Modules 接口 Interfaces 枚举 可选类型 和 错误处理 范型 Generics （预计7月上线） 并发 JSON 解析 单元测试 内存管理 延迟 Defer vfmt 进阶内容 V语言中调用C 函数 预编译if语句 代码反射 有限的运算符重载 内联汇编 将 C/C++翻译成V 热门代码重加载 交叉编译 (mac 编译打包 win程序) V中的跨平台shell脚本 (6月下旬) 附录1：关键字 附录2：运算符 介绍 V是一种静态类型的编译编程语言，用于构建可维护的软件。 它与Go类似，也受到Oberon，Rust，Swift的影响。 V是一种非常简单的语言。通过这个文档将花费你大约半个小时，到最后你将学习几乎整个语言。 尽管很简单，但它为开发人员提供了很多动力。你可以用其他语言做任何事情，你可以用V做。（官方文档入口：https://vlang.io/docs#option） Hello World //hello.v fn main() { println('hello world') } 和 c语言一样，main 为程序入口函数 fn 声明函数，函数的返回值类型在 名称() 的后面，此处不返回任何内容所以忽略； println 是为数不多的内置函数之一，作为标准输出; fn main()函数也可以被忽略，方便在编写小程序应用中，或者脚本，或者学习语言时带来方便；这样代表’Hello World’可以这么写 //hello.v println('hello world') 注释 // 单行注释 /* 这是多行注释 /* 它可以嵌套 */ */ 函数 Functions fn main() { println(add(77, 33)) println(sub(100, 50)) } fn add(x int, y int) int { return x + y } fn sub(x, y int) int { return x - y } 再次声明，返回值的类型在 名称的后面, 和Go 和 C 一样，函数不能重载，这也简化了代码，提高了可维护性和可读性 函数的使用可以在声明之前：例如上面， add 和 sub 在main 之后声明，也可以被 main 调用。对于 V 语言，所有声明都是如此，并且不需要头文件或考虑文件和声明的顺序。 变量 name := 'Bob' age := 20 large_number := i64(9999999999) println(name) println(age) println(large_number) 变量的声明和初始化 使用 := ;这是V语言声明变量的唯一方式，这也意味着变量的初始化始终具有初始值。 变量的类型是右侧的值推断出来的。要强制使用其他类型，请使用强制类型转换；表达式 T(v) 将值 v 转换为 T类型 与大多数语言不同，V 只允许在函数中定义变量，不允许使用全局（模块级别）变量，没有全局状态。 mut age := 20 println(age) age = 21 println(age) 【mut】改变变量的值，使用 = 符号。在V语言中，默认情况下变量是不可改变的，为了得到一个允许被修改的变量，你必须在声明时，用 mut来修饰。 您可以将上面例子的 mut 删除过后编译试试。 请注意 := 和 =之间的区别；:=用于声明和初始化，=用于赋值 请看如下3例错误示例 fn main() { age = 21 //这段代码在V语言中是编译不通过的，因为age未声明变量。 } fn main() { age := 21 //此段代码也不会被编译通过，因为未使用的变量会导致编译错误 } fn main() { a := 10 if true { a := 20 //与大多数语言不同，不允许使用已被声明的变量在局部变量。 //声明已在父作用域中使用的变量名，将导致编译错误。 } } 基本类型 bool 布尔类型 string 字符串类型 i8 i16 i32 i64 i128 (soon) u8 u16 u32 u64 u128 (soon) byte // 是 u8 的别名 int // 是 i32 的别名,与C,Go不同，int 始终为 32字节 rune // 是 i32 的别名,表示Unicode代码点 f32 f64 byteptr voidptr 字符串 Strings name := 'Bob' println('Hello, $name!') // `$` 用与字符串内引入变量 println(name.len) //字符串长度 bobby := name + 'by' // 通过 + 拼接字符串 println(bobby) // ==&gt; \"Bobby\" println(bobby.substr(1, 3)) // 字符串截取 ==&gt; \"ob\" // println(bobby[1:3]) // 这种写法很可能会替换 substr 方法 V语言中，字符串是只读字节数组，字符串数据使用UTF-8编码。 单引号和双引号都可以用于表示字符串（TODO：暂时不支持双引号）。为了保持一致，vfmt 请将双引号转换为单引号，除非字符串包含单引号。 字符串是不可变的，这代表 substring 函数非常有影响：不执行复制，不需要额外的分配。 V语言中，所有运算符必须在两侧都具有相同类型的值。如果有一个int 类型的变量 age: println('age = ' + age) //此段代码将无法编译通过，需改为如下 println('age = ' + age.str()) //将 age 转换为 string ,或者使用 println('age = $age') //字符串引入变量的方式 数组 Arrays nums := [1, 2, 3] println(nums) println(nums[1]) // ==&gt; \"2\" mut names := ['John'] names &lt;&lt; 'Peter' //数组中添加元素 names &lt;&lt; 'Sam' // names &lt;&lt; 10 //这里将编译不通过，因为 names 是一个字符串数组 println(names.len) // ==&gt; \"3\" println('Alex' in names) // ==&gt; \"false\" 判断变量是否在数组中 // 我们也可以预先分配一定数量的元素 nr_ids := 50 mut ids := [0 ; nr_ids] // 这里将创建 包含50个0的数组 数组的类型由第一个元素决定 [1,2,3] 是int数组 ([]int)。 [‘a’,‘b’] 是一个字符串数组 ([]string) 所有元素必须相同类型，[1,‘a’] 将编译不通过 数组的追加， &lt;&lt; 将一个值附加到数组末尾的运算符 数组长度，arr.len 字段。注意：len是一个只读字段，用户无法修改。 是否包含：val in arr ；如果arr包含val返回 true。 Map mut m := map[string]int{} // 现在 map的键值只能为 string 类型， m['one'] = 1 //设置值 println(m['one']) // ==&gt; \"1\" //获取值 println(m['bad_key']) // ==&gt; \"0\" //不包含返回 0 // TODO: 这是实现 key 是否存在的方法 numbers := { // TODO: 这种语法暂时没有实现 'one': 1, 'two': 2, } IF 用法 if 语句非常简单，与大多数其他语言类似。 与其他类C语言不同，条件周围没有括号，并且始终需要大括号。 if 可以用作表达式(类似3位运算符)： num := 777 s := if num % 2 == 0 { 'even' } else { 'odd' } println(s) // ==&gt; \"odd\" 运算符 in in 用于检测 数组中是否包含 某元素 nums := [1, 2, 3] println(1 in nums) // ==&gt; true in 拓展用法，可以编写更清晰的布尔判断逻辑 //标准写法 if parser.token == .plus || parser.token == .minus || parser.token == .div || parser.token == .mult { ... } //优化后写法 if parser.token in [.plus, .minus, .div, .mult] { ... } // V 语言在这样的表达式中有做优化，上面两个语句会生成相同的机器码，不会创建任何数组 循环语句 FOR V 语言只有一种循环方法：for 数组的循环： 使用 for value in arr 的方式循环取数组中的元素；如果需要索引，可以使用 for index,value in arr的方式代替 numbers := [1, 2, 3, 4, 5] for num in numbers { println(num) } names := ['Sam', 'Peter'] for i, name in names { println('$i) $name') // Output: 0) Sam } // 1) Peter 数组循环时，value是只读的，如果要在循环时修改数组，必须使用索引： mut numbers := [1, 2, 3, 4, 5] for i, num in numbers { println(num) numbers[i] = 0 } 类似while的循环方式实现:这种循环方式类似其他语言的 while 循环。一但条件不满足，循环停止，同样，条件周围不需要使用(),代码块总需要{} mut sum := 0 mut i := 0 for i &lt;= 100 { sum += i i++ } println(sum) // ==&gt; \"5050\" 循环的条件可以省去，这样循环会出现无限循环 mut num := 0 for { num++ if num &gt;= 10 { break } } println(num) // ==&gt; \"10\" 传统的 for i 循环:同其他语言风格一样。他比 while形式更安全，因为后者很容易忘记更新计数器并陷入无限循环 这里的 i 无需 mut 修饰，因为在这里 默认会被定义为 mut 类型的 for i := 0; i &lt; 10; i++ { println(i) } Switch os := 'windows' print('V is running on ') switch os { case 'darwin': println('macOS.') case 'linux': println('Linux.') default: println(os) } // TODO: replace with match expressions | 用匹配表达式替换 switch语句是编写if - else语句序列的较短方式。它运行第一种情况，其值等于条件表达式。 注意：与C不同，每个代码块的末尾都不需要 break。 Structs 结构体 简单使用 struct Point { x int y int } p := Point{ x: 10 y: 20 } println(p.x) // 访问结构体对象的某字段 结构体的内存是在堆上分配，需要获取结构体指针，使用 &amp;前缀: pointer := &amp;Point{10, 10} // 字段少于3的结构体的简化初始化方式 println(pointer.x) // 指针访问结构体属性方式与默认的方式相同 V 语言没有子类，但它支持嵌入式结构： // TODO: 这个功能将与6月末实施 struct Button { Widget title string } button := new_button('Click me') button.set_pos(x, y) // 没有潜入式，我们需要这么做 button.widget.set_pos(x,y) 结构体-访问修饰符 结构字段默认是私有的和不可变的（使结构也是不可变的）。 他们可以被 pub(可被访问的)和mut(可被修改的) 修饰。总共有5种可能的选择： struct Foo { a int // 私有的 不可变的 (default) mut: b int // 私有的 可变的 c int // (你可以一次列出，相同访问修饰符的字段) pub: d int // 公开的，不可变的 pub mut: e int // 公开的，但仅在父模块中可变 pub mut mut: f int // 公开的，父模块内部和外部都可变 } // (不建议使用，这就是为什么它如此冗长的原因) 例子，string 在 builtin 模块中定义的类型： struct string { str byteptr pub: len int } // 很容易看出 string 内容是不可变的 错误示例： fn main() { str := 'hello' len := str.len // OK str.len++ // 编译出错 } //具有字符串数据的字节指针根本无法在外部builtin访问。 len字段是公开的，但不是可变的。 结构体-方法 V 没有 class概念，但是我们可以在结构体上定义方法。 方法是具有特殊行参的函数。特殊行参 放在 fn关键字 和方法名之间的参数列表中。 简单示例（can_register 方法具有 User 类型的 特殊行参 u）： 不和其他语言一样，使用 self 或 this ，而是使用短名称，当然最好一个字母长 struct User { age int } fn (u User) can_register() bool { return u.age &gt; 16 } user := User{age: 10} println(user.can_register()) // ==&gt; \"false\" user2 := User{age: 20} println(user2.can_register()) // ==&gt; \"true\" 纯函数 V语言的函数默认是纯函数，也就是函数的输出结果只依赖输入的参数，并且没有其它的影响。 因为V语言没有全局变量，且所有的参数默认都是只读的，即使传入的引用也是默认只读的。 然后V语言并不纯的函数式语言。我们可以通过mut来修饰行参数，使得可以被修改： struct User { mut: is_registered bool } fn (u mut User) register() { u.is_registered = true } mut user := User{} println(user.is_registered) // ==&gt; \"false\" user.register() println(user.is_registered) // ==&gt; \"true\" 如上示例：特殊行参(这里被修饰了第一个参数) 被mut 修饰，为可变的。因此 register() 可以更改用户对象。 当然也适用于函数的普通参数,示例如下: fn multiply_by_2(arr mut []int) { for i := 0; i &lt; arr.len; i++ { arr[i] *= 2 } } mut nums := [1, 2, 3] multiply_by_2(mut nums) println(nums) // ==&gt; \"[2, 4, 6]\" 注意1：您必须在执行函数之前 声明一个 mut 的nums 变量。这清楚的表明被调用的函数将要修改该值！ 最好使用返回值而不是修改参数。修改参数只应在应用程序的性能关键部分中完成，以减少分配和复制。 使用user.register()或user = register(user) 代替register(mut user) fn register(u User) User { return { u | is_registered: true } } user = register(user) 常量 Constants 常量声明为const。它们只能在模块级别上（函数body外）定义。 常量名称必须大写。这有助于将它们与变量区分开来 永远不能改变常量值。 简单使用 const ( PI = 3.14 World = '世界' ) println(PI) println(World) 复杂类型的常量定义(这相对大多数语言更灵活) struct Color { r int g int b int } fn (c Color) str() string { return '{$c.r, $c.g, $c.b}' } //重写 str方法 fn rgb(r, g, b int) Color { return Color{r: r, g: g, b: b} } const ( Numbers = [1, 2, 3] Red = Color{r: 255, g: 0, b: 0} //结构体常量 Blue = rgb(0, 0, 255)//结构体常量 ) println(Numbers) println(Red) println(Blue) 不支持使用全局变量，因此这种方式显得非常有必要 模块 Modules V 语言是一个模块化的语言。鼓励创建可重用的模块，而且创建模块也非常简单。 新模块创建，请创建一个包含你模块名的目录 和 .v 代码文件： cd ~/code/modules mkdir mymodule vim mymodule/mymodule.v // mymodule.v module mymodule // 要用 pub修饰符修饰，外部才能访问该 模块函数 pub fn say_hi() { println('hello from mymodule!') } 模块的编译： 您可以在 你定义好的 模块目录下创建 更多的 .v模块文件 构建命令 v -lib ~/code/modules/mymodule ，然后就可以在代码中使用它 模块的使用： module main import mymodule fn main() { mymodule.say_hi() } 请注意，每次调用外部函数时都必须指定模块。这看起来似乎很冗长，但它使代码更易读，更容易理解，因为它始终清楚的表达出从哪个模块调用哪个函数。特别是在大型代码库中。 模块名称应短，不超过10个字符。模块不允许循环依赖。 您可以在任何地方创建模块 ,所有的模块都将静态编译到单一的可执行程序中。 接口 Interfaces 简单使用： 类型通过实现接口同名的方法（注意返回值也相同类型）。和Go语言一样,V语言也是隐式接口，类型不需要显式实现接口，没有“implements”关键字。 struct Dog {} struct Cat {} fn (d Dog) speak() string { return 'woof' } fn (c Cat) speak() string { return 'meow' } interface Speaker { speak() string } fn perform(s Speaker) { println(s.speak()) } dog := Dog{} cat := Cat{} perform(dog) // ==&gt; \"woof\" perform(cat) // ==&gt; \"meow\" 枚举 enum Color { red green blue } mut color := Color.red // 下面的写法要注意了，V语言知道 color的类型为Color，所以这个地方不需要使用 Color.green color = .green println(color) // ==&gt; \"1\" TODO: print \"green\"? 可选类型 和 错误处理 V语言针对函数返回值增加了一个可选的属性，这样可以用于处理失败的情况 可以用最小工作量来升级一个可选类型返回的函数：只需要在 返回值类型声明的前面添加一个 ?,这样就可以区别错误和真正的返回值。 当然如果你不需要返回错误，可以简单的使用 return None;（TODO：None尚未实现） 这是处理V中错误的主要手段。函数的返回值依然是值，但是错误处理要简洁很多。 struct User { id int name string } struct Repo { users []User } fn new_repo() Repo { return Repo { users: [User{1, 'Andrew'}, User {2, 'Bob'}, User {10, 'Charles'}] } } fn (r Repo) find_user_by_id(id int) ?User { for user in r.users { if user.id == id { // V 自动将其包装为 Option 类型 return user } } return error('User $id not found') } fn main() { repo := new_repo() user := repo.find_user_by_id(10) or { // Option类型必须使用 `or` 的代码块hold住； return // `or` 代码块必须以， return ,break,或 continue 关键字结束 } println(user.id) // ==&gt; \"10\" println(user.name) // ==&gt; 'Charles' } 当然，错误还可以继续传播： resp := http.get(url)? println(resp.body) 上面例子中，http.get return ?http.Response 的可选类型，如果错误发生，将传播到调用函数，这里是导致main函数抛出异常。 上面代码是下面代码的简写： resp := http.get(url) or { panic(err) } println(resp.body) 范型 Generics （预计7月上线） 为了方便阅读, 允许使用 ⟨⟩ 来代替 &lt;&gt;. vfmt 自动替换 ⟨⟩ 为&lt;&gt; . struct Repo⟨T⟩ { db DB } fn new_repo⟨T⟩(db DB) Repo⟨T⟩ { return Repo⟨T⟩{db: db} } // 这是一个范型函数. V 语言可以使用任意类型的范型 fn (r Repo⟨T⟩) find_by_id(id int) ?T { table_name := T.name // 在此示例中，获取类型的名称会得到表明 return r.db.query_one⟨T⟩('select * from $table_name where id = ?', id) } db := new_db() users_repo := new_repo⟨User⟩(db) posts_repo := new_repo⟨Post⟩(db) user := users_repo.find_by_id(1)? post := posts_repo.find_by_id(1)? 并发 并发模型与Go非常相似。要foo()同时运行，只需调用它go foo()，便会在新的系统线程执行该函数 . 很快 将实现 goroutines 和 scheduler 。 JSON 解析 JSON 在今天已经非常流行，这也是为什么要内置json支持的原因。 json.decode 函数的第一个参数是要解码的类型，第二个参数是 json字符串。 json 用于生成json 编码和解码的代码，不使用运行时反射，这也会带来更好的性能。 struct User { name string age int foo Foo [skip] //使用 skip 来跳过某些字段 } data := '{ \"name\": \"Frodo\", \"age\": 25 }' user := json.decode(User, data) or { eprintln('Failed to decode json') return } println(user.name) println(user.age) 单元测试 所有的单元测试都必须放在 *test.v 文件中，并且测试函数必须使用 test 开头方式命名。 若要运行 测试文件 hello_test.v 用来测试某整个模块，请执行命令 v test mymodule // hello.v fn hello() string { return 'Hello world' } // hello_test.v fn test_hello() { assert hello() == 'Hello world' } 内存管理 V语言没有自动内存回收（GC）和引用计数，V语言会在编译阶段完成必要的清理工作。例如： fn draw_text(s string, x, y int) { ... } fn draw_scene() { ... draw_text('hello $name1', 10, 10) draw_text('hello $name2', 100, 10) draw_text(strings.repeat('X', 10000), 10, 50) ... } 字符串 string 生命周期不会超出 draw_text 函数，因此当函数执行完时，它们将会被清除。实际上,前面两次调用根本不会导致任何分配，因为这两个字符串很小，V语言会使用提前准备好的缓冲区构造字符串。 对于更复杂的情况，需要手动内存管理，我们将很快实现解决。 V 将在运行时检测并报告内存泄露，例如：要清除数组，请使用 free() 方法： numbers := [0; 1000000] ... numbers.free() 延迟 Defer TODO vfmt TODO 进阶内容 V语言中调用C 函数 #flag -lsqlite3 #include \"sqlite3.h\" struct C.sqlite3 struct C.sqlite3_stmt fn C.sqlite3_column_int(C.sqlite_stmt, int) int fn main() { path := 'sqlite3_users.db' db := &amp;C.sqlite3{} C.sqlite3_open(path.cstr(), &amp;db) query := 'select count(*) from users' stmt := &amp;C.sqlite3_stmt{} C.sqlite3_prepare_v2(db, query.cstr(), - 1, &amp;stmt, 0) C.sqlite3_step(stmt) nr_users := C.sqlite3_column_int(res, 0) C.sqlite3_finalize(res) println(nr_users) } C strings 可以转换为 “string（cstring）”的V字符串 预编译if语句 预编译 使用 $if 。现在它只能用于检测操作系统。 $if windows { println('Windows') } $if linux { println('Linux') } $if mac { println('macOS') } 代码反射 有内置的 json支持已经是很不错的选择，但是V还允许使用者为任意添加高效的序列化程序。 // TODO: 计划6月上线 fn decode&lt;T&gt;(data string) T { mut result := T{} for field in T.fields { if field.typ == 'string' { result.$field = get_string(data, field.name) } else if field.typ == 'int' { result.$field = get_int(data, field.name) } } return result } // 生成: fn decode_User(data string) User { mut result := User{} result.name = get_string(data, 'name') result.age = get_int(data, 'age') return result } 有限的运算符重载 运算符重载违背了V的简单性和可预测性的理念。但由于科学和图形应用程序属于V域，因此为了提高可读性，运算符重载非常重要: a.add(b).add(c.mul(d))比 a + b + c * d 可读性差得多了。 struct Vec { x int y int } fn (a Vec) str() string { return '{$a.x, $a.y}' } fn (a Vec) + (b Vec) Vec { return Vec { a.x + b.x, a.y + b.y } } fn (a Vec) - (b Vec) Vec { return Vec { a.x - b.x, a.y - b.y } } fn main() { a := Vec{2, 3} b := Vec{4, 5} println(a + b) // ==&gt; \"{6, 8}\" println(a - b) // ==&gt; \"{-2, -2}\" } 为了提高安全性和可维护性，运算符重载 有几个局限性： 只能使用 +,=,* ,/ 运算符的重载 不允许运算符重载函数内调用其他函数 运算符重载函数无法修改其参数 运算符函数的两个参数必须具有相同类型，（同V中所有运算符一样,str+num =&gt; error） 内联汇编 TODO 尚未实现 fn main() { a := 10 asm x64 { mov eax, [a] add eax, 10 mov [a], eax } } 将 C/C++翻译成V TODO: 将C翻译为V将于6月上市。C ++到V将于今年晚些时候推出 V可以将您的C / C ++代码转换为可读的V代码。让我们先创建一个简单的程序test.cpp #include &lt;vector&gt; #include &lt;string&gt; #include &lt;iostream&gt; int main() { std::vector&lt;std::string&gt; s; s.push_back(\"V is \"); s.push_back(\"awesome\"); std::cout &lt;&lt; s.size() &lt;&lt; std::endl; return 0; } 允许命令 v translate test.cpp 将会得到 test.v: fn main { mut s := [] s &lt;&lt; 'V is ' s &lt;&lt; 'awesome' println(s.len) } 一个在线C / C ++到V的翻译即将推出. 什么时候应该翻译C代码，什么时候应该从V调用C代码？ 如果您有经过良好编写且经过良好测试的C代码，那么您当然可以直接从V调用此C代码 将其翻译为V有以下几个优点： 如果您计划开发该代码库，那么现在您可以使用一种语言编写所有内容，这样可以更安全，更容易开发 交叉编译(mac 编译打包 win程序)变得更加容易。您根本不必担心它。 没有更多的构建标志和包含文件。 热门代码重加载 TODO 交叉编译 (mac 编译打包 win程序) 要交叉编译项目，只需简单执行命令: v -os windows . v -os linux . （暂时无法对macOS进行交叉编译。） 如果您没有任何C依赖项，那就是您需要做的。即使在使用ui模块或图形应用程序编译GUI应用程序时也可以使用 gg。 您需要安装Clang，LLD链接器，并下载包含库和包含Windows和Linux文件的zip文件。V将为您提供链接。 V中的跨平台shell脚本 (6月下旬) V可以用作Bash的替代方案来编写部署脚本，构建脚本等。 使用V的优势在于语言的简单性和可预测性以及跨平台支持。“V脚本”在类Unix系统和Windows上运行。 使用#v指令启动程序。它将使os 模块中的所有函数全局化（您可以使用ls() 来代替os.ls() ）例如： #v rm('build/*') // 效果同: for file in ls('build/') { rm(file) } mv('*.v', 'build/') // 效果同: for file in ls('.') { if file.ends_with('.v') { mv(file, 'build/') } } 现在您可以像普通的V程序一样编译它，并获得可以在任何地方部署和运行的可执行文件： v deploy.v &amp;&amp; ./deploy (当然也可以使用传统脚本运行方式来允许它： v run deploy.v) 附录1：关键字 V 拥有22个关键字 break const continue defer else enum fn for go goto if import in interface match module mut or pub return struct type 附录2：运算符 运算符 运算符 含义 支持类型 + sum integers, floats, strings - difference integers, floats * product integers, floats / quotient integers, floats % remainder integers &amp; bitwise AND integers ｜ bitwise OR integers, floats ^ bitwise XOR integers &lt;&lt; left shift integer &lt;&lt; unsigned integer &gt;&gt; right shift integer &gt;&gt; unsigned integer 运算符优先级 优先级 运算符 5 * / % &lt;&lt; &gt;&gt; &amp; 4 + - ｜ ^ 3 == != &lt; &lt;= &gt; &gt;= 2 &amp;&amp; 1 ｜｜ 赋值运算符 += -= *= /= %= &amp;= |= ^= &gt;&gt;= &lt;&lt;=","categories":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}],"tags":[{"name":"V语言","slug":"v语言","permalink":"https://vlanguage.cn/tags/v语言/"}],"keywords":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}]},{"title":"GITHUB排行榜C位出道-手把手教你玩转V语言版的俄罗斯方块","slug":"BEYONDMA_94349691","date":"2019-07-01T00:00:00.000Z","updated":"2019-07-22T04:55:18.400Z","comments":true,"path":"2019/07/01/BEYONDMA_94349691.html","link":"","permalink":"https://vlanguage.cn/2019/07/01/BEYONDMA_94349691.html","excerpt":"","text":"&nbsp; &nbsp; 最近&nbsp;V 语言-一个GO语言最吸晴的项目，在千呼万唤之后，终于迎来开源，并正式发布了首个可用版本，其一经推出，便强势登顶&nbsp;GitHub的榜首，引来各方热议。目前V已经可以实现自我编译迭代，笔者大致了解了一下V语言，主要有如下一些特性。 &nbsp; &nbsp; 1.快速编译：&nbsp; V每CPU核心每秒编译约120万行代码。&nbsp; V也可以调用C，编译速度下降到≈100k行/秒/CPU。安全 &nbsp; &nbsp; 2.安全策略：没有空；没有全局变量(意味着变量都是在函数体中声明)&nbsp;没有未定义的行为&nbsp; &nbsp; &nbsp; 3.性能：和C一样快，操作C没有任何成本，不支持运行时反射，编译器只有400K,整个语言及其标准库都小于400kb。V目前是用V写的，你可以在0。4秒内完成。(到今年年底，这个数字将降至≈0.15秒。) &nbsp; &nbsp; 4.强大的图形能力:支持在GDI+/Cocoa绘图之上的跨平台绘图库，以及一个基于OpenGL的图形库，以支持加载复杂的三维对象与纹理 &nbsp; &nbsp;由于曾经做过一段时间的DIRECTX的开发，V语言对于图形能力的特性宣传最吸引笔者的注意。所以我到其官网及Github上学习了一下相关内容，按照编译运行了一下俄罗斯 方块的例程，接下来向大家做一下分享。 &nbsp; &nbsp;安装V语言 &nbsp; &nbsp; 如果只是HELLO WORLD程序是非常简单的，只需要按照https://vlang.io官网的标准步骤来执行即可。而如果使用其图形处理能力笔者目前只在UBANTU平台测试成功。下面均是以UBANTU为例来说明 &nbsp; &nbsp;首先将整个项目克隆下来，再make即可 git clone https://github.com/vlang/v cd v make &nbsp; &nbsp; 如果报curl command not found，则执行以下命令安装curl sudo apt install curl &nbsp; &nbsp; 接下来在建立软链接 sudo ln -s /home/machao/v/v /usr/local/bin/v &nbsp; 然后运行v就能进到v语言的命令行了。而如果要运行俄罗斯方块还需要以下这些库的支持， sudo apt install libglfw3 libglfw3-dev libfreetype6-dev libcurl3-dev &nbsp; &nbsp; &nbsp; &nbsp; 运行俄罗斯方块 &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 接下来cd tetris,进入到俄罗斯方块的目录，先使用gedit tetris.v,来看一下v语言的代码样例，其主要部分如下： &nbsp; &nbsp;&nbsp; fn main() { glfw.init()//实始化类 mut game := &amp;Game{gg: 0} // TODO game.parse_tetros() game.init_game() mut window := glfw.create_window(glfw.WinCfg { width: WinWidth height: WinHeight title: 'V Tetris' ptr: game // glfw user pointer }) window.make_context_current() window.onkeydown(key_down)//注册事件 gg.init() game.gg = gg.new_context(gg.Cfg { width: WinWidth height: WinHeight use_ortho: true // This is needed for 2D drawing }) go game.run() // Run the game loop in a new thread gl.clear() // For some reason this is necessary to avoid an intial flickering gl.clear_color(255, 255, 255, 255) for { gl.clear() gl.clear_color(255, 255, 255, 255) game.draw_scene() window.swap_buffers() glfw.wait_events() if window.should_close() { window.destroy() glfw.terminate() exit(0) } } } fn (g mut Game) move_right(dx int) { // Reached left/right edge or another tetro? for i := 0; i &lt; TetroSize; i++ { tetro := g.tetro[i] y := tetro.y + g.pos_y x := tetro.x + g.pos_x + dx row := g.field[y] if row[x] != 0 { // Do not move return } } g.pos_x += dx } fn (g mut Game) delete_completed_lines() { for y := FieldHeight; y &gt;= 1; y-- { g.delete_completed_line(y) } } fn (g mut Game) delete_completed_line(y int) { for x := 1; x &lt;= FieldWidth; x++ { f := g.field[y] if f[x] == 0 { return } } // Move everything down by 1 position for yy := y - 1; yy &gt;= 1; yy-- { for x := 1; x &lt;= FieldWidth; x++ { mut a := g.field[yy + 1] mut b := g.field[yy] a[x] = b[x] } } } // Place a new tetro on top fn (g mut Game) generate_tetro() { g.pos_y = 0 g.pos_x = FieldWidth / 2 - TetroSize / 2 g.tetro_idx = rand.next(BTetros.len) g.rotation_idx = 0 g.get_tetro() } // Get the right tetro from cache fn (g mut Game) get_tetro() { idx := g.tetro_idx * TetroSize * TetroSize + g.rotation_idx * TetroSize g.tetro = g.tetros_cache.slice(idx, idx + TetroSize) } fn (g mut Game) drop_tetro() { for i := 0; i &lt; TetroSize; i++ { tetro := g.tetro[i] x := tetro.x + g.pos_x y := tetro.y + g.pos_y // Remember the color of each block // TODO: g.field[y][x] = g.tetro_idx + 1 mut row := g.field[y] row[x] = g.tetro_idx + 1 } } fn (g &amp;Game) draw_tetro() { for i := 0; i &lt; TetroSize; i++ { tetro := g.tetro[i] g.draw_block(g.pos_y + tetro.y, g.pos_x + tetro.x, g.tetro_idx + 1) } } fn (g &amp;Game) draw_block(i, j, color_idx int) { g.gg.draw_rect((j - 1) * BlockSize, (i - 1) * BlockSize, BlockSize - 1, BlockSize - 1, Colors[color_idx]) } fn (g &amp;Game) draw_field() { for i := 1; i &lt; FieldHeight + 1; i++ { for j := 1; j &lt; FieldWidth + 1; j++ { f := g.field[i] if f[j] &gt; 0 { g.draw_block(i, j, f[j]) } } } } fn (g &amp;Game) draw_scene() { g.draw_tetro() g.draw_field() } fn parse_binary_tetro(t int) []Block { res := [Block{} ; 4] mut cnt := 0 horizontal := t == 9// special case for the horizontal line for i := 0; i &lt;= 3; i++ { // Get ith digit of t p := int(math.pow(10, 3 - i)) mut digit := int(t / p) t %= p // Convert the digit to binary for j := 3; j &gt;= 0; j-- { bin := digit % 2 digit /= 2 if bin == 1 || (horizontal &amp;&amp; i == TetroSize - 1) { // TODO: res[cnt].x = j // res[cnt].y = i mut point := &amp;res[cnt] point.x = j point.y = i cnt++ } } } return res } // TODO: this exposes the unsafe C interface, clean up fn key_down(wnd voidptr, key, code, action, mods int) { if action != 2 &amp;&amp; action != 1 { return } // Fetch the game object stored in the user pointer mut game := &amp;Game(glfw.get_window_user_pointer(wnd)) switch key { case glfw.KEY_ESCAPE: glfw.set_should_close(wnd, true) case glfw.KeyUp: // Rotate the tetro game.rotation_idx++ if game.rotation_idx == TetroSize { game.rotation_idx = 0 } game.get_tetro() if game.pos_x &lt; 0 { game.pos_x = 1 } case glfw.KeyLeft: game.move_right(-1) case glfw.KeyRight: game.move_right(1) case glfw.KeyDown: game.move_tetro() // drop faster when the player presses &lt;down&gt; } } &nbsp; &nbsp;我们看到这个程序是在这行代码window.onkeydown(key_down)来进行事件注册的，其渲染是在draw_scene函数进行渲染的。 使用v run tetris.v命令就能看到以下的效果了。左边是debug窗口，右边是程序效果。 &nbsp; &nbsp; &nbsp; &nbsp;后面笔者还会继续关注V语言的发展，为大家带来第一手的教程分享。","categories":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}],"tags":[{"name":"V语言","slug":"v语言","permalink":"https://vlanguage.cn/tags/v语言/"}],"keywords":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}]},{"title":"V语言环境部署教程-linux","slug":"qq_32394351_93966947","date":"2019-06-28T00:00:00.000Z","updated":"2019-07-22T04:55:19.225Z","comments":true,"path":"2019/06/28/qq_32394351_93966947.html","link":"","permalink":"https://vlanguage.cn/2019/06/28/qq_32394351_93966947.html","excerpt":"","text":"在linux系统上，目前有两种搭建V语言环境的方法: &nbsp; 一:git 下载源码并编译出可执行文件，然后创建软链接 二:直接下载别人编译好的可执行文件v&nbsp; ，然后改权限为可执行文件，再创建软链接 &nbsp; 下面用ubuntu为例来讲解。centos类似操作。 &nbsp; 方法一: 先请求临时管理员权限吧，后面懒得输sudo前缀 sudo -s su &nbsp;等会儿，然后输入当前用户的密码，那么就会发现路径用户名有了root前缀了 好了，接下来按步骤操作&nbsp; 1.如果是ubuntu desktop系统。那么先得安装git。命令: apt install git 也许还没有gcc,还得安装 apt install gcc 如果是ubuntu server 系统，什么也不用安，直接干。 好了，默认你已经把git和gcc安装好了。然后随便到一个路径克隆一下源码 比如我在当前用户的根目录创建一个v目录,然后切换到里面再git mkdir v cd v git clone https://github.com/vlang/v 等克隆完毕，然后输入&nbsp; ls&nbsp;&nbsp;发现路径里面躺着一个v路径了 那么接着进这个目录看看 cd v ls -alt &nbsp; &nbsp;可以看到这个完整的项目结构了，现在我们需要进去编译一下源码: cd compiler make ls &nbsp; 弄完发现已经有一个编译好的绿色的可执行文件躺在这路径里面了。 接着在当前路径执行一下这个文件试试: ./v 发现进入这个解释器了。我这刚编译的0.1.7版本 接着退出这个编译环境，按ctrl-d然后回车 &nbsp;接着创建一个软链接。首先看下当前目录的绝对路径 pwd 看出来绝对路径是/home/dashen/cp/v/compiler,那么创建软链接的命令是: ln -s /home/dashen/cp/v/compiler/v /usr/local/bin/v 我这里是因为之前创建过了，我先删除之前那个文件再来 rm /usr/local/bin/v ln -s /home/dashen/cp/v/compiler/v /usr/local/bin/v &nbsp;弄完了再输入一个v看看 &nbsp;ok。成功了。这里需要注意的是，创建软链接的命令是 ln -s 你的可执行文件路径 /usr/local/bin/v 注意空格，然后不要那么死板敲成我的路径了，敲你们自己的。哈哈。方法一到此结束。 &nbsp; 方法二： 直接下载别人编译好了的可执行文件v。比如你现在在windows下载好了v文件，然后要把windows里的v文件搞到linux里面去 &nbsp; 默认你用xshell通过ssh连接的linux主机。然后需要安装一个上传下载的包 apt install lrzsz 然后弄完了，因为是现在是root用户，直接从windows上把文件拖到xshell里面就能上传到linux主机当前路径了 &nbsp;然后输入ls查看一下路径: 发现有个白色的v文件躺在路径里面了。接下来很关键，我们要把它变成绿色的可执行文件 &nbsp;执行以下命令: chmod +x v ls 一个绿色的可执行文件已经躺在这儿了。 然后输入: ./v &nbsp; &nbsp;没毛病。已经进去了。接着返回第一种方法，然后创建软链接。就完了。。 &nbsp; 最后写在这儿，新手可能在windows与linux之间传输文件比较麻烦，可以不用命令，用可视化的工具，他的名字叫做: &nbsp; FileZilla 在电脑管家软件中心就能下载安装了，完了起来看起来长这样的: 左边windows，右边linux，然后自己随便玩玩就会了。最后我再演示一下怎么在刚弄好的v环境编写个程序测试一下: &nbsp; 在linux下找到一个干净的路径创建一个c.v文件，千万别弄在v源码里面，具体代码看图参考: &nbsp;然后就进入了vim编辑器里面了，咱们编译一下c.v文件。先按字母键i,让vim编辑器处于insert状态 &nbsp;然后在里面写代码: 完了按ESC键，再按冒号（shift+分号键），输入wq,回车 &nbsp;这是保存并退出的意思。然后再输入v run c.v 成功了，随便happy吧，这里只是演示了一下mut的用法，用了mut申明的变量，后面就能够直接通过=改变它的值 如果不用mut申明的变量，初始化完了后面就不能再用=改变它的值了。&nbsp; &nbsp; 附录:&nbsp;Linux常用的50个命令","categories":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}],"tags":[{"name":"V语言","slug":"v语言","permalink":"https://vlanguage.cn/tags/v语言/"}],"keywords":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}]},{"title":"V语言关键字解读","slug":"qq_32394351_93883296","date":"2019-06-27T00:00:00.000Z","updated":"2019-07-22T04:55:19.178Z","comments":true,"path":"2019/06/27/qq_32394351_93883296.html","link":"","permalink":"https://vlanguage.cn/2019/06/27/qq_32394351_93883296.html","excerpt":"","text":"官方文档:https://vlang.io/docs#keywords V has 22 keywords: break const continue defer else enum fn for go goto if import in interface match module mut 用于申明可变变量，申明并初始化后的变量在后面可以直接用=赋值，不用mut申明的变量后面不可改变。例如: mut name:='dashen' println(name) name='dada' println(name) or pub return struct type","categories":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}],"tags":[{"name":"V语言","slug":"v语言","permalink":"https://vlanguage.cn/tags/v语言/"}],"keywords":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}]},{"title":"V语言初探","slug":"huangruifeng_93908166","date":"2019-06-27T00:00:00.000Z","updated":"2019-07-22T04:55:18.900Z","comments":true,"path":"2019/06/27/huangruifeng_93908166.html","link":"","permalink":"https://vlanguage.cn/2019/06/27/huangruifeng_93908166.html","excerpt":"","text":"V语言，感觉厉害。。。。。。 人家的Helloworld只需这样 fn main() { println('hello world') } 就是短小精悍。 居然还有泛型，这个可是连我们可以到处GO的都没有。 struct Repo &lt;T&gt; { db DB } fn new_repo&lt;T&gt;(db DB) Repo&lt;T&gt; { return Repo&lt;T&gt;{db: db} } // This is a generic function. V will generate it for every type it's used with. fn (r Repo&lt;T&gt;) find_by_id(id int) T? { table_name := T.name // in this example getting the name of the type gives us the table name return r.db.query_one&lt;T&gt;('select * from $table_name where id = ?', id) } fn main() { db := new_db() users_repo := new_repo&lt;User&gt;(db) posts_repo := new_repo&lt;Post&gt;(db) user := users_repo.find_by_id(1)? post := posts_repo.find_by_id(1)? } V语言官网地址:https://vlang.io V语言Github地址:https://github.com/vlang/v","categories":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}],"tags":[{"name":"V语言","slug":"v语言","permalink":"https://vlanguage.cn/tags/v语言/"}],"keywords":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}]},{"title":"V 语言强势登顶 GitHub TOP1，难道要取 Go 而代之？","slug":"yihuliunian_93874487","date":"2019-06-27T00:00:00.000Z","updated":"2019-07-22T04:55:19.842Z","comments":true,"path":"2019/06/27/yihuliunian_93874487.html","link":"","permalink":"https://vlanguage.cn/2019/06/27/yihuliunian_93874487.html","excerpt":"","text":"这个结合了 Go 和 Rust 特性的新语言 V，正式发布了首个可用版本。 整理 | 郭芮 长久以来，编程语言在语法、语义和标准库等方面都存在着千差万别，使得程序员在选择时不得不面临着差异化等难题。自然选择下，就会有旧语言的淘汰（PHP 是个意外，至今还存在）和新语言的诞生。在&nbsp;JetBrains 最新发布的《2019 开发人员生态系统现状》报告中，Java、Python、C/C#、JavaScript 等主流的编程语言在历经实践考验后依然是开发者们的心头好。 而本文的主角 V 语言，在千呼万唤之后，终于于近日开源了，并正式发布了首个可用版本（预构建的二进制文件也即将推出）！其一经发布，便强势登顶&nbsp;GitHub TOP1，引来开发者们的热议围观。 &nbsp; &nbsp; （https://github.com/vlang/v/releases/tag/v0.0.12） 根据介绍，V 是一种新型的静态编译型语言，可以“快速编译、安全且和 C/C++ 转换”，其提供了方便、快捷、安全的编程语言和工具包，还能够很好地服务于区块链技术。 V 语言作者 Reishi Saza 就表示，它是一种非常简单的语言，看官方文档 30 分钟就能完全掌握。而且，其编译器只有 400KB，无任何第三方依赖。 （作者展示的应用示例：V 语言建立的 macOS Demo） V 的核心 CPU 每秒可以编译大约 120 万行代码，这种速度是通过生成的机器代码和强大的模块化来实现的，但是目前仅支持 x64/Mach-O，预计到今年年底才能足够稳定。而在性能表现上，V 可以做到和 C 一样快，且能够翻译整个 C 或 C++ 项目，实现高达 400x 的编译速度。 std::vector&lt;std::string&gt;&nbsp;s;s.push_back(\"V&nbsp;is&nbsp;\");s.push_back(\"awesome\");std::cout&nbsp;&lt;&lt;&nbsp;s.size();mut&nbsp;s&nbsp;:=&nbsp;[]s&nbsp;&lt;&lt;&nbsp;\"V&nbsp;is&nbsp;\"s&nbsp;&lt;&lt;&nbsp;\"awesome\"println(s.len) &nbsp; 目前，整个 V 语言及其标准库小于 400 KB，开发者在 0.4 秒内就可以构建它。并且到今年年底，这个数字还将下降到大约 0.15 秒。 此外，开发者们还在官网上放出了部分示例代码。更多编译器函数介绍可参见官方网站：https://vlang.io/。 1、数据库访问： struct&nbsp;User&nbsp;{&nbsp;/*&nbsp;...&nbsp;*/&nbsp;}struct&nbsp;Post&nbsp;{&nbsp;/*&nbsp;...&nbsp;*/&nbsp;}struct&nbsp;DB&nbsp;&nbsp;&nbsp;{&nbsp;/*&nbsp;...&nbsp;*/&nbsp;}struct&nbsp;Repo&nbsp;&lt;T&gt;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;db&nbsp;DB}fn&nbsp;new_repo&lt;T&gt;(db&nbsp;DB)&nbsp;Repo&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Repo&lt;T&gt;{db:&nbsp;db}}fn&nbsp;(r&nbsp;Repo)&nbsp;find_by_id(id&nbsp;int)&nbsp;T?&nbsp;{&nbsp;//&nbsp;`?`&nbsp;means&nbsp;the&nbsp;function&nbsp;returns&nbsp;an&nbsp;optional&nbsp;&nbsp;&nbsp;&nbsp;table_name&nbsp;:=&nbsp;T.name&nbsp;//&nbsp;in&nbsp;this&nbsp;example&nbsp;getting&nbsp;the&nbsp;name&nbsp;of&nbsp;the&nbsp;type&nbsp;gives&nbsp;us&nbsp;the&nbsp;table&nbsp;name&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;r.db.query_one&lt;T&gt;(\"select&nbsp;*&nbsp;from&nbsp;$table_name&nbsp;where&nbsp;id&nbsp;=&nbsp;?\",&nbsp;id)}fn&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;db&nbsp;:=&nbsp;new_db()&nbsp;&nbsp;&nbsp;&nbsp;users_repo&nbsp;:=&nbsp;new_repo&lt;User&gt;(db)&nbsp;&nbsp;&nbsp;&nbsp;posts_repo&nbsp;:=&nbsp;new_repo&lt;Post&gt;(db)&nbsp;&nbsp;&nbsp;&nbsp;user&nbsp;:=&nbsp;users_repo.find_by_id(1)&nbsp;or&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eprintln(\"User&nbsp;not&nbsp;found\")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;post&nbsp;:=&nbsp;posts_repo.find_by_id(1)&nbsp;or&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eprintln(\"Post&nbsp;not&nbsp;found\")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;}}&nbsp; &nbsp; 2、网络开发： struct&nbsp;Story&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;title&nbsp;string}//&nbsp;Fetches&nbsp;top&nbsp;HN&nbsp;stories&nbsp;in&nbsp;8&nbsp;coroutines&nbsp;fn&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;resp&nbsp;:=&nbsp;http.get(\"https://hacker-news.firebaseio.com/v0/topstories.json\")?&nbsp;&nbsp;&nbsp;&nbsp;ids&nbsp;:=&nbsp;json.decode([]int,&nbsp;resp.body)?&nbsp;&nbsp;&nbsp;&nbsp;mut&nbsp;cursor&nbsp;:=&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;_&nbsp;in&nbsp;0..8&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;go&nbsp;fn()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;{&nbsp;//&nbsp;Without&nbsp;this&nbsp;lock&nbsp;the&nbsp;program&nbsp;will&nbsp;not&nbsp;compile&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;cursor&nbsp;&gt;=&nbsp;ids.len&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id&nbsp;:=&nbsp;ids[cursor]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cursor++&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resp&nbsp;:=&nbsp;http.get(\"https://hacker-news.firebaseio.com/v0/item/$id.json\")?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;story&nbsp;:=&nbsp;json.decode(Story,&nbsp;resp.body)?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(story.title)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}()&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;runtime.wait()&nbsp;//&nbsp;Waits&nbsp;for&nbsp;all&nbsp;coroutines&nbsp;to&nbsp;finish&nbsp;}&nbsp; &nbsp; 当然，目前V 语言的开发仍处于早期阶段，很多方面还不够完善，尤其是内存管理上还面临着与 Go 和 Rust 同样繁琐的生命期管理问题，但对比 C++ 等手动和半自动的管理方式还是更省心一些的。 那么开发者们怎么看？ @三川走刀口：还是要得到开发者认可，但是对于安卓开发好像没用？ @淡定的龙哥：Go语言同父异母的弟弟？ @Heisenber哥：语言特性只是一方面，生态也很重要。 @王的凝视：这个新语言提出来是为了解决什么问题？每种语言都有适合场景，如果没有合适场景迟早也要被淘汰。 @楚小欢：执行效率比C高应该不可能，C现在都被认为是汇编语言，本身语义也十分接近汇编。别的语言只要有高级点的特性，效率就不可能超过C。 &nbsp; 总之，这个新生的 V 语言还是需要不断的发展，得到开发者的广泛应用才能焕发生机，也才能有望助力程序员做到真正的“人剑合一”。 品略图书馆 http://www.pinlue.com/ &nbsp; &nbsp;","categories":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}],"tags":[{"name":"V语言","slug":"v语言","permalink":"https://vlanguage.cn/tags/v语言/"}],"keywords":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}]},{"title":"年轻人的第一篇V语言笔记","slug":"zjbyough_93663256","date":"2019-06-25T00:00:00.000Z","updated":"2019-07-22T04:55:19.894Z","comments":true,"path":"2019/06/25/zjbyough_93663256.html","link":"","permalink":"https://vlanguage.cn/2019/06/25/zjbyough_93663256.html","excerpt":"","text":"V语言极限学习 我听说V语言看文档半小时就能完全掌握？？？？以我的智商一小时掌握不了我就给各位科普一下广告法？？？ 宇宙惯例hello world // first v code fn main(){ printIn(\"hello world\") } 不需要行结束符 v函数使用fn声明，和其他语言一样，main函数是程序入口 注释规则和c一样 输出使用内置函数 printIn() 宇宙惯例2. 1+1 fn main(){ a := 1 b := 2 mut name := \"v langue\" name = \"v\" printIn(add(a,b)) } fn add(a int,b int) int { return a+b } 变量名在类型名之前（反人类） 函数和变量都可以提前，也就是可以“先调用，再声明” 变量用:=声明并初始化，变量默认不允许修改，要修改必须加 mut 修改变量用 = v没有全局变量，变量只能在函数中定义 定义的变量必须使用，不允许只定义，不使用，和go像 子代码块中不允许使用父代码块中已经定义的变量,如下面的代码会编译出错 fn main(){ a := 20 if true{ a := 30 } } 基本数据类型 string 在V中，字符串是只读字节数组。 字符串数据使用UTF-8编码。 单引号和双引号都可用于表示字符串（TODO：尚不支持双引号）。 为保持一致性，vfmt将双引号转换为单引号，除非该字符串包含单引号字符。 字符串是不可变的。 这意味着子字符串函数非常有效：不执行复制，不需要额外的分配。 All operators in V must have values of the same type on both sides. This code will not compile if age is an int: println('age = ’ + age) We have to either convert age to a string: println('age = ’ + age.str()) or use string interpolation (preferred): println(‘age = $age’) 翻译 V中的所有运算符必须在两边都具有相同类型的值。如果age是int: println(‘age = ’ + age’)，这段代码将无法编译。我们必须将age转换为一个字符串:println('age = ’ + age.str())或使用字符串插值(preferred): println(‘age = ’ $age’) 数组 fn main(){ a := [1,2,3] printIn(a) } 数组类型由数组第一个元素决定 数组中元素类型必须相同 使用&lt;&lt;在数组末尾插入元素 使用.len返回数组长度 val in array,如果数组array包含val，返回true 字典 mut m := map[string]int{} // Only maps with string keys are allowed for now m['one'] = 1 println(m['one']) // ==&gt; \"1\" 这个字典人家似乎还没有写好，emmmm，一堆TODO，你先写着，咱不急，看下一个 流程控制 if a := 10 b := 20 if a &lt; b { println('$a &lt; $b') } else if a &gt; b { println('$a &gt; $b') } else { println('$a == $b') } 条件没有小括号 始终有大括号 if语句可以作为一个表达式 num := 777 s := if num % 2 == 0 { 'even' } else { 'odd' } println(s) // ==&gt; \"odd\" in 作用： 检查数组中是否含有某个元素 布尔表达式，如： if parser.token == .plus || parser.token == .minus || parser.token == .div || parser.token == .mult { ... } if parser.token in [.plus, .minus, .div, .mult] { ... } 上下两个是等价的，使用下面的语法时，v不会创建数组 for for比较牛逼，因为我看他文档写的比之前的都多…(狗头)，知道为啥吗，应为v只有一种循环，就是for，哈哈哈哈 虽然只有一种循环，但人家for有好几种啊~~~ for in fn main(){ list := ['a','b','c'] for value in list{ printIn(value) } } value-in 如果需要数据的索引，可以用另一种方法 names := ['Sam', 'Peter'] for i, name in names { println('$i) $name') // Output: 0) Sam } // 1) Peter 第二种for(类似于while) mut sum := 0 mut i := 0 for i &lt;= 100 { sum += i i++ } println(sum) // ==&gt; \"5050\" 不写条件将导致死循环 第三种for(类似c) for i := 0; i &lt; 10; i++ { println(i) } 为啥这儿的i不用加mut而可以变化？？别问，文档这么写的！！！ Here i doesn’t need to be declared with mut since it’s always going to be mutable by definition. switch os := 'windows' print('V is running on ') switch os { case 'darwin': println('macOS.') case 'linux': println('Linux.') default: println(os) } 这里的switch和c里的差不多，只不过v中不需要在每个case后面加break 结构体 结构体？？？你可别告诉我你面向过程啊 struct Point { x int y int } p := Point{ x: 10 y: 20 } println(p.x) // Struct fields are accessed using a dot 属性访问用. 结构是在堆栈上分配的。若要在堆上分配结构并获取指向它的指针，请使用&amp;,如 pointer := &amp;Point{10, 10} // 有三个或更少字段的结构体可使用这种替代写法 println(pointer.x) // 用指针访问值和其他一样，都用. 结构体嵌套，目前还不支持，不过快了 // 就直接复制了，他支持了再说（到时候我也不一定看） V doesn't have subclassing, but it supports embedded structs: // TODO: this will be implemented later in June struct Button { Widget title string } button := new_button('Click me') button.set_pos(x, y) // Without embedding we'd have to do button.widget.set_pos(x,y) 访问修饰符 默认的结构体是私有的，不可变的，可以使用访问修饰符pub 和 mut 修改，pub和mut有五种组合（不明白了吧，还有一种pub mut mut）,先把文档复制过来再看是个什么妖魔 struct Foo { a int // private immutable (default) mut: b int // private mutable c int // (you can list multiple fields with the same access modifier) pub: d int // public immmutable (readonly) pub mut: e int // public, but mutable only in parent module pub mut mut: f int // public and mutable both inside and outside parent module } // (not recommended to use, that's why it's so verbose) 访问修饰符 作用 不写（默认） 私有，不可变 mut 私有，可变 pub 公有，不可变 pub mut 公有，仅在父模块可变 pub mut mut 公有，父模块内部外部都可变 一脸懵逼是吧，哈哈哈，依老衲看来，这和c++中的public，private啥的一样，只不过他的变量（不能叫变量吧，先这样叫）默认是常量（const）你定义时需要加一个mut才能变成其他语言的“变量”，加一个pub这个变量就变成公有变量，从结构体外部可以访问了，加一个pub mut他就在结构体内外可以访问，而只能在结构体内部能改变，如字符串结构体中的len，外部可以访问他，但不能改变它，内部才能改变，最后pub mut mut 就是内外都可以访问，都可以修改。 Methods，方法 v没有class 吓死我了，辛亏有方法 一个方法就是一个函数，它带一个特殊的参数（接收器） // 继续粘贴文档代码，CV工程师，年薪百万，啊啊啊啊啊啊啊啊 struct User { age int } fn (u User) can_register() bool { return u.age &gt; 16 } user := User{age: 10} println(user.can_register()) // ==&gt; \"false\" user2 := User{age: 20} println(user2.can_register()) // ==&gt; \"true\" 这里的can_register就是一个方法，他的接收器是u，类型是User，官方说接收器名字最好用简短的，别用self，this啥的，一个字母最好（要不然没特色，开玩笑的） Pure functions by default 英语捉急，无法翻译，大概就是默认的纯函数，应为V没有全局变量，加上变量默认不能改变，哪怕是传参时也一样， 后面开始赋值粘贴了 struct User { mut: is_registered bool } fn (u mut User) register() { u.is_registered = true } mut user := User{} println(user.is_registered) // ==&gt; \"false\" user.register() println(user.is_registered) // ==&gt; \"true\" fn multiply_by_2(arr mut []int) { for i := 0; i &lt; arr.len; i++ { arr[i] *= 2 } } mut nums := [1, 2, 3] multiply_by_2(mut nums) println(nums) // ==&gt; \"[2, 4, 6]\" 注意，在调用此函数时，必须在nums之前添加mut。 这清楚地表明被调用的函数将修改该值。 最好返回值而不是修改参数。修改参数应该只在应用程序的性能关键部分执行，以减少分配和复制。 使用user.register()或user = register(user)代替register(mut user)。 V可以很容易地返回对象的修改版本： fn register(u User) User { return { u | is_registered: true } } user = register(user) 常量const const ( PI = 3.14 World = '世界' ) println(PI) println(World) 常量使用const声明。 它们只能在模块级别(函数之外)定义。 常量名称必须大写。这有助于将它们与变量区分开来。 常数永远不会改变。 V常量比大多数语言更灵活。您可以分配更复杂的值 struct Color { r int g int b int } fn (c Color) str() string { return '{$c.r, $c.g, $c.b}' } fn rgb(r, g, b int) Color { return Color{r: r, g: g, b: b} } const ( Numbers = [1, 2, 3] Red = Color{r: 255, g: 0, b: 0} Blue = rgb(0, 0, 255) ) println(Numbers) println(Red) println(Blue) 不允许使用全局变量，因此这非常有用。 模块化 V是一种非常模块化的语言。鼓励创建可重用模块，而且非常简单。要创建一个新模块，请创建一个目录，其中包含模块的名称和.v文件 cd ~/code/modules mkdir mymodule vim mymodule/mymodule.v // mymodule.v module mymodule // To export a function we have to use `pub` pub fn say_hi() { println('hello from mymodule!') } 你可以在mymodule /中拥有尽可能多的.v文件。 使用v -lib~ / code / modules / mymodule构建它。 就是这样，您现在可以在代码中使用它 module main import mymodule fn main() { mymodule.say_hi() } 注意，每次调用外部函数时都必须指定模块。 模块名称应该简短，不超过10个字符。 不允许循环导入。 您可以在任何地方创建模块。 所有模块都被静态地编译成一个可执行文件。 看了两个小时了，还没看完，以我的智商，算是告别代码界了，再见各位，我自闭了","categories":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}],"tags":[{"name":"V语言","slug":"v语言","permalink":"https://vlanguage.cn/tags/v语言/"}],"keywords":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}]},{"title":"vlang,v语言","slug":"wyyyh9458_93377612","date":"2019-06-23T00:00:00.000Z","updated":"2019-07-22T04:55:19.545Z","comments":true,"path":"2019/06/23/wyyyh9458_93377612.html","link":"","permalink":"https://vlanguage.cn/2019/06/23/wyyyh9458_93377612.html","excerpt":"","text":"AD: http://a.scwy.net/ 无意中看到．https://vlang.io/，还有网友很积极的来了个中文网 https://www.v-lang.cn/ 安装： mkdir -p ~/code &amp;&amp; cd ~/code # ~/code directory has to be used (it's a temporary limitation) git clone https://github.com/vlang/v cd v/compiler wget https://vlang.io/v.c # Download the V compiler's source translated to C cc -w -o vc v.c # Build it with Clang or GCC ./vc -o v . # Use the resulting V binary to build V from V source 文档：https://vlang.io/docs 学起来还是满快，类golang．代码够简，只是这个库太少，生态不够．发展尚需时日． 特点据说是：编(译)得快，安全，高性能，编译器小(400kb)，０依赖，翻译为C语言，代码热载，强大图形库，通用图形界面库，交叉编译． 当我重新再次编译的时候出现：段错误 (核心已转储)．它在用户目录建立了.vlang0.0.12,删除它，依然不行..... 看来必须用code目录，这个有点搞笑了....重编译好后，将v目录移到其它目录，它将出现库不存在等问题（依然在找code目录) 删之，表示稍微关注. -------------------------------------------------------------------------------------------------- 就统计看到的访问数据，还有比较多人（浏览器？）来关注这个v．路漫漫...不过还是多鼓励，少放气．优点还是有的，假以时日或许也会有一定使用者．生态很重要． 这里还有网友的评论：V 语言强势登顶 GitHub TOP1，欲取 Go 而代之 －＞https://blog.csdn.net/csdnnews/article/details/93550448 &nbsp; ---------------------------------------------------------------------------------------------------- https://vlang.ide.judge0.com/&nbsp; 在线编辑运行","categories":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}],"tags":[{"name":"V语言","slug":"v语言","permalink":"https://vlanguage.cn/tags/v语言/"}],"keywords":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}]},{"title":"V语言正式开源","slug":"chai2010_93377522","date":"2019-06-22T00:00:00.000Z","updated":"2019-07-22T04:55:18.833Z","comments":true,"path":"2019/06/22/chai2010_93377522.html","link":"","permalink":"https://vlanguage.cn/2019/06/22/chai2010_93377522.html","excerpt":"","text":"V语言今天正式，欢迎访问V语言中文网：https://vlang-zh.cn/ Hello, world 在线运行：https://vlang.io/play fn&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;areas&nbsp;:=&nbsp;['game',&nbsp;'web',&nbsp;'tools',&nbsp;'science',&nbsp;'systems',&nbsp;'GUI',&nbsp;'mobile']&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;area&nbsp;in&nbsp;areas&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println('Hello,&nbsp;$area&nbsp;developers!')&nbsp;&nbsp;&nbsp;&nbsp;}}&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;area&nbsp;in&nbsp;areas&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println('Hello,&nbsp;$area&nbsp;developers!')&nbsp;&nbsp;&nbsp;&nbsp;}} 扫码加入V语言微信群 注：如果二维码过期，可以通过“光谷码农”微信公众号底部菜单扫码进入。 开发状态 V语言还处于非常早期的开发阶段。很多特性都标记为开发中状态（WIP，work in progress）。不过此页面相关的内容和代码都会在2019年6月22号开源。如果所有的WIP开发工作都完成，那么将是发布V1.0的时候。 V语言的特色 快速编译 在Intel i5-7500 @ 3.40GHz, SM0256L SSD没有优化的环境，每秒钟可以编译120万行V代码。这是通过模块化和直接输出机器码来实现快速编译的。 V语言编译器也可以直接输出C语言代码，但是输出的性能将下降到10行每秒钟。 注：直接输出机器码还处于非常早期的阶段，目前只支持X64环境的Mach-O格式的目标文件。因此目前必须先输出C代码再进行编译。 安全 性能 用于构建可维护程序的简洁语言 你可以在半个小说读完全部的自带文档。虽然简洁，但是不简单！你可以用V语言做任何其它语言可以做的事情！ 编译器400KB，零依赖 语言的标准库小雨400KB。V语言已经自举，用V语言编写，可以在0.4秒内构建（到今年地，时间继续降到0.15秒）。 时间对比： 语言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内存大小&nbsp;&nbsp;&nbsp;&nbsp;编译时间Go&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;525&nbsp;MB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1m&nbsp;33sRust&nbsp;&nbsp;&nbsp;&nbsp;30&nbsp;GB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;45mGCC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;GB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;50mClang&nbsp;&nbsp;&nbsp;90&nbsp;GB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;25mSwift&nbsp;&nbsp;&nbsp;70&nbsp;GB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;90mV&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.4&nbsp;MB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.4sGo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;525&nbsp;MB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1m&nbsp;33sRust&nbsp;&nbsp;&nbsp;&nbsp;30&nbsp;GB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;45mGCC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;GB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;50mClang&nbsp;&nbsp;&nbsp;90&nbsp;GB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;25mSwift&nbsp;&nbsp;&nbsp;70&nbsp;GB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;90mV&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.4&nbsp;MB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.4s 目前V语言只依赖C语言编译器，用于启动。一旦语言完备，就可以不再需要C语言编译器。 先在0.4秒内构建V，然后使用生成的编译器再次构建自己： C/C++代码到V代码 V可以翻译整个C/C++代码到V代码，以享受带来的安全性、简单性和高达400x的编译速度。 比如C++代码： std::vector&lt;std::string&gt;&nbsp;s;s.push_back(\"V&nbsp;is&nbsp;\");s.push_back(\"awesome\");std::cout&nbsp;&lt;&lt;&nbsp;s.size();vector&lt;std::string&gt;&nbsp;s;s.push_back(\"V&nbsp;is&nbsp;\");s.push_back(\"awesome\");std::cout&nbsp;&lt;&lt;&nbsp;s.size(); 将翻译为以下V代码： mut&nbsp;s&nbsp;:=&nbsp;[]s&nbsp;&lt;&lt;&nbsp;'V&nbsp;is&nbsp;'s&nbsp;&lt;&lt;&nbsp;'awesome'println(s.len)s&nbsp;&lt;&lt;&nbsp;'awesome'println(s.len) 关于翻译DOOM的博客文章即将发布。 翻译几乎支持全部的C语言标准，但是对C++对支持还处于早期阶段。上面是简单的例子，复杂的C++代码可能有困难。C++是一个比较复杂的语言，我们希望今年年底能完成这个工作。 更多的信息请访问V语言中文网：https://vlang-zh.cn/","categories":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}],"tags":[{"name":"V语言","slug":"v语言","permalink":"https://vlanguage.cn/tags/v语言/"}],"keywords":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}]}]}