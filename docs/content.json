{"meta":{"title":"V语言中文社区","subtitle":null,"description":null,"author":null,"url":"https://vlanguage.cn"},"pages":[],"posts":[{"title":"循序渐进:V语言0.1.3版本更新,vlang命令介绍","slug":"vlang-command","date":"2019-07-18T08:01:27.000Z","updated":"2019-07-18T02:46:38.987Z","comments":true,"path":"2019/07/18/vlang-command.html","link":"","permalink":"https://vlanguage.cn/2019/07/18/vlang-command.html","excerpt":"","text":"6月26日，vlang官网(https://vlang.io)已更新版本到0.1.3,同时发布了linux平台及macOS平台编译好的二进制文件供下载，windows平台暂无，不久会发布。该版本修复了vlang之前编译会报错的+=、*=等运算符，同时也更新了v命令，现整理v命令如下：1.直接运行v，将进入交互式编程环境(REPL)2.编译.v文件v file.v 这里将file.v文件编译为二进制可执行文件file，如需运行，请在执行./file。 默认情况下，生成的可执行文件的名称和.v文件名相同，如果在编译时修改，可执行v -o &lt;程序名&gt; file.v 3.编译并运行.v文件 v run file.v 4.细心的同学会发现，每次编译完.v文件后，不仅会生成二进制可执行文件，同时还会生成一个file.dSYM的文件夹，对于有洁癖的同学来说时难以忍受的，其实只要运行以下命令就会只生成纯粹的可执行文件，不会生成“烦人”的file.dSYM文件夹 v -prod file.v P.S:以上-o、-prod参数可以混合使用������以上内容若有不足之处，欢迎朋友们指正！","categories":[{"name":"前沿资讯","slug":"前沿资讯","permalink":"https://vlanguage.cn/categories/前沿资讯/"}],"tags":[{"name":"V语言","slug":"v语言","permalink":"https://vlanguage.cn/tags/v语言/"}],"keywords":[{"name":"前沿资讯","slug":"前沿资讯","permalink":"https://vlanguage.cn/categories/前沿资讯/"}]},{"title":"千呼万唤始出来:V语言终于开源上线啦","slug":"vlanguage-source","date":"2019-07-18T07:01:27.000Z","updated":"2019-07-18T02:46:59.571Z","comments":true,"path":"2019/07/18/vlanguage-source.html","link":"","permalink":"https://vlanguage.cn/2019/07/18/vlanguage-source.html","excerpt":"","text":"V语言正式开源啦！经过漫长的等待，Vlang终于开源，当前开源的版本是0.0.12。目前还没有提供已经编译好的二进制版本供大家下载，只能通过源码编译的方式（其实作者在6月18号短暂上线了一会macos平台的vlang二进制文件）。Vlang源码编译地址及编译方法可访问：https://github.com/vlang/v#installing-v-from-source。现摘抄编译步骤如下(P.S:如果有的同学https://vlang.io/v.c 访问超时，可以替换为https://assets.v-lang.cn/downloads/v.c):Linux and macOSmkdir ~/code &amp;&amp; cd ~/code # ~/code directory has to be used (it's a temporary limitation) git clone https://github.com/vlang/v cd v/compiler make # Or build without make: wget https://vlang.io/v.c # Download the V compiler's source translated to C // 下载C实现的V编译器源码 cc -std=c11 -w -o vc v.c # Build it with Clang or GCC // 用Clang编译C实现的V编译器 ./vc -o v . &amp;&amp; rm vc # Use the resulting V binary to build V from V source, delete the old compiler // 用C实现的V编译器编译V实现的V编译器That's it! Now you have a V executable at&nbsp;~/code/v/compiler/v.Bootstrap the compiler to make sure it works:./v -o v . # 用V实现的V编译器编译V编译器源码，所谓的语言自举 You can create a symlink so that it's globally available:sudo ln -s ~/code/v/compiler/v /usr/local/bin/vWindowsV works great on Windows Subsystem for Linux. The instructions are the same as above.If you want to build v.exe on Windows without WSL, you will need Visual Studio. Microsoft doesn't make it easy for developers. Mingw-w64 could suffice, but if you plan to develop UI and graphical apps, VS is your only option.V temporarily can't be compiled with Visual Studio. This will be fixed asap.Testing$ v V 0.0.12 Use Ctrl-D to exit &gt;&gt;&gt; println('hello world') hello world &gt;&gt;&gt; Now if you want, you can start tinkering with the compiler. If you introduce a breaking change and rebuild V, you will no longer be able to use V to build itself. So it's a good idea to make a backup copy of a working compiler executable.Running the examplesv hello_world.v &amp;&amp; ./hello_world # or simply v run hello_world.v # This builds the program and runs it right away v word_counter.v &amp;&amp; ./word_counter cinderella.txt v news_fetcher.v &amp;&amp; ./news_fetcher v tetris.v &amp;&amp; ./tetris In order to build Tetris and anything else using the graphics module, you will need to install glfw and freetype.If you plan to use the http package, you also need to install libcurl.glfw and libcurl dependencies will be removed soon.Ubuntu: sudo apt install glfw libglfw3-dev libfreetype6-dev libcurl3-dev macOS: brew install glfw freetype curl","categories":[{"name":"前沿资讯","slug":"前沿资讯","permalink":"https://vlanguage.cn/categories/前沿资讯/"}],"tags":[{"name":"V语言","slug":"v语言","permalink":"https://vlanguage.cn/tags/v语言/"}],"keywords":[{"name":"前沿资讯","slug":"前沿资讯","permalink":"https://vlanguage.cn/categories/前沿资讯/"}]},{"title":"【IT资讯】全新编程语言V发布","slug":"dengjin20104042056_96426213","date":"2019-07-18T00:00:00.000Z","updated":"2019-07-22T05:05:28.458Z","comments":true,"path":"2019/07/18/dengjin20104042056_96426213.html","link":"","permalink":"https://vlanguage.cn/2019/07/18/dengjin20104042056_96426213.html","excerpt":"","text":"近日，一种开源的名为V的新的静态类型编程语言发布了。它被描述为一种简单，快速，编译的语言，用于创建可维护的软件。它的创造者Alex Medvednikov表示它与Go非常相似，并受到Oberon，Rust和Swift的启发。 开发者从来就不缺新语言。今天新智元为大家带来的，是一款最新推出的语言：V。目前处于很早期的阶段，暂时还没有在维基百科上拥有姓名。 V是一种静态编译型语言，用于构建可维护的软件。它与Go类似，也受到Oberon、Rust、Swift的影响。 这一语言主要特性是快速编译、安全且可以和C/C++转换。其编译器只有400KB，且没有第三方依赖。V语言官方推特账号还同时公布了V语言建立的macOS Demo。 从V编程语言中可以期待什么 快速编译 V每秒可以编译多达120万行代码。它通过直接的机器代码生成和强大的模块化实现了这一点。如果我们决定发出C代码，编译速度将下降到每CPU每秒大约100k的代码。 Medvednikov提到，直接生成机器码仍处于早期的阶段，目前只支持x64/Mach-O。他计划在今年年底之前使这个功能稳定下来。 安全 它似乎是一种理想的语言，因为它没有null、全局变量、未定义的值、未定义的行为、变量阴影以及绑定检查。默认情况下，它支持不可变变量、纯函数和不可变结构。泛型目前正在研发中，计划在下个月推出。 性能 根据该网站介绍，V与C一样快，需要最少量的分配，并且支持内置序列化而无需运行时反射。它编译为原生二进制文件而没有任何依赖。 只需一个0.4 MB的编译器 与Go，Rust，GCC和Clang相比，V所需的空间和构建时间非常少。整个语言和标准库只有400 KB，您可以在0.4秒内构建它。到今年年底，作者的目标是将这个构建时间缩短到0.15秒。 C/C++转换 V允许您将V代码转换为C或C++。但是，考虑到C和C++是一种非常复杂的语言，这个功能还处于初期阶段。创作者的目标是在今年年底之前使这个功能稳定下来。 开发人员如何看待这种语言? 尽管开发人员喜欢使用一种优秀的语言来构建应用程序，但许多人认为V太好了，不可能成真。难以置信。看看网站上的声明，一些开发人员认为创建者要么对V的功能不诚实，要么在欺骗用户。 在我看来，Vlang是一个巨大的骗局和一堆虚假的承诺。如果我看到幕后黑手带着Patreon的钱跑了，我不会感到惊讶。— Ave. (@warnvod) April 1, 2019 Alex Medvednikov谈为什么可以信任V编程 在GitHub上报道的一个问题上，这位创作者评论道，“所以你要么相信我，要么不相信，我们将在6月看到谁是对的。”但请不要叫我骗子，骗子和散布错误信息。Medvednikov在不同的论坛上看到的回应和猜测可能让他不知所措。开发一门全新的语言需要大量的工作，也许他是雄心勃勃的。 有关更多详细信息，请访问V编程语言的官方网站。 参考网址： https://vlang.io Documentation: https://vlang.io/docs Twitter: https://twitter.com/v_language Discord (primary community): https://discord.gg/n7c74HM Installing V: https://github.com/vlang/v#installing-v-from-source alling V: https://github.com/vlang/v#installing-v-from-source gitHub链接：https://github.com/vlang/v","categories":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}],"tags":[{"name":"V语言","slug":"v语言","permalink":"https://vlanguage.cn/tags/v语言/"}],"keywords":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}]},{"title":"持续排名GITHUB榜首的V语言竟是C++的孪生兄弟-V版毁灭战士值得点赞","slug":"BEYONDMA_94978528","date":"2019-07-09T00:00:00.000Z","updated":"2019-07-22T04:55:18.457Z","comments":true,"path":"2019/07/09/BEYONDMA_94978528.html","link":"","permalink":"https://vlanguage.cn/2019/07/09/BEYONDMA_94978528.html","excerpt":"","text":"&nbsp; &nbsp; &nbsp; 最近V语言持续在GITHUB上霸屏，而笔者在上周介绍了V语言的一些基础，详见：GITHUB排行榜C位出道-手把手教你玩转V语言版的俄罗斯方块，而这周我也持续关注了V语言的动态，这次带大家玩一下V语言版的毁灭战士。 &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;V语言 VS C/C++ &nbsp; &nbsp; &nbsp; &nbsp;访问V语言的官网https://vlang.io/，可以看到其主打的特点就有 C to V translation &nbsp; &nbsp; 在具体介绍时其声称可以用快400倍的速度来整译整个C或者C++语言的工程。 &nbsp; &nbsp;而且还举出了使用V语言使用vector例子 #这是C++使用vector的版本 std::vector&lt;std::string&gt; s; s.push_back(\"V is \"); s.push_back(\"awesome\"); std::cout &lt;&lt; s.size(); #这是V语言的版本 mut s := [] s &lt;&lt; 'V is ' s &lt;&lt; 'awesome' println(s.len) 我看可以看到V语言在语法上与JAVA、.NET等纯面向对象的语言比较接近语法甜点很多，API的调用也不像C++那么刻板，但是其内核其实是C/C++，这就让我们这种金融IT的人士非常的开心，因为纯的面向对象语言都有垃圾回收的问题，延时的不确定性使JAVA不太适合做为量化交易的主要编程语言，而Rust虽然也没有延时，但是他还没有像V一样在不进行改造的情况下，直接完整编译C语言工程的能力。 &nbsp; 所以V语言不但具备了C的高效率还能能与C兼容、最关键的是语法掌握起来比较简单，这也是V的核心优势。 &nbsp; &nbsp;V语言版的DOOM &nbsp; &nbsp; 在V语言的官网上提到马上有一篇将毁灭战士（DOOM）翻译为V语言的博客PO出，不过使用V语言编译、执行DOOM也能让我们进一步了解V调用C、C++的机制，其Github的地址在github.com/vlang/doom。 &nbsp; &nbsp;下面我来给带大家整理一下ubantu下的安装过程（V语言的安装过程请参考https://blog.csdn.net/BEYONDMA/article/details/94349691，这里假设读者已经装好不再赘述) &nbsp; &nbsp; 1.安装sdl库 sudo apt install libsdl2-dev sudo apt install libsdl2-mixer-dev &nbsp; &nbsp;注意这步在官网上并未说明，如果不装后面在MAKE的阶段会报sdl::mixer库missing 2.编译doom代码 git clone https://github.com/chocolate-doom/chocolate-doom cd chocolate-doom cmake . make chocolate-doom 3.下载V的调用DOOM工程的代码 wget https://raw.githubusercontent.com/vlang/doom/master/p_enemy.v v -lib translated p_enemy.v cp p_enemy.o src/doom/CMakeFiles/doom.dir/p_enemy.c.o 4.运行程序 make chocolate-doom src/chocolate-doom -width 640 #640是指程序运行界面的宽度 5.p_enemy.v调用C的机制 &nbsp; 下面我再给大家展示一下p_enemy.v,我们可以看到如果想调用C的函数，只需要在声明加上fn C.函数名（函数签名） 返回类型，即可完成，另外调用__global标签就能调用全局变量了。可以说是非常方便啊。 struct C.FILE{} fn C.memcpy(voidptr, voidptr, int)#调用C的函数 fn C.memmove(voidptr, voidptr, int) fn C.memset(voidptr, voidptr, int) fn C.puts(voidptr) fn C.printf(voidptr, ..) fn C.sscanf(voidptr,voidptr, ..) voidptr fn C.strcasecmp(voidptr, voidptr) int fn C.strncasecmp(voidptr, voidptr, int) int fn C.strcmp(voidptr, voidptr) int fn C.strncmp(voidptr, voidptr, int) int fn C.fopen(byteptr, byteptr) *C.FILE fn C.fclose(*C.FILE) fn C.ftell(*C.FILE) int fn C.remove (byteptr) fn C.rename ( byteptr, byteptr) fn C.isspace(byte) int fn C.atoi(byteptr) int __global video_driver byteptr#调用全局变量 __global screenvisible bool __global vanilla_keyboard_mapping int __global screensaver_mode bool __global usegamma int 具体效果是这样的，虽然只是DOOM一代的画质，但是笔者还是很喜欢，玩了一下午。纯V语言版DOOM出炉笔者会在第一时间向大家分享。 &nbsp;","categories":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}],"tags":[{"name":"V语言","slug":"v语言","permalink":"https://vlanguage.cn/tags/v语言/"}],"keywords":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}]},{"title":"V 语言中文文档","slug":"u013604145_94598562","date":"2019-07-04T00:00:00.000Z","updated":"2019-07-22T04:55:19.545Z","comments":true,"path":"2019/07/04/u013604145_94598562.html","link":"","permalink":"https://vlanguage.cn/2019/07/04/u013604145_94598562.html","excerpt":"","text":"文章目录 介绍 Hello World 注释 函数 Functions 变量 基本类型 字符串 Strings 数组 Arrays Map IF 用法 运算符 in 循环语句 FOR Switch Structs 结构体 结构体-访问修饰符 结构体-方法 纯函数 常量 Constants 模块 Modules 接口 Interfaces 枚举 可选类型 和 错误处理 范型 Generics （预计7月上线） 并发 JSON 解析 单元测试 内存管理 延迟 Defer vfmt 进阶内容 V语言中调用C 函数 预编译if语句 代码反射 有限的运算符重载 内联汇编 将 C/C++翻译成V 热门代码重加载 交叉编译 (mac 编译打包 win程序) V中的跨平台shell脚本 (6月下旬) 附录1：关键字 附录2：运算符 介绍 V是一种静态类型的编译编程语言，用于构建可维护的软件。 它与Go类似，也受到Oberon，Rust，Swift的影响。 V是一种非常简单的语言。通过这个文档将花费你大约半个小时，到最后你将学习几乎整个语言。 尽管很简单，但它为开发人员提供了很多动力。你可以用其他语言做任何事情，你可以用V做。（官方文档入口：https://vlang.io/docs#option） Hello World //hello.v fn main() { println('hello world') } 和 c语言一样，main 为程序入口函数 fn 声明函数，函数的返回值类型在 名称() 的后面，此处不返回任何内容所以忽略； println 是为数不多的内置函数之一，作为标准输出; fn main()函数也可以被忽略，方便在编写小程序应用中，或者脚本，或者学习语言时带来方便；这样代表’Hello World’可以这么写 //hello.v println('hello world') 注释 // 单行注释 /* 这是多行注释 /* 它可以嵌套 */ */ 函数 Functions fn main() { println(add(77, 33)) println(sub(100, 50)) } fn add(x int, y int) int { return x + y } fn sub(x, y int) int { return x - y } 再次声明，返回值的类型在 名称的后面, 和Go 和 C 一样，函数不能重载，这也简化了代码，提高了可维护性和可读性 函数的使用可以在声明之前：例如上面， add 和 sub 在main 之后声明，也可以被 main 调用。对于 V 语言，所有声明都是如此，并且不需要头文件或考虑文件和声明的顺序。 变量 name := 'Bob' age := 20 large_number := i64(9999999999) println(name) println(age) println(large_number) 变量的声明和初始化 使用 := ;这是V语言声明变量的唯一方式，这也意味着变量的初始化始终具有初始值。 变量的类型是右侧的值推断出来的。要强制使用其他类型，请使用强制类型转换；表达式 T(v) 将值 v 转换为 T类型 与大多数语言不同，V 只允许在函数中定义变量，不允许使用全局（模块级别）变量，没有全局状态。 mut age := 20 println(age) age = 21 println(age) 【mut】改变变量的值，使用 = 符号。在V语言中，默认情况下变量是不可改变的，为了得到一个允许被修改的变量，你必须在声明时，用 mut来修饰。 您可以将上面例子的 mut 删除过后编译试试。 请注意 := 和 =之间的区别；:=用于声明和初始化，=用于赋值 请看如下3例错误示例 fn main() { age = 21 //这段代码在V语言中是编译不通过的，因为age未声明变量。 } fn main() { age := 21 //此段代码也不会被编译通过，因为未使用的变量会导致编译错误 } fn main() { a := 10 if true { a := 20 //与大多数语言不同，不允许使用已被声明的变量在局部变量。 //声明已在父作用域中使用的变量名，将导致编译错误。 } } 基本类型 bool 布尔类型 string 字符串类型 i8 i16 i32 i64 i128 (soon) u8 u16 u32 u64 u128 (soon) byte // 是 u8 的别名 int // 是 i32 的别名,与C,Go不同，int 始终为 32字节 rune // 是 i32 的别名,表示Unicode代码点 f32 f64 byteptr voidptr 字符串 Strings name := 'Bob' println('Hello, $name!') // `$` 用与字符串内引入变量 println(name.len) //字符串长度 bobby := name + 'by' // 通过 + 拼接字符串 println(bobby) // ==&gt; \"Bobby\" println(bobby.substr(1, 3)) // 字符串截取 ==&gt; \"ob\" // println(bobby[1:3]) // 这种写法很可能会替换 substr 方法 V语言中，字符串是只读字节数组，字符串数据使用UTF-8编码。 单引号和双引号都可以用于表示字符串（TODO：暂时不支持双引号）。为了保持一致，vfmt 请将双引号转换为单引号，除非字符串包含单引号。 字符串是不可变的，这代表 substring 函数非常有影响：不执行复制，不需要额外的分配。 V语言中，所有运算符必须在两侧都具有相同类型的值。如果有一个int 类型的变量 age: println('age = ' + age) //此段代码将无法编译通过，需改为如下 println('age = ' + age.str()) //将 age 转换为 string ,或者使用 println('age = $age') //字符串引入变量的方式 数组 Arrays nums := [1, 2, 3] println(nums) println(nums[1]) // ==&gt; \"2\" mut names := ['John'] names &lt;&lt; 'Peter' //数组中添加元素 names &lt;&lt; 'Sam' // names &lt;&lt; 10 //这里将编译不通过，因为 names 是一个字符串数组 println(names.len) // ==&gt; \"3\" println('Alex' in names) // ==&gt; \"false\" 判断变量是否在数组中 // 我们也可以预先分配一定数量的元素 nr_ids := 50 mut ids := [0 ; nr_ids] // 这里将创建 包含50个0的数组 数组的类型由第一个元素决定 [1,2,3] 是int数组 ([]int)。 [‘a’,‘b’] 是一个字符串数组 ([]string) 所有元素必须相同类型，[1,‘a’] 将编译不通过 数组的追加， &lt;&lt; 将一个值附加到数组末尾的运算符 数组长度，arr.len 字段。注意：len是一个只读字段，用户无法修改。 是否包含：val in arr ；如果arr包含val返回 true。 Map mut m := map[string]int{} // 现在 map的键值只能为 string 类型， m['one'] = 1 //设置值 println(m['one']) // ==&gt; \"1\" //获取值 println(m['bad_key']) // ==&gt; \"0\" //不包含返回 0 // TODO: 这是实现 key 是否存在的方法 numbers := { // TODO: 这种语法暂时没有实现 'one': 1, 'two': 2, } IF 用法 if 语句非常简单，与大多数其他语言类似。 与其他类C语言不同，条件周围没有括号，并且始终需要大括号。 if 可以用作表达式(类似3位运算符)： num := 777 s := if num % 2 == 0 { 'even' } else { 'odd' } println(s) // ==&gt; \"odd\" 运算符 in in 用于检测 数组中是否包含 某元素 nums := [1, 2, 3] println(1 in nums) // ==&gt; true in 拓展用法，可以编写更清晰的布尔判断逻辑 //标准写法 if parser.token == .plus || parser.token == .minus || parser.token == .div || parser.token == .mult { ... } //优化后写法 if parser.token in [.plus, .minus, .div, .mult] { ... } // V 语言在这样的表达式中有做优化，上面两个语句会生成相同的机器码，不会创建任何数组 循环语句 FOR V 语言只有一种循环方法：for 数组的循环： 使用 for value in arr 的方式循环取数组中的元素；如果需要索引，可以使用 for index,value in arr的方式代替 numbers := [1, 2, 3, 4, 5] for num in numbers { println(num) } names := ['Sam', 'Peter'] for i, name in names { println('$i) $name') // Output: 0) Sam } // 1) Peter 数组循环时，value是只读的，如果要在循环时修改数组，必须使用索引： mut numbers := [1, 2, 3, 4, 5] for i, num in numbers { println(num) numbers[i] = 0 } 类似while的循环方式实现:这种循环方式类似其他语言的 while 循环。一但条件不满足，循环停止，同样，条件周围不需要使用(),代码块总需要{} mut sum := 0 mut i := 0 for i &lt;= 100 { sum += i i++ } println(sum) // ==&gt; \"5050\" 循环的条件可以省去，这样循环会出现无限循环 mut num := 0 for { num++ if num &gt;= 10 { break } } println(num) // ==&gt; \"10\" 传统的 for i 循环:同其他语言风格一样。他比 while形式更安全，因为后者很容易忘记更新计数器并陷入无限循环 这里的 i 无需 mut 修饰，因为在这里 默认会被定义为 mut 类型的 for i := 0; i &lt; 10; i++ { println(i) } Switch os := 'windows' print('V is running on ') switch os { case 'darwin': println('macOS.') case 'linux': println('Linux.') default: println(os) } // TODO: replace with match expressions | 用匹配表达式替换 switch语句是编写if - else语句序列的较短方式。它运行第一种情况，其值等于条件表达式。 注意：与C不同，每个代码块的末尾都不需要 break。 Structs 结构体 简单使用 struct Point { x int y int } p := Point{ x: 10 y: 20 } println(p.x) // 访问结构体对象的某字段 结构体的内存是在堆上分配，需要获取结构体指针，使用 &amp;前缀: pointer := &amp;Point{10, 10} // 字段少于3的结构体的简化初始化方式 println(pointer.x) // 指针访问结构体属性方式与默认的方式相同 V 语言没有子类，但它支持嵌入式结构： // TODO: 这个功能将与6月末实施 struct Button { Widget title string } button := new_button('Click me') button.set_pos(x, y) // 没有潜入式，我们需要这么做 button.widget.set_pos(x,y) 结构体-访问修饰符 结构字段默认是私有的和不可变的（使结构也是不可变的）。 他们可以被 pub(可被访问的)和mut(可被修改的) 修饰。总共有5种可能的选择： struct Foo { a int // 私有的 不可变的 (default) mut: b int // 私有的 可变的 c int // (你可以一次列出，相同访问修饰符的字段) pub: d int // 公开的，不可变的 pub mut: e int // 公开的，但仅在父模块中可变 pub mut mut: f int // 公开的，父模块内部和外部都可变 } // (不建议使用，这就是为什么它如此冗长的原因) 例子，string 在 builtin 模块中定义的类型： struct string { str byteptr pub: len int } // 很容易看出 string 内容是不可变的 错误示例： fn main() { str := 'hello' len := str.len // OK str.len++ // 编译出错 } //具有字符串数据的字节指针根本无法在外部builtin访问。 len字段是公开的，但不是可变的。 结构体-方法 V 没有 class概念，但是我们可以在结构体上定义方法。 方法是具有特殊行参的函数。特殊行参 放在 fn关键字 和方法名之间的参数列表中。 简单示例（can_register 方法具有 User 类型的 特殊行参 u）： 不和其他语言一样，使用 self 或 this ，而是使用短名称，当然最好一个字母长 struct User { age int } fn (u User) can_register() bool { return u.age &gt; 16 } user := User{age: 10} println(user.can_register()) // ==&gt; \"false\" user2 := User{age: 20} println(user2.can_register()) // ==&gt; \"true\" 纯函数 V语言的函数默认是纯函数，也就是函数的输出结果只依赖输入的参数，并且没有其它的影响。 因为V语言没有全局变量，且所有的参数默认都是只读的，即使传入的引用也是默认只读的。 然后V语言并不纯的函数式语言。我们可以通过mut来修饰行参数，使得可以被修改： struct User { mut: is_registered bool } fn (u mut User) register() { u.is_registered = true } mut user := User{} println(user.is_registered) // ==&gt; \"false\" user.register() println(user.is_registered) // ==&gt; \"true\" 如上示例：特殊行参(这里被修饰了第一个参数) 被mut 修饰，为可变的。因此 register() 可以更改用户对象。 当然也适用于函数的普通参数,示例如下: fn multiply_by_2(arr mut []int) { for i := 0; i &lt; arr.len; i++ { arr[i] *= 2 } } mut nums := [1, 2, 3] multiply_by_2(mut nums) println(nums) // ==&gt; \"[2, 4, 6]\" 注意1：您必须在执行函数之前 声明一个 mut 的nums 变量。这清楚的表明被调用的函数将要修改该值！ 最好使用返回值而不是修改参数。修改参数只应在应用程序的性能关键部分中完成，以减少分配和复制。 使用user.register()或user = register(user) 代替register(mut user) fn register(u User) User { return { u | is_registered: true } } user = register(user) 常量 Constants 常量声明为const。它们只能在模块级别上（函数body外）定义。 常量名称必须大写。这有助于将它们与变量区分开来 永远不能改变常量值。 简单使用 const ( PI = 3.14 World = '世界' ) println(PI) println(World) 复杂类型的常量定义(这相对大多数语言更灵活) struct Color { r int g int b int } fn (c Color) str() string { return '{$c.r, $c.g, $c.b}' } //重写 str方法 fn rgb(r, g, b int) Color { return Color{r: r, g: g, b: b} } const ( Numbers = [1, 2, 3] Red = Color{r: 255, g: 0, b: 0} //结构体常量 Blue = rgb(0, 0, 255)//结构体常量 ) println(Numbers) println(Red) println(Blue) 不支持使用全局变量，因此这种方式显得非常有必要 模块 Modules V 语言是一个模块化的语言。鼓励创建可重用的模块，而且创建模块也非常简单。 新模块创建，请创建一个包含你模块名的目录 和 .v 代码文件： cd ~/code/modules mkdir mymodule vim mymodule/mymodule.v // mymodule.v module mymodule // 要用 pub修饰符修饰，外部才能访问该 模块函数 pub fn say_hi() { println('hello from mymodule!') } 模块的编译： 您可以在 你定义好的 模块目录下创建 更多的 .v模块文件 构建命令 v -lib ~/code/modules/mymodule ，然后就可以在代码中使用它 模块的使用： module main import mymodule fn main() { mymodule.say_hi() } 请注意，每次调用外部函数时都必须指定模块。这看起来似乎很冗长，但它使代码更易读，更容易理解，因为它始终清楚的表达出从哪个模块调用哪个函数。特别是在大型代码库中。 模块名称应短，不超过10个字符。模块不允许循环依赖。 您可以在任何地方创建模块 ,所有的模块都将静态编译到单一的可执行程序中。 接口 Interfaces 简单使用： 类型通过实现接口同名的方法（注意返回值也相同类型）。和Go语言一样,V语言也是隐式接口，类型不需要显式实现接口，没有“implements”关键字。 struct Dog {} struct Cat {} fn (d Dog) speak() string { return 'woof' } fn (c Cat) speak() string { return 'meow' } interface Speaker { speak() string } fn perform(s Speaker) { println(s.speak()) } dog := Dog{} cat := Cat{} perform(dog) // ==&gt; \"woof\" perform(cat) // ==&gt; \"meow\" 枚举 enum Color { red green blue } mut color := Color.red // 下面的写法要注意了，V语言知道 color的类型为Color，所以这个地方不需要使用 Color.green color = .green println(color) // ==&gt; \"1\" TODO: print \"green\"? 可选类型 和 错误处理 V语言针对函数返回值增加了一个可选的属性，这样可以用于处理失败的情况 可以用最小工作量来升级一个可选类型返回的函数：只需要在 返回值类型声明的前面添加一个 ?,这样就可以区别错误和真正的返回值。 当然如果你不需要返回错误，可以简单的使用 return None;（TODO：None尚未实现） 这是处理V中错误的主要手段。函数的返回值依然是值，但是错误处理要简洁很多。 struct User { id int name string } struct Repo { users []User } fn new_repo() Repo { return Repo { users: [User{1, 'Andrew'}, User {2, 'Bob'}, User {10, 'Charles'}] } } fn (r Repo) find_user_by_id(id int) ?User { for user in r.users { if user.id == id { // V 自动将其包装为 Option 类型 return user } } return error('User $id not found') } fn main() { repo := new_repo() user := repo.find_user_by_id(10) or { // Option类型必须使用 `or` 的代码块hold住； return // `or` 代码块必须以， return ,break,或 continue 关键字结束 } println(user.id) // ==&gt; \"10\" println(user.name) // ==&gt; 'Charles' } 当然，错误还可以继续传播： resp := http.get(url)? println(resp.body) 上面例子中，http.get return ?http.Response 的可选类型，如果错误发生，将传播到调用函数，这里是导致main函数抛出异常。 上面代码是下面代码的简写： resp := http.get(url) or { panic(err) } println(resp.body) 范型 Generics （预计7月上线） 为了方便阅读, 允许使用 ⟨⟩ 来代替 &lt;&gt;. vfmt 自动替换 ⟨⟩ 为&lt;&gt; . struct Repo⟨T⟩ { db DB } fn new_repo⟨T⟩(db DB) Repo⟨T⟩ { return Repo⟨T⟩{db: db} } // 这是一个范型函数. V 语言可以使用任意类型的范型 fn (r Repo⟨T⟩) find_by_id(id int) ?T { table_name := T.name // 在此示例中，获取类型的名称会得到表明 return r.db.query_one⟨T⟩('select * from $table_name where id = ?', id) } db := new_db() users_repo := new_repo⟨User⟩(db) posts_repo := new_repo⟨Post⟩(db) user := users_repo.find_by_id(1)? post := posts_repo.find_by_id(1)? 并发 并发模型与Go非常相似。要foo()同时运行，只需调用它go foo()，便会在新的系统线程执行该函数 . 很快 将实现 goroutines 和 scheduler 。 JSON 解析 JSON 在今天已经非常流行，这也是为什么要内置json支持的原因。 json.decode 函数的第一个参数是要解码的类型，第二个参数是 json字符串。 json 用于生成json 编码和解码的代码，不使用运行时反射，这也会带来更好的性能。 struct User { name string age int foo Foo [skip] //使用 skip 来跳过某些字段 } data := '{ \"name\": \"Frodo\", \"age\": 25 }' user := json.decode(User, data) or { eprintln('Failed to decode json') return } println(user.name) println(user.age) 单元测试 所有的单元测试都必须放在 *test.v 文件中，并且测试函数必须使用 test 开头方式命名。 若要运行 测试文件 hello_test.v 用来测试某整个模块，请执行命令 v test mymodule // hello.v fn hello() string { return 'Hello world' } // hello_test.v fn test_hello() { assert hello() == 'Hello world' } 内存管理 V语言没有自动内存回收（GC）和引用计数，V语言会在编译阶段完成必要的清理工作。例如： fn draw_text(s string, x, y int) { ... } fn draw_scene() { ... draw_text('hello $name1', 10, 10) draw_text('hello $name2', 100, 10) draw_text(strings.repeat('X', 10000), 10, 50) ... } 字符串 string 生命周期不会超出 draw_text 函数，因此当函数执行完时，它们将会被清除。实际上,前面两次调用根本不会导致任何分配，因为这两个字符串很小，V语言会使用提前准备好的缓冲区构造字符串。 对于更复杂的情况，需要手动内存管理，我们将很快实现解决。 V 将在运行时检测并报告内存泄露，例如：要清除数组，请使用 free() 方法： numbers := [0; 1000000] ... numbers.free() 延迟 Defer TODO vfmt TODO 进阶内容 V语言中调用C 函数 #flag -lsqlite3 #include \"sqlite3.h\" struct C.sqlite3 struct C.sqlite3_stmt fn C.sqlite3_column_int(C.sqlite_stmt, int) int fn main() { path := 'sqlite3_users.db' db := &amp;C.sqlite3{} C.sqlite3_open(path.cstr(), &amp;db) query := 'select count(*) from users' stmt := &amp;C.sqlite3_stmt{} C.sqlite3_prepare_v2(db, query.cstr(), - 1, &amp;stmt, 0) C.sqlite3_step(stmt) nr_users := C.sqlite3_column_int(res, 0) C.sqlite3_finalize(res) println(nr_users) } C strings 可以转换为 “string（cstring）”的V字符串 预编译if语句 预编译 使用 $if 。现在它只能用于检测操作系统。 $if windows { println('Windows') } $if linux { println('Linux') } $if mac { println('macOS') } 代码反射 有内置的 json支持已经是很不错的选择，但是V还允许使用者为任意添加高效的序列化程序。 // TODO: 计划6月上线 fn decode&lt;T&gt;(data string) T { mut result := T{} for field in T.fields { if field.typ == 'string' { result.$field = get_string(data, field.name) } else if field.typ == 'int' { result.$field = get_int(data, field.name) } } return result } // 生成: fn decode_User(data string) User { mut result := User{} result.name = get_string(data, 'name') result.age = get_int(data, 'age') return result } 有限的运算符重载 运算符重载违背了V的简单性和可预测性的理念。但由于科学和图形应用程序属于V域，因此为了提高可读性，运算符重载非常重要: a.add(b).add(c.mul(d))比 a + b + c * d 可读性差得多了。 struct Vec { x int y int } fn (a Vec) str() string { return '{$a.x, $a.y}' } fn (a Vec) + (b Vec) Vec { return Vec { a.x + b.x, a.y + b.y } } fn (a Vec) - (b Vec) Vec { return Vec { a.x - b.x, a.y - b.y } } fn main() { a := Vec{2, 3} b := Vec{4, 5} println(a + b) // ==&gt; \"{6, 8}\" println(a - b) // ==&gt; \"{-2, -2}\" } 为了提高安全性和可维护性，运算符重载 有几个局限性： 只能使用 +,=,* ,/ 运算符的重载 不允许运算符重载函数内调用其他函数 运算符重载函数无法修改其参数 运算符函数的两个参数必须具有相同类型，（同V中所有运算符一样,str+num =&gt; error） 内联汇编 TODO 尚未实现 fn main() { a := 10 asm x64 { mov eax, [a] add eax, 10 mov [a], eax } } 将 C/C++翻译成V TODO: 将C翻译为V将于6月上市。C ++到V将于今年晚些时候推出 V可以将您的C / C ++代码转换为可读的V代码。让我们先创建一个简单的程序test.cpp #include &lt;vector&gt; #include &lt;string&gt; #include &lt;iostream&gt; int main() { std::vector&lt;std::string&gt; s; s.push_back(\"V is \"); s.push_back(\"awesome\"); std::cout &lt;&lt; s.size() &lt;&lt; std::endl; return 0; } 允许命令 v translate test.cpp 将会得到 test.v: fn main { mut s := [] s &lt;&lt; 'V is ' s &lt;&lt; 'awesome' println(s.len) } 一个在线C / C ++到V的翻译即将推出. 什么时候应该翻译C代码，什么时候应该从V调用C代码？ 如果您有经过良好编写且经过良好测试的C代码，那么您当然可以直接从V调用此C代码 将其翻译为V有以下几个优点： 如果您计划开发该代码库，那么现在您可以使用一种语言编写所有内容，这样可以更安全，更容易开发 交叉编译(mac 编译打包 win程序)变得更加容易。您根本不必担心它。 没有更多的构建标志和包含文件。 热门代码重加载 TODO 交叉编译 (mac 编译打包 win程序) 要交叉编译项目，只需简单执行命令: v -os windows . v -os linux . （暂时无法对macOS进行交叉编译。） 如果您没有任何C依赖项，那就是您需要做的。即使在使用ui模块或图形应用程序编译GUI应用程序时也可以使用 gg。 您需要安装Clang，LLD链接器，并下载包含库和包含Windows和Linux文件的zip文件。V将为您提供链接。 V中的跨平台shell脚本 (6月下旬) V可以用作Bash的替代方案来编写部署脚本，构建脚本等。 使用V的优势在于语言的简单性和可预测性以及跨平台支持。“V脚本”在类Unix系统和Windows上运行。 使用#v指令启动程序。它将使os 模块中的所有函数全局化（您可以使用ls() 来代替os.ls() ）例如： #v rm('build/*') // 效果同: for file in ls('build/') { rm(file) } mv('*.v', 'build/') // 效果同: for file in ls('.') { if file.ends_with('.v') { mv(file, 'build/') } } 现在您可以像普通的V程序一样编译它，并获得可以在任何地方部署和运行的可执行文件： v deploy.v &amp;&amp; ./deploy (当然也可以使用传统脚本运行方式来允许它： v run deploy.v) 附录1：关键字 V 拥有22个关键字 break const continue defer else enum fn for go goto if import in interface match module mut or pub return struct type 附录2：运算符 运算符 运算符 含义 支持类型 + sum integers, floats, strings - difference integers, floats * product integers, floats / quotient integers, floats % remainder integers &amp; bitwise AND integers ｜ bitwise OR integers, floats ^ bitwise XOR integers &lt;&lt; left shift integer &lt;&lt; unsigned integer &gt;&gt; right shift integer &gt;&gt; unsigned integer 运算符优先级 优先级 运算符 5 * / % &lt;&lt; &gt;&gt; &amp; 4 + - ｜ ^ 3 == != &lt; &lt;= &gt; &gt;= 2 &amp;&amp; 1 ｜｜ 赋值运算符 += -= *= /= %= &amp;= |= ^= &gt;&gt;= &lt;&lt;=","categories":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}],"tags":[{"name":"V语言","slug":"v语言","permalink":"https://vlanguage.cn/tags/v语言/"}],"keywords":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}]},{"title":"Centos下安装vlang运行环境-新手必看","slug":"weixin_42512337_94554250","date":"2019-07-03T00:00:00.000Z","updated":"2019-07-22T05:05:31.033Z","comments":true,"path":"2019/07/03/weixin_42512337_94554250.html","link":"","permalink":"https://vlanguage.cn/2019/07/03/weixin_42512337_94554250.html","excerpt":"","text":"磨刀霍霍向vlang 工欲善其事必先利其器。在开始v语言相关语法知识学习之前，我们首先需要部署好vlang的运行环境。目前vlang语言只支持linux和mac系统，笔者本人选择使用Centos，下面是基本的安装部署步骤： 安装clang编译器 下载v语言源码 修改默认编译器 编译源码 建立软链接 测试安装结果 源码更新 现在我们对上述安装步骤展开具体介绍。 1. 安装clang编译器 为了能编译v语言，需要先安装对应的编译器，目前比较流行的编译器有clang或者GCC，笔者这里选择使用clang。Clang是一个支持C语言、C++、Objective-C语言的轻量级编译器。 首先检查当前Centos环境是否有安装clang编译器 [root@localhost iris]# which clang /usr/bin/which: no clang in (/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin:/usr/local/go/bin:/mnt/hgfs/go/bin:/home/iris/.local/bin:/home/iris/bin) 如上表示没有安装clang编译器，可通过yum进行安装 [root@localhost iris]# yum install -y clang 已加载插件：fastestmirror, langpacks Loading mirror speeds from cached hostfile * base: mirrors.aliyun.com * extras: mirrors.aliyun.com * updates: mirrors.aliyun.com 软件包 clang-3.4.2-9.el7.x86_64 已安装并且是最新版本 无须任何处理 查看clang版本 [root@localhost iris]# clang -v clang version 3.4.2 (tags/RELEASE_34/dot2-final) Target: x86_64-redhat-linux-gnu Thread model: posix Found candidate GCC installation: /usr/bin/../lib/gcc/x86_64-redhat-linux/4.8.2 Found candidate GCC installation: /usr/bin/../lib/gcc/x86_64-redhat-linux/4.8.5 Found candidate GCC installation: /usr/lib/gcc/x86_64-redhat-linux/4.8.2 Found candidate GCC installation: /usr/lib/gcc/x86_64-redhat-linux/4.8.5 Selected GCC installation: /usr/bin/../lib/gcc/x86_64-redhat-linux/4.8.5 2. 下载V语言源码 [root@localhost iris]# git clone https://github.com/vlang/v 正克隆到 'V'... remote: Enumerating objects: 39, done. remote: Counting objects: 100% (39/39), done. remote: Compressing objects: 100% (28/28), done. remote: Total 1924 (delta 11), reused 29 (delta 11), pack-reused 1885 接收对象中: 100% (1924/1924), 1.23MiB | 247.00 KiB/s, done. 处理 delta 中: 100% (1115/1115), done. 3. 修改默认编译器 这里先修改编译器为clang，否则后面编译源码的时候可能会出错。 [root@localhost iris]# cd /usr/bin [root@localhost bin]# rm cc rm: 是否删除符号链接 \"cc\"? y [root@localhost bin]# ln -s clang cc 4. 编译源码 进入到vlang语言对应的下载目录下，通过make命令编译源码。 [root@localhost iris]# cd v [root@localhost v]# make rm -f v.c v vprod curl -Os https://raw.githubusercontent.com/vlang/vc/master/v.c cc -march=native -std=gnu11 -w -o v v.c ./v -o v compiler rm v.c V has been successfully built 5. 建立软链接 软链接ln是Linux中的一个重要命令，作用是为某一个文件在另外一个位置建立一个不同的链接，其本质是实现文件的共享。通过软链接，当我们需要在其他目录使相同的文件时，不需要在每一个需要的目录下都放一个相同的文件，只需要在某个固定的目录放上该文件，然后在其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。 [root@localhost iris]# ln -s /home/iris/v/v /usr/local/bin/v 这里 /home/iris/v/v 表示步骤 5 中编译成功后生成v.exe文件，/usr/local/bin/v 为我们需要使用v.exe 的共享位置。 6. 测试安装结果 [root@localhost v]# cd examples [root@localhost examples]# ls game_of_life json.v news_fetcher.v tetris hello_world links_scraper.v rune.v VCasino hello_world.v log.v terminal_control.v word_counter [root@localhost examples]# v run hello_world.v ============ running hello_world ============ Hello, World! 7. 更新源码 [root@localhost v]# git pull origin master 来自 https://github.com/vlang/v * branch master -&gt; FETCH_HEAD Already up-to-date. [root@localhost v]# make rm -f v.c v vprod curl -Os https://raw.githubusercontent.com/vlang/vc/master/v.c cc -march=native -std=gnu11 -w -o v v.c ./v -o v compiler rm v.c V has been successfully built 后记 以上就是vlang运行环境全部的安装配置过程。笔者发现在安装过程中有时候执行make命令会报错，除了没有修改默认编译器这个原因之外，有时候可能是源码本身的问题，通过更新源码步骤后重新make就能成功。下一章开始我们将正式开始进入vlang语言的语法学习，一起来感受vlang的魅力吧！","categories":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}],"tags":[{"name":"V语言","slug":"v语言","permalink":"https://vlanguage.cn/tags/v语言/"}],"keywords":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}]},{"title":"GitHub 排行榜 C 位出道：手把手教你玩转 V 语言版的俄罗斯方块！｜CSDN 博文精选...","slug":"csdnnews_94508510","date":"2019-07-02T00:00:00.000Z","updated":"2019-07-22T05:05:28.136Z","comments":true,"path":"2019/07/02/csdnnews_94508510.html","link":"","permalink":"https://vlanguage.cn/2019/07/02/csdnnews_94508510.html","excerpt":"","text":"作者 |&nbsp;beyondma 本文精选自 CSDN 博客，已获作者授权 最近 V 语言在千呼万唤之后，终于迎来开源，并正式发布了首个可用版本。其一经推出，便强势登顶GitHub的榜首，引来各方热议。目前V已经可以实现自我编译迭代，笔者大致了解了一下V语言，主要有如下一些特性： &nbsp; 快速编译：V的CPU核心每秒编译约120万行代码；V也可以调用C，编译速度下降到≈100k行/秒/CPU； 安全策略：没有空；没有全局变量（意味着变量都是在函数体中声明）；没有未定义的行为； 性能：和C一样快，操作C没有任何成本，不支持运行时反射，编译器只有400K，整个语言及其标准库都小于400kb；V目前是用V写的，你可以在0.4秒内完成（到今年年底，这个数字将降至≈0.15秒）； 强大的图形能力：支持在GDI+/Cocoa绘图之上的跨平台绘图库，以及一个基于OpenGL的图形库，以支持加载复杂的三维对象与纹理。 &nbsp; 由于曾经做过一段时间的DIRECTX的开发，V语言对于图形能力的特性宣传最吸引笔者的注意。所以我到其官网及Github上学习了一下相关内容，按照编译运行了一下俄罗斯方块的例程，接下来向大家做一下分享。 &nbsp; &nbsp; &nbsp; &nbsp; 安装V语言 &nbsp; &nbsp; 如果只是HELLO WORLD程序是非常简单的，只需要按照https://vlang.io官网的标准步骤来执行即可。而如果使用其图形处理能力笔者目前只在UBANTU平台测试成功——下面均是以UBANTU为例来说明。 &nbsp; 首先将整个项目克隆下来，再make即可： &nbsp; &nbsp; &nbsp;git&nbsp;clone&nbsp;https://github.com/vlang/v&nbsp;cd&nbsp;v&nbsp;make &nbsp;cd&nbsp;v &nbsp;make &nbsp; 如果报curl command not found，则执行以下命令安装curl： &nbsp; &nbsp; sudo&nbsp;apt&nbsp;install&nbsp;curl &nbsp; 接下来再建立软链接： &nbsp; &nbsp; sudo&nbsp;ln&nbsp;-s&nbsp;/home/machao/v/v&nbsp;/usr/local/bin/v &nbsp; 然后运行v就能进到v语言的命令行了。而如果要运行俄罗斯方块还需要以下这些库的支持： &nbsp; &nbsp; sudo&nbsp;apt&nbsp;install&nbsp;libglfw3&nbsp;libglfw3-dev&nbsp;libfreetype6-dev&nbsp;libcurl3-dev &nbsp; &nbsp; 运行俄罗斯方块 &nbsp; &nbsp; &nbsp; &nbsp; 接下来cd tetris，进入到俄罗斯方块的目录，先使用gedit tetris.v。来看一下v语言的代码样例，其主要部分如下： &nbsp; &nbsp; fn&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;glfw.init()//实始化类&nbsp;&nbsp;&nbsp;&nbsp;mut&nbsp;game&nbsp;:=&nbsp;&amp;Game{gg:&nbsp;0}&nbsp;//&nbsp;TODO&nbsp;&nbsp;&nbsp;&nbsp;game.parse_tetros()&nbsp;&nbsp;&nbsp;&nbsp;game.init_game()&nbsp;&nbsp;&nbsp;&nbsp;mut&nbsp;window&nbsp;:=&nbsp;glfw.create_window(glfw.WinCfg&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width:&nbsp;WinWidth&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;height:&nbsp;WinHeight&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title:&nbsp;'V&nbsp;Tetris'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ptr:&nbsp;game&nbsp;//&nbsp;glfw&nbsp;user&nbsp;pointer&nbsp;&nbsp;&nbsp;&nbsp;})&nbsp;&nbsp;&nbsp;&nbsp;window.make_context_current()&nbsp;&nbsp;&nbsp;&nbsp;window.onkeydown(key_down)//注册事件&nbsp;&nbsp;&nbsp;&nbsp;gg.init()&nbsp;&nbsp;&nbsp;&nbsp;game.gg&nbsp;=&nbsp;gg.new_context(gg.Cfg&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width:&nbsp;WinWidth&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;height:&nbsp;WinHeight&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use_ortho:&nbsp;true&nbsp;//&nbsp;This&nbsp;is&nbsp;needed&nbsp;for&nbsp;2D&nbsp;drawing&nbsp;&nbsp;&nbsp;&nbsp;})&nbsp;&nbsp;&nbsp;&nbsp;go&nbsp;game.run()&nbsp;//&nbsp;Run&nbsp;the&nbsp;game&nbsp;loop&nbsp;in&nbsp;a&nbsp;new&nbsp;thread&nbsp;&nbsp;&nbsp;&nbsp;gl.clear()&nbsp;//&nbsp;For&nbsp;some&nbsp;reason&nbsp;this&nbsp;is&nbsp;necessary&nbsp;to&nbsp;avoid&nbsp;an&nbsp;intial&nbsp;flickering&nbsp;&nbsp;&nbsp;&nbsp;gl.clear_color(255,&nbsp;255,&nbsp;255,&nbsp;255)&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gl.clear()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gl.clear_color(255,&nbsp;255,&nbsp;255,&nbsp;255)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;game.draw_scene()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;window.swap_buffers()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glfw.wait_events()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;window.should_close()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;window.destroy()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glfw.terminate()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}}fn&nbsp;(g&nbsp;mut&nbsp;Game)&nbsp;move_right(dx&nbsp;int)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Reached&nbsp;left/right&nbsp;edge&nbsp;or&nbsp;another&nbsp;tetro?&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i&nbsp;:=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;TetroSize;&nbsp;i++&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tetro&nbsp;:=&nbsp;g.tetro[i]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;:=&nbsp;tetro.y&nbsp;+&nbsp;g.pos_y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;:=&nbsp;tetro.x&nbsp;+&nbsp;g.pos_x&nbsp;+&nbsp;dx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;row&nbsp;:=&nbsp;g.field[y]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;row[x]&nbsp;!=&nbsp;0&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Do&nbsp;not&nbsp;move&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;g.pos_x&nbsp;+=&nbsp;dx}fn&nbsp;(g&nbsp;mut&nbsp;Game)&nbsp;delete_completed_lines()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;y&nbsp;:=&nbsp;FieldHeight;&nbsp;y&nbsp;&gt;=&nbsp;1;&nbsp;y--&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.delete_completed_line(y)&nbsp;&nbsp;&nbsp;&nbsp;}}fn&nbsp;(g&nbsp;mut&nbsp;Game)&nbsp;delete_completed_line(y&nbsp;int)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;x&nbsp;:=&nbsp;1;&nbsp;x&nbsp;&lt;=&nbsp;FieldWidth;&nbsp;x++&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;:=&nbsp;g.field[y]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;f[x]&nbsp;==&nbsp;0&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Move&nbsp;everything&nbsp;down&nbsp;by&nbsp;1&nbsp;position&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;yy&nbsp;:=&nbsp;y&nbsp;-&nbsp;1;&nbsp;yy&nbsp;&gt;=&nbsp;1;&nbsp;yy--&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;x&nbsp;:=&nbsp;1;&nbsp;x&nbsp;&lt;=&nbsp;FieldWidth;&nbsp;x++&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mut&nbsp;a&nbsp;:=&nbsp;g.field[yy&nbsp;+&nbsp;1]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mut&nbsp;b&nbsp;:=&nbsp;g.field[yy]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a[x]&nbsp;=&nbsp;b[x]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}}//&nbsp;Place&nbsp;a&nbsp;new&nbsp;tetro&nbsp;on&nbsp;topfn&nbsp;(g&nbsp;mut&nbsp;Game)&nbsp;generate_tetro()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;g.pos_y&nbsp;=&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;g.pos_x&nbsp;=&nbsp;FieldWidth&nbsp;/&nbsp;2&nbsp;-&nbsp;TetroSize&nbsp;/&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;g.tetro_idx&nbsp;=&nbsp;rand.next(BTetros.len)&nbsp;&nbsp;&nbsp;&nbsp;g.rotation_idx&nbsp;=&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;g.get_tetro()}//&nbsp;Get&nbsp;the&nbsp;right&nbsp;tetro&nbsp;from&nbsp;cachefn&nbsp;(g&nbsp;mut&nbsp;Game)&nbsp;get_tetro()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;idx&nbsp;:=&nbsp;g.tetro_idx&nbsp;*&nbsp;TetroSize&nbsp;*&nbsp;TetroSize&nbsp;+&nbsp;g.rotation_idx&nbsp;*&nbsp;TetroSize&nbsp;&nbsp;&nbsp;&nbsp;g.tetro&nbsp;=&nbsp;g.tetros_cache.slice(idx,&nbsp;idx&nbsp;+&nbsp;TetroSize)}fn&nbsp;(g&nbsp;mut&nbsp;Game)&nbsp;drop_tetro()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i&nbsp;:=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;TetroSize;&nbsp;i++&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tetro&nbsp;:=&nbsp;g.tetro[i]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;:=&nbsp;tetro.x&nbsp;+&nbsp;g.pos_x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;:=&nbsp;tetro.y&nbsp;+&nbsp;g.pos_y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Remember&nbsp;the&nbsp;color&nbsp;of&nbsp;each&nbsp;block&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;TODO:&nbsp;g.field[y][x]&nbsp;=&nbsp;g.tetro_idx&nbsp;+&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mut&nbsp;row&nbsp;:=&nbsp;g.field[y]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;row[x]&nbsp;=&nbsp;g.tetro_idx&nbsp;+&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;}}fn&nbsp;(g&nbsp;&amp;Game)&nbsp;draw_tetro()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i&nbsp;:=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;TetroSize;&nbsp;i++&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tetro&nbsp;:=&nbsp;g.tetro[i]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.draw_block(g.pos_y&nbsp;+&nbsp;tetro.y,&nbsp;g.pos_x&nbsp;+&nbsp;tetro.x,&nbsp;g.tetro_idx&nbsp;+&nbsp;1)&nbsp;&nbsp;&nbsp;&nbsp;}}fn&nbsp;(g&nbsp;&amp;Game)&nbsp;draw_block(i,&nbsp;j,&nbsp;color_idx&nbsp;int)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;g.gg.draw_rect((j&nbsp;-&nbsp;1)&nbsp;*&nbsp;BlockSize,&nbsp;(i&nbsp;-&nbsp;1)&nbsp;*&nbsp;BlockSize,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlockSize&nbsp;-&nbsp;1,&nbsp;BlockSize&nbsp;-&nbsp;1,&nbsp;Colors[color_idx])}fn&nbsp;(g&nbsp;&amp;Game)&nbsp;draw_field()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i&nbsp;:=&nbsp;1;&nbsp;i&nbsp;&lt;&nbsp;FieldHeight&nbsp;+&nbsp;1;&nbsp;i++&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;j&nbsp;:=&nbsp;1;&nbsp;j&nbsp;&lt;&nbsp;FieldWidth&nbsp;+&nbsp;1;&nbsp;j++&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;:=&nbsp;g.field[i]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;f[j]&nbsp;&gt;&nbsp;0&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.draw_block(i,&nbsp;j,&nbsp;f[j])&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}}fn&nbsp;(g&nbsp;&amp;Game)&nbsp;draw_scene()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;g.draw_tetro()&nbsp;&nbsp;&nbsp;&nbsp;g.draw_field()}fn&nbsp;parse_binary_tetro(t&nbsp;int)&nbsp;[]Block&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;res&nbsp;:=&nbsp;[Block{}&nbsp;;&nbsp;4]&nbsp;&nbsp;&nbsp;&nbsp;mut&nbsp;cnt&nbsp;:=&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;horizontal&nbsp;:=&nbsp;t&nbsp;==&nbsp;9//&nbsp;special&nbsp;case&nbsp;for&nbsp;the&nbsp;horizontal&nbsp;line&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i&nbsp;:=&nbsp;0;&nbsp;i&nbsp;&lt;=&nbsp;3;&nbsp;i++&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Get&nbsp;ith&nbsp;digit&nbsp;of&nbsp;t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;:=&nbsp;int(math.pow(10,&nbsp;3&nbsp;-&nbsp;i))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mut&nbsp;digit&nbsp;:=&nbsp;int(t&nbsp;/&nbsp;p)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t&nbsp;%=&nbsp;p&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Convert&nbsp;the&nbsp;digit&nbsp;to&nbsp;binary&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;j&nbsp;:=&nbsp;3;&nbsp;j&nbsp;&gt;=&nbsp;0;&nbsp;j--&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bin&nbsp;:=&nbsp;digit&nbsp;%&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;digit&nbsp;/=&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;bin&nbsp;==&nbsp;1&nbsp;||&nbsp;(horizontal&nbsp;&amp;&amp;&nbsp;i&nbsp;==&nbsp;TetroSize&nbsp;-&nbsp;1)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;TODO:&nbsp;res[cnt].x&nbsp;=&nbsp;j&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;res[cnt].y&nbsp;=&nbsp;i&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mut&nbsp;point&nbsp;:=&nbsp;&amp;res[cnt]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;point.x&nbsp;=&nbsp;j&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;point.y&nbsp;=&nbsp;i&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cnt++&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;res}//&nbsp;TODO:&nbsp;this&nbsp;exposes&nbsp;the&nbsp;unsafe&nbsp;C&nbsp;interface,&nbsp;clean&nbsp;upfn&nbsp;key_down(wnd&nbsp;voidptr,&nbsp;key,&nbsp;code,&nbsp;action,&nbsp;mods&nbsp;int)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;action&nbsp;!=&nbsp;2&nbsp;&amp;&amp;&nbsp;action&nbsp;!=&nbsp;1&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Fetch&nbsp;the&nbsp;game&nbsp;object&nbsp;stored&nbsp;in&nbsp;the&nbsp;user&nbsp;pointer&nbsp;&nbsp;&nbsp;&nbsp;mut&nbsp;game&nbsp;:=&nbsp;&amp;Game(glfw.get_window_user_pointer(wnd))&nbsp;&nbsp;&nbsp;&nbsp;switch&nbsp;key&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;glfw.KEY_ESCAPE:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glfw.set_should_close(wnd,&nbsp;true)&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;glfw.KeyUp:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Rotate&nbsp;the&nbsp;tetro&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;game.rotation_idx++&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;game.rotation_idx&nbsp;==&nbsp;TetroSize&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;game.rotation_idx&nbsp;=&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;game.get_tetro()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;game.pos_x&nbsp;&lt;&nbsp;0&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;game.pos_x&nbsp;=&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;glfw.KeyLeft:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;game.move_right(-1)&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;glfw.KeyRight:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;game.move_right(1)&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;glfw.KeyDown:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;game.move_tetro()&nbsp;//&nbsp;drop&nbsp;faster&nbsp;when&nbsp;the&nbsp;player&nbsp;presses&nbsp;&lt;down&gt;&nbsp;&nbsp;&nbsp;&nbsp;}}//实始化类 &nbsp;&nbsp;&nbsp;&nbsp;mut&nbsp;game&nbsp;:=&nbsp;&amp;Game{gg:&nbsp;0}&nbsp;//&nbsp;TODO &nbsp;&nbsp;&nbsp;&nbsp;game.parse_tetros() &nbsp;&nbsp;&nbsp;&nbsp;game.init_game() &nbsp;&nbsp;&nbsp;&nbsp;mut&nbsp;window&nbsp;:=&nbsp;glfw.create_window(glfw.WinCfg&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width:&nbsp;WinWidth &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;height:&nbsp;WinHeight &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title:&nbsp;'V&nbsp;Tetris' &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ptr:&nbsp;game&nbsp;//&nbsp;glfw&nbsp;user&nbsp;pointer &nbsp;&nbsp;&nbsp;&nbsp;}) &nbsp;&nbsp;&nbsp;&nbsp;window.make_context_current() &nbsp;&nbsp;&nbsp;&nbsp;window.onkeydown(key_down)//注册事件 &nbsp;&nbsp;&nbsp;&nbsp;gg.init() &nbsp;&nbsp;&nbsp;&nbsp;game.gg&nbsp;=&nbsp;gg.new_context(gg.Cfg&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width:&nbsp;WinWidth &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;height:&nbsp;WinHeight &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use_ortho:&nbsp;true&nbsp;//&nbsp;This&nbsp;is&nbsp;needed&nbsp;for&nbsp;2D&nbsp;drawing &nbsp;&nbsp;&nbsp;&nbsp;}) &nbsp;&nbsp;&nbsp;&nbsp;go&nbsp;game.run()&nbsp;//&nbsp;Run&nbsp;the&nbsp;game&nbsp;loop&nbsp;in&nbsp;a&nbsp;new&nbsp;thread &nbsp;&nbsp;&nbsp;&nbsp;gl.clear()&nbsp;//&nbsp;For&nbsp;some&nbsp;reason&nbsp;this&nbsp;is&nbsp;necessary&nbsp;to&nbsp;avoid&nbsp;an&nbsp;intial&nbsp;flickering &nbsp;&nbsp;&nbsp;&nbsp;gl.clear_color(255,&nbsp;255,&nbsp;255,&nbsp;255) &nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gl.clear() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gl.clear_color(255,&nbsp;255,&nbsp;255,&nbsp;255) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;game.draw_scene() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;window.swap_buffers() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glfw.wait_events() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;window.should_close()&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;window.destroy() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glfw.terminate() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(0) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} } fn&nbsp;(g&nbsp;mut&nbsp;Game)&nbsp;move_right(dx&nbsp;int)&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Reached&nbsp;left/right&nbsp;edge&nbsp;or&nbsp;another&nbsp;tetro? &nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i&nbsp;:=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;TetroSize;&nbsp;i++&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tetro&nbsp;:=&nbsp;g.tetro[i] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;:=&nbsp;tetro.y&nbsp;+&nbsp;g.pos_y &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;:=&nbsp;tetro.x&nbsp;+&nbsp;g.pos_x&nbsp;+&nbsp;dx &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;row&nbsp;:=&nbsp;g.field[y] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;row[x]&nbsp;!=&nbsp;0&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Do&nbsp;not&nbsp;move &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;g.pos_x&nbsp;+=&nbsp;dx } fn&nbsp;(g&nbsp;mut&nbsp;Game)&nbsp;delete_completed_lines()&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;y&nbsp;:=&nbsp;FieldHeight;&nbsp;y&nbsp;&gt;=&nbsp;1;&nbsp;y--&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.delete_completed_line(y) &nbsp;&nbsp;&nbsp;&nbsp;} } fn&nbsp;(g&nbsp;mut&nbsp;Game)&nbsp;delete_completed_line(y&nbsp;int)&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;x&nbsp;:=&nbsp;1;&nbsp;x&nbsp;&lt;=&nbsp;FieldWidth;&nbsp;x++&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;:=&nbsp;g.field[y] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;f[x]&nbsp;==&nbsp;0&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Move&nbsp;everything&nbsp;down&nbsp;by&nbsp;1&nbsp;position &nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;yy&nbsp;:=&nbsp;y&nbsp;-&nbsp;1;&nbsp;yy&nbsp;&gt;=&nbsp;1;&nbsp;yy--&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;x&nbsp;:=&nbsp;1;&nbsp;x&nbsp;&lt;=&nbsp;FieldWidth;&nbsp;x++&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mut&nbsp;a&nbsp;:=&nbsp;g.field[yy&nbsp;+&nbsp;1] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mut&nbsp;b&nbsp;:=&nbsp;g.field[yy] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a[x]&nbsp;=&nbsp;b[x] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} } //&nbsp;Place&nbsp;a&nbsp;new&nbsp;tetro&nbsp;on&nbsp;top fn&nbsp;(g&nbsp;mut&nbsp;Game)&nbsp;generate_tetro()&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;g.pos_y&nbsp;=&nbsp;0 &nbsp;&nbsp;&nbsp;&nbsp;g.pos_x&nbsp;=&nbsp;FieldWidth&nbsp;/&nbsp;2&nbsp;-&nbsp;TetroSize&nbsp;/&nbsp;2 &nbsp;&nbsp;&nbsp;&nbsp;g.tetro_idx&nbsp;=&nbsp;rand.next(BTetros.len) &nbsp;&nbsp;&nbsp;&nbsp;g.rotation_idx&nbsp;=&nbsp;0 &nbsp;&nbsp;&nbsp;&nbsp;g.get_tetro() } //&nbsp;Get&nbsp;the&nbsp;right&nbsp;tetro&nbsp;from&nbsp;cache fn&nbsp;(g&nbsp;mut&nbsp;Game)&nbsp;get_tetro()&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;idx&nbsp;:=&nbsp;g.tetro_idx&nbsp;*&nbsp;TetroSize&nbsp;*&nbsp;TetroSize&nbsp;+&nbsp;g.rotation_idx&nbsp;*&nbsp;TetroSize &nbsp;&nbsp;&nbsp;&nbsp;g.tetro&nbsp;=&nbsp;g.tetros_cache.slice(idx,&nbsp;idx&nbsp;+&nbsp;TetroSize) } fn&nbsp;(g&nbsp;mut&nbsp;Game)&nbsp;drop_tetro()&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i&nbsp;:=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;TetroSize;&nbsp;i++&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tetro&nbsp;:=&nbsp;g.tetro[i] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;:=&nbsp;tetro.x&nbsp;+&nbsp;g.pos_x &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;:=&nbsp;tetro.y&nbsp;+&nbsp;g.pos_y &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Remember&nbsp;the&nbsp;color&nbsp;of&nbsp;each&nbsp;block &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;TODO:&nbsp;g.field[y][x]&nbsp;=&nbsp;g.tetro_idx&nbsp;+&nbsp;1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mut&nbsp;row&nbsp;:=&nbsp;g.field[y] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;row[x]&nbsp;=&nbsp;g.tetro_idx&nbsp;+&nbsp;1 &nbsp;&nbsp;&nbsp;&nbsp;} } fn&nbsp;(g&nbsp;&amp;Game)&nbsp;draw_tetro()&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i&nbsp;:=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;TetroSize;&nbsp;i++&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tetro&nbsp;:=&nbsp;g.tetro[i] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.draw_block(g.pos_y&nbsp;+&nbsp;tetro.y,&nbsp;g.pos_x&nbsp;+&nbsp;tetro.x,&nbsp;g.tetro_idx&nbsp;+&nbsp;1) &nbsp;&nbsp;&nbsp;&nbsp;} } fn&nbsp;(g&nbsp;&amp;Game)&nbsp;draw_block(i,&nbsp;j,&nbsp;color_idx&nbsp;int)&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;g.gg.draw_rect((j&nbsp;-&nbsp;1)&nbsp;*&nbsp;BlockSize,&nbsp;(i&nbsp;-&nbsp;1)&nbsp;*&nbsp;BlockSize, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlockSize&nbsp;-&nbsp;1,&nbsp;BlockSize&nbsp;-&nbsp;1,&nbsp;Colors[color_idx]) } fn&nbsp;(g&nbsp;&amp;Game)&nbsp;draw_field()&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i&nbsp;:=&nbsp;1;&nbsp;i&nbsp;&lt;&nbsp;FieldHeight&nbsp;+&nbsp;1;&nbsp;i++&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;j&nbsp;:=&nbsp;1;&nbsp;j&nbsp;&lt;&nbsp;FieldWidth&nbsp;+&nbsp;1;&nbsp;j++&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;:=&nbsp;g.field[i] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;f[j]&nbsp;&gt;&nbsp;0&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.draw_block(i,&nbsp;j,&nbsp;f[j]) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} } fn&nbsp;(g&nbsp;&amp;Game)&nbsp;draw_scene()&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;g.draw_tetro() &nbsp;&nbsp;&nbsp;&nbsp;g.draw_field() } fn&nbsp;parse_binary_tetro(t&nbsp;int)&nbsp;[]Block&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;res&nbsp;:=&nbsp;[Block{}&nbsp;;&nbsp;4] &nbsp;&nbsp;&nbsp;&nbsp;mut&nbsp;cnt&nbsp;:=&nbsp;0 &nbsp;&nbsp;&nbsp;&nbsp;horizontal&nbsp;:=&nbsp;t&nbsp;==&nbsp;9//&nbsp;special&nbsp;case&nbsp;for&nbsp;the&nbsp;horizontal&nbsp;line &nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i&nbsp;:=&nbsp;0;&nbsp;i&nbsp;&lt;=&nbsp;3;&nbsp;i++&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Get&nbsp;ith&nbsp;digit&nbsp;of&nbsp;t &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;:=&nbsp;int(math.pow(10,&nbsp;3&nbsp;-&nbsp;i)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mut&nbsp;digit&nbsp;:=&nbsp;int(t&nbsp;/&nbsp;p) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t&nbsp;%=&nbsp;p &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Convert&nbsp;the&nbsp;digit&nbsp;to&nbsp;binary &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;j&nbsp;:=&nbsp;3;&nbsp;j&nbsp;&gt;=&nbsp;0;&nbsp;j--&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bin&nbsp;:=&nbsp;digit&nbsp;%&nbsp;2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;digit&nbsp;/=&nbsp;2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;bin&nbsp;==&nbsp;1&nbsp;||&nbsp;(horizontal&nbsp;&amp;&amp;&nbsp;i&nbsp;==&nbsp;TetroSize&nbsp;-&nbsp;1)&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;TODO:&nbsp;res[cnt].x&nbsp;=&nbsp;j &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;res[cnt].y&nbsp;=&nbsp;i &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mut&nbsp;point&nbsp;:=&nbsp;&amp;res[cnt] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;point.x&nbsp;=&nbsp;j &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;point.y&nbsp;=&nbsp;i &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cnt++ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;res } //&nbsp;TODO:&nbsp;this&nbsp;exposes&nbsp;the&nbsp;unsafe&nbsp;C&nbsp;interface,&nbsp;clean&nbsp;up fn&nbsp;key_down(wnd&nbsp;voidptr,&nbsp;key,&nbsp;code,&nbsp;action,&nbsp;mods&nbsp;int)&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;action&nbsp;!=&nbsp;2&nbsp;&amp;&amp;&nbsp;action&nbsp;!=&nbsp;1&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Fetch&nbsp;the&nbsp;game&nbsp;object&nbsp;stored&nbsp;in&nbsp;the&nbsp;user&nbsp;pointer &nbsp;&nbsp;&nbsp;&nbsp;mut&nbsp;game&nbsp;:=&nbsp;&amp;Game(glfw.get_window_user_pointer(wnd)) &nbsp;&nbsp;&nbsp;&nbsp;switch&nbsp;key&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;glfw.KEY_ESCAPE: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glfw.set_should_close(wnd,&nbsp;true) &nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;glfw.KeyUp: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Rotate&nbsp;the&nbsp;tetro &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;game.rotation_idx++ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;game.rotation_idx&nbsp;==&nbsp;TetroSize&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;game.rotation_idx&nbsp;=&nbsp;0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;game.get_tetro() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;game.pos_x&nbsp;&lt;&nbsp;0&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;game.pos_x&nbsp;=&nbsp;1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;glfw.KeyLeft: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;game.move_right(-1) &nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;glfw.KeyRight: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;game.move_right(1) &nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;glfw.KeyDown: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;game.move_tetro()&nbsp;//&nbsp;drop&nbsp;faster&nbsp;when&nbsp;the&nbsp;player&nbsp;presses&nbsp;&lt;down&gt; &nbsp;&nbsp;&nbsp;&nbsp;} } &nbsp; 我们看到这个程序是在这行代码window.onkeydown(key_down)来进行事件注册的，其渲染是在draw_scene函数进行渲染的。 &nbsp; 使用v run tetris.v命令就能看到以下的效果了。左边是debug窗口，右边是程序效果： &nbsp; &nbsp; 后面笔者还会继续关注V语言的发展，为大家带来第一手的教程分享。 &nbsp; CSDN博客原文：https://blog.csdn.net/BEYONDMA/article/details/94349691，欢迎大家入驻 CSDN 博客。 国家认证的Python工程师有哪些能力要求？ https://edu.csdn.net/topic/python115?utm_source=csdn_bw 【END】 &nbsp;热 文&nbsp;推 荐&nbsp; 微软为何痛失移动操作系统？ 漫画：一文学会面试中常问的 IO 问题！ ☞库克回应乔纳森离职；微信新版本取消“语音转文字”功能；Mac Pro生产迁至中国 | 极客头条 ☞程序员们如何破局 5G？ ☞软件为什么会沦为遗留系统？ 因为有了 TA，搞定行业应用开发，不怕不怕啦！ 除了V神,17个以太坊大会讲师的演讲精华都在这儿了！ ☞2019年技术盘点容器篇（二）：听腾讯云讲讲踏入成熟期的容器技术&nbsp;| 程序员硬核评测 ☞50行Python代码，获取公众号全部文章 不写一行代码，也能玩转Kaggle竞赛？ ☞马云曾经偶像，终于把阿里留下的1400亿败光了！ 点击阅读原文，输入关键词，即可搜索您想要的 CSDN 文章。 你点的每个“在看”，我都认真当成了喜欢","categories":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}],"tags":[{"name":"V语言","slug":"v语言","permalink":"https://vlanguage.cn/tags/v语言/"}],"keywords":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}]},{"title":"V 语言 -- 数据结构.Map","slug":"liaodong2010_94438815","date":"2019-07-02T00:00:00.000Z","updated":"2019-07-22T05:05:28.954Z","comments":true,"path":"2019/07/02/liaodong2010_94438815.html","link":"","permalink":"https://vlanguage.cn/2019/07/02/liaodong2010_94438815.html","excerpt":"","text":"V 语言 – 数据结构.Map V语言现在还在开发阶段，所以还有很多不成熟的地方。比如其中的map，还只是一个原型。下面我做一个简单的分析。 结构体定义 module builtin struct map { // cap int // keys []string // table byteptr // keys_table *string // table *Entry element_size int // collisions []Entry pub: entries []Entry is_sorted bool } struct Entry { pub: key string val voidptr // linked list for collisions // next *Entry } 可以看到，map的结构十分简单，只包含三个成员 element_size: 元素大小 entries: 实体集合 is_sorted: 是否排序 其中的is_sorted这个属性比较有意思，说明在方法里面会排序，用到排序则很有可能与提高查找效率有关。 下面再来看方法。 方法 对于一个map来说，用的最多的无非是插入元素和获取元素。 插入元素 // 插入一个元素 fn (m mut map) _set(key string, val voidptr) { e := m.new_entry(key, val) for i := 0; i &lt; m.entries.len; i++ { entry := m.entries[i] if entry.key == key { // e := Entry2{key: key, val: val} m.entries[i] = e return } } m.entries &lt;&lt; e// m.new_entry(key, val) m.is_sorted = false } 插入元素的过程可以描述为： 创建一个元素 遍历查找键是否重复 如果重复，则赋值 如果没重复，则添加到末尾 不难看出，插入用到了遍历，其时间复杂度为O(n)，是一种很低效的算法。在后续有很大的优化空间。 查找元素 // 获取元素 fn (m map) get(key string, out voidptr) bool { if m.is_sorted { // println('\\n\\nget \"$key\" sorted') m.bs(key, 0, m.entries.len, out) return true } for i := 0; i &lt; m.entries.len; i++ { entry := m.entries[i] if entry.key == key { C.memcpy(out, entry.val, m.element_size) return true } } return false } // 二分查找 fn (m map) bs(query string, start, end int, out voidptr) { // println('bs \"$query\" $start -&gt; $end') mid := start + ((end - start) / 2) if end - start == 0 { last := m.entries[end] C.memcpy(out, last.val, m.element_size) return } if end - start == 1 { first := m.entries[start] C.memcpy(out, first.val, m.element_size) return } if mid &gt;= m.entries.len { return } mid_msg := m.entries[mid] // println('mid.key=$mid_msg.key') if query &lt; mid_msg.key { m.bs(query, start, mid, out) return } m.bs(query, mid, end, out) } 查找的流程可以描述为： 判断是否已经排序 如果未排序则遍历查找 如果已排序则二分查找(排序方法需要显式调用) 查找过程用到了二分查找(O(lgn))，和遍历(O(n))，但是大部分时候，开发者不会对map显式排序，所以真正起作用的是遍历操作，也是十分低效。 改进及评价 map模块显然很不成熟，其结构和算法有很大改进空间。 如果采用数组作为存储容器，则至少也可以达到查找： O(lgn) -&gt; 排序O(lgn) + 二分查找 O(lgn)， 插入O(lgn) -&gt; 查重O(lgn) + 插入O(1)。否则数据量稍大会非常慢。 如果采用Hash实现，则可达到O(1) + O(1)的速度，不过这要看v语言的开发者如何取舍。 v语言当前还无法用于生产环境，尝鲜可以，但正式环境还不可用。其语言特性很有吸引力，但现在的完成度还不高，到稳定可用估计还需要些时日。","categories":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}],"tags":[{"name":"V语言","slug":"v语言","permalink":"https://vlanguage.cn/tags/v语言/"}],"keywords":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}]},{"title":"GITHUB排行榜C位出道-手把手教你玩转V语言版的俄罗斯方块","slug":"BEYONDMA_94349691","date":"2019-07-01T00:00:00.000Z","updated":"2019-07-22T04:55:18.400Z","comments":true,"path":"2019/07/01/BEYONDMA_94349691.html","link":"","permalink":"https://vlanguage.cn/2019/07/01/BEYONDMA_94349691.html","excerpt":"","text":"&nbsp; &nbsp; 最近&nbsp;V 语言-一个GO语言最吸晴的项目，在千呼万唤之后，终于迎来开源，并正式发布了首个可用版本，其一经推出，便强势登顶&nbsp;GitHub的榜首，引来各方热议。目前V已经可以实现自我编译迭代，笔者大致了解了一下V语言，主要有如下一些特性。 &nbsp; &nbsp; 1.快速编译：&nbsp; V每CPU核心每秒编译约120万行代码。&nbsp; V也可以调用C，编译速度下降到≈100k行/秒/CPU。安全 &nbsp; &nbsp; 2.安全策略：没有空；没有全局变量(意味着变量都是在函数体中声明)&nbsp;没有未定义的行为&nbsp; &nbsp; &nbsp; 3.性能：和C一样快，操作C没有任何成本，不支持运行时反射，编译器只有400K,整个语言及其标准库都小于400kb。V目前是用V写的，你可以在0。4秒内完成。(到今年年底，这个数字将降至≈0.15秒。) &nbsp; &nbsp; 4.强大的图形能力:支持在GDI+/Cocoa绘图之上的跨平台绘图库，以及一个基于OpenGL的图形库，以支持加载复杂的三维对象与纹理 &nbsp; &nbsp;由于曾经做过一段时间的DIRECTX的开发，V语言对于图形能力的特性宣传最吸引笔者的注意。所以我到其官网及Github上学习了一下相关内容，按照编译运行了一下俄罗斯 方块的例程，接下来向大家做一下分享。 &nbsp; &nbsp;安装V语言 &nbsp; &nbsp; 如果只是HELLO WORLD程序是非常简单的，只需要按照https://vlang.io官网的标准步骤来执行即可。而如果使用其图形处理能力笔者目前只在UBANTU平台测试成功。下面均是以UBANTU为例来说明 &nbsp; &nbsp;首先将整个项目克隆下来，再make即可 git clone https://github.com/vlang/v cd v make &nbsp; &nbsp; 如果报curl command not found，则执行以下命令安装curl sudo apt install curl &nbsp; &nbsp; 接下来在建立软链接 sudo ln -s /home/machao/v/v /usr/local/bin/v &nbsp; 然后运行v就能进到v语言的命令行了。而如果要运行俄罗斯方块还需要以下这些库的支持， sudo apt install libglfw3 libglfw3-dev libfreetype6-dev libcurl3-dev &nbsp; &nbsp; &nbsp; &nbsp; 运行俄罗斯方块 &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 接下来cd tetris,进入到俄罗斯方块的目录，先使用gedit tetris.v,来看一下v语言的代码样例，其主要部分如下： &nbsp; &nbsp;&nbsp; fn main() { glfw.init()//实始化类 mut game := &amp;Game{gg: 0} // TODO game.parse_tetros() game.init_game() mut window := glfw.create_window(glfw.WinCfg { width: WinWidth height: WinHeight title: 'V Tetris' ptr: game // glfw user pointer }) window.make_context_current() window.onkeydown(key_down)//注册事件 gg.init() game.gg = gg.new_context(gg.Cfg { width: WinWidth height: WinHeight use_ortho: true // This is needed for 2D drawing }) go game.run() // Run the game loop in a new thread gl.clear() // For some reason this is necessary to avoid an intial flickering gl.clear_color(255, 255, 255, 255) for { gl.clear() gl.clear_color(255, 255, 255, 255) game.draw_scene() window.swap_buffers() glfw.wait_events() if window.should_close() { window.destroy() glfw.terminate() exit(0) } } } fn (g mut Game) move_right(dx int) { // Reached left/right edge or another tetro? for i := 0; i &lt; TetroSize; i++ { tetro := g.tetro[i] y := tetro.y + g.pos_y x := tetro.x + g.pos_x + dx row := g.field[y] if row[x] != 0 { // Do not move return } } g.pos_x += dx } fn (g mut Game) delete_completed_lines() { for y := FieldHeight; y &gt;= 1; y-- { g.delete_completed_line(y) } } fn (g mut Game) delete_completed_line(y int) { for x := 1; x &lt;= FieldWidth; x++ { f := g.field[y] if f[x] == 0 { return } } // Move everything down by 1 position for yy := y - 1; yy &gt;= 1; yy-- { for x := 1; x &lt;= FieldWidth; x++ { mut a := g.field[yy + 1] mut b := g.field[yy] a[x] = b[x] } } } // Place a new tetro on top fn (g mut Game) generate_tetro() { g.pos_y = 0 g.pos_x = FieldWidth / 2 - TetroSize / 2 g.tetro_idx = rand.next(BTetros.len) g.rotation_idx = 0 g.get_tetro() } // Get the right tetro from cache fn (g mut Game) get_tetro() { idx := g.tetro_idx * TetroSize * TetroSize + g.rotation_idx * TetroSize g.tetro = g.tetros_cache.slice(idx, idx + TetroSize) } fn (g mut Game) drop_tetro() { for i := 0; i &lt; TetroSize; i++ { tetro := g.tetro[i] x := tetro.x + g.pos_x y := tetro.y + g.pos_y // Remember the color of each block // TODO: g.field[y][x] = g.tetro_idx + 1 mut row := g.field[y] row[x] = g.tetro_idx + 1 } } fn (g &amp;Game) draw_tetro() { for i := 0; i &lt; TetroSize; i++ { tetro := g.tetro[i] g.draw_block(g.pos_y + tetro.y, g.pos_x + tetro.x, g.tetro_idx + 1) } } fn (g &amp;Game) draw_block(i, j, color_idx int) { g.gg.draw_rect((j - 1) * BlockSize, (i - 1) * BlockSize, BlockSize - 1, BlockSize - 1, Colors[color_idx]) } fn (g &amp;Game) draw_field() { for i := 1; i &lt; FieldHeight + 1; i++ { for j := 1; j &lt; FieldWidth + 1; j++ { f := g.field[i] if f[j] &gt; 0 { g.draw_block(i, j, f[j]) } } } } fn (g &amp;Game) draw_scene() { g.draw_tetro() g.draw_field() } fn parse_binary_tetro(t int) []Block { res := [Block{} ; 4] mut cnt := 0 horizontal := t == 9// special case for the horizontal line for i := 0; i &lt;= 3; i++ { // Get ith digit of t p := int(math.pow(10, 3 - i)) mut digit := int(t / p) t %= p // Convert the digit to binary for j := 3; j &gt;= 0; j-- { bin := digit % 2 digit /= 2 if bin == 1 || (horizontal &amp;&amp; i == TetroSize - 1) { // TODO: res[cnt].x = j // res[cnt].y = i mut point := &amp;res[cnt] point.x = j point.y = i cnt++ } } } return res } // TODO: this exposes the unsafe C interface, clean up fn key_down(wnd voidptr, key, code, action, mods int) { if action != 2 &amp;&amp; action != 1 { return } // Fetch the game object stored in the user pointer mut game := &amp;Game(glfw.get_window_user_pointer(wnd)) switch key { case glfw.KEY_ESCAPE: glfw.set_should_close(wnd, true) case glfw.KeyUp: // Rotate the tetro game.rotation_idx++ if game.rotation_idx == TetroSize { game.rotation_idx = 0 } game.get_tetro() if game.pos_x &lt; 0 { game.pos_x = 1 } case glfw.KeyLeft: game.move_right(-1) case glfw.KeyRight: game.move_right(1) case glfw.KeyDown: game.move_tetro() // drop faster when the player presses &lt;down&gt; } } &nbsp; &nbsp;我们看到这个程序是在这行代码window.onkeydown(key_down)来进行事件注册的，其渲染是在draw_scene函数进行渲染的。 使用v run tetris.v命令就能看到以下的效果了。左边是debug窗口，右边是程序效果。 &nbsp; &nbsp; &nbsp; &nbsp;后面笔者还会继续关注V语言的发展，为大家带来第一手的教程分享。","categories":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}],"tags":[{"name":"V语言","slug":"v语言","permalink":"https://vlanguage.cn/tags/v语言/"}],"keywords":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}]},{"title":"V语言环境部署教程-linux","slug":"qq_32394351_93966947","date":"2019-06-28T00:00:00.000Z","updated":"2019-07-22T04:55:19.225Z","comments":true,"path":"2019/06/28/qq_32394351_93966947.html","link":"","permalink":"https://vlanguage.cn/2019/06/28/qq_32394351_93966947.html","excerpt":"","text":"在linux系统上，目前有两种搭建V语言环境的方法: &nbsp; 一:git 下载源码并编译出可执行文件，然后创建软链接 二:直接下载别人编译好的可执行文件v&nbsp; ，然后改权限为可执行文件，再创建软链接 &nbsp; 下面用ubuntu为例来讲解。centos类似操作。 &nbsp; 方法一: 先请求临时管理员权限吧，后面懒得输sudo前缀 sudo -s su &nbsp;等会儿，然后输入当前用户的密码，那么就会发现路径用户名有了root前缀了 好了，接下来按步骤操作&nbsp; 1.如果是ubuntu desktop系统。那么先得安装git。命令: apt install git 也许还没有gcc,还得安装 apt install gcc 如果是ubuntu server 系统，什么也不用安，直接干。 好了，默认你已经把git和gcc安装好了。然后随便到一个路径克隆一下源码 比如我在当前用户的根目录创建一个v目录,然后切换到里面再git mkdir v cd v git clone https://github.com/vlang/v 等克隆完毕，然后输入&nbsp; ls&nbsp;&nbsp;发现路径里面躺着一个v路径了 那么接着进这个目录看看 cd v ls -alt &nbsp; &nbsp;可以看到这个完整的项目结构了，现在我们需要进去编译一下源码: cd compiler make ls &nbsp; 弄完发现已经有一个编译好的绿色的可执行文件躺在这路径里面了。 接着在当前路径执行一下这个文件试试: ./v 发现进入这个解释器了。我这刚编译的0.1.7版本 接着退出这个编译环境，按ctrl-d然后回车 &nbsp;接着创建一个软链接。首先看下当前目录的绝对路径 pwd 看出来绝对路径是/home/dashen/cp/v/compiler,那么创建软链接的命令是: ln -s /home/dashen/cp/v/compiler/v /usr/local/bin/v 我这里是因为之前创建过了，我先删除之前那个文件再来 rm /usr/local/bin/v ln -s /home/dashen/cp/v/compiler/v /usr/local/bin/v &nbsp;弄完了再输入一个v看看 &nbsp;ok。成功了。这里需要注意的是，创建软链接的命令是 ln -s 你的可执行文件路径 /usr/local/bin/v 注意空格，然后不要那么死板敲成我的路径了，敲你们自己的。哈哈。方法一到此结束。 &nbsp; 方法二： 直接下载别人编译好了的可执行文件v。比如你现在在windows下载好了v文件，然后要把windows里的v文件搞到linux里面去 &nbsp; 默认你用xshell通过ssh连接的linux主机。然后需要安装一个上传下载的包 apt install lrzsz 然后弄完了，因为是现在是root用户，直接从windows上把文件拖到xshell里面就能上传到linux主机当前路径了 &nbsp;然后输入ls查看一下路径: 发现有个白色的v文件躺在路径里面了。接下来很关键，我们要把它变成绿色的可执行文件 &nbsp;执行以下命令: chmod +x v ls 一个绿色的可执行文件已经躺在这儿了。 然后输入: ./v &nbsp; &nbsp;没毛病。已经进去了。接着返回第一种方法，然后创建软链接。就完了。。 &nbsp; 最后写在这儿，新手可能在windows与linux之间传输文件比较麻烦，可以不用命令，用可视化的工具，他的名字叫做: &nbsp; FileZilla 在电脑管家软件中心就能下载安装了，完了起来看起来长这样的: 左边windows，右边linux，然后自己随便玩玩就会了。最后我再演示一下怎么在刚弄好的v环境编写个程序测试一下: &nbsp; 在linux下找到一个干净的路径创建一个c.v文件，千万别弄在v源码里面，具体代码看图参考: &nbsp;然后就进入了vim编辑器里面了，咱们编译一下c.v文件。先按字母键i,让vim编辑器处于insert状态 &nbsp;然后在里面写代码: 完了按ESC键，再按冒号（shift+分号键），输入wq,回车 &nbsp;这是保存并退出的意思。然后再输入v run c.v 成功了，随便happy吧，这里只是演示了一下mut的用法，用了mut申明的变量，后面就能够直接通过=改变它的值 如果不用mut申明的变量，初始化完了后面就不能再用=改变它的值了。&nbsp; &nbsp; 附录:&nbsp;Linux常用的50个命令","categories":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}],"tags":[{"name":"V语言","slug":"v语言","permalink":"https://vlanguage.cn/tags/v语言/"}],"keywords":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}]},{"title":"V语言关键字解读","slug":"qq_32394351_93883296","date":"2019-06-27T00:00:00.000Z","updated":"2019-07-22T04:55:19.178Z","comments":true,"path":"2019/06/27/qq_32394351_93883296.html","link":"","permalink":"https://vlanguage.cn/2019/06/27/qq_32394351_93883296.html","excerpt":"","text":"官方文档:https://vlang.io/docs#keywords V has 22 keywords: break const continue defer else enum fn for go goto if import in interface match module mut 用于申明可变变量，申明并初始化后的变量在后面可以直接用=赋值，不用mut申明的变量后面不可改变。例如: mut name:='dashen' println(name) name='dada' println(name) or pub return struct type","categories":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}],"tags":[{"name":"V语言","slug":"v语言","permalink":"https://vlanguage.cn/tags/v语言/"}],"keywords":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}]},{"title":"V语言初探","slug":"huangruifeng_93908166","date":"2019-06-27T00:00:00.000Z","updated":"2019-07-22T04:55:18.900Z","comments":true,"path":"2019/06/27/huangruifeng_93908166.html","link":"","permalink":"https://vlanguage.cn/2019/06/27/huangruifeng_93908166.html","excerpt":"","text":"V语言，感觉厉害。。。。。。 人家的Helloworld只需这样 fn main() { println('hello world') } 就是短小精悍。 居然还有泛型，这个可是连我们可以到处GO的都没有。 struct Repo &lt;T&gt; { db DB } fn new_repo&lt;T&gt;(db DB) Repo&lt;T&gt; { return Repo&lt;T&gt;{db: db} } // This is a generic function. V will generate it for every type it's used with. fn (r Repo&lt;T&gt;) find_by_id(id int) T? { table_name := T.name // in this example getting the name of the type gives us the table name return r.db.query_one&lt;T&gt;('select * from $table_name where id = ?', id) } fn main() { db := new_db() users_repo := new_repo&lt;User&gt;(db) posts_repo := new_repo&lt;Post&gt;(db) user := users_repo.find_by_id(1)? post := posts_repo.find_by_id(1)? } V语言官网地址:https://vlang.io V语言Github地址:https://github.com/vlang/v","categories":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}],"tags":[{"name":"V语言","slug":"v语言","permalink":"https://vlanguage.cn/tags/v语言/"}],"keywords":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}]},{"title":"V 语言强势登顶 GitHub TOP1，难道要取 Go 而代之？","slug":"yihuliunian_93874487","date":"2019-06-27T00:00:00.000Z","updated":"2019-07-22T04:55:19.842Z","comments":true,"path":"2019/06/27/yihuliunian_93874487.html","link":"","permalink":"https://vlanguage.cn/2019/06/27/yihuliunian_93874487.html","excerpt":"","text":"这个结合了 Go 和 Rust 特性的新语言 V，正式发布了首个可用版本。 整理 | 郭芮 长久以来，编程语言在语法、语义和标准库等方面都存在着千差万别，使得程序员在选择时不得不面临着差异化等难题。自然选择下，就会有旧语言的淘汰（PHP 是个意外，至今还存在）和新语言的诞生。在&nbsp;JetBrains 最新发布的《2019 开发人员生态系统现状》报告中，Java、Python、C/C#、JavaScript 等主流的编程语言在历经实践考验后依然是开发者们的心头好。 而本文的主角 V 语言，在千呼万唤之后，终于于近日开源了，并正式发布了首个可用版本（预构建的二进制文件也即将推出）！其一经发布，便强势登顶&nbsp;GitHub TOP1，引来开发者们的热议围观。 &nbsp; &nbsp; （https://github.com/vlang/v/releases/tag/v0.0.12） 根据介绍，V 是一种新型的静态编译型语言，可以“快速编译、安全且和 C/C++ 转换”，其提供了方便、快捷、安全的编程语言和工具包，还能够很好地服务于区块链技术。 V 语言作者 Reishi Saza 就表示，它是一种非常简单的语言，看官方文档 30 分钟就能完全掌握。而且，其编译器只有 400KB，无任何第三方依赖。 （作者展示的应用示例：V 语言建立的 macOS Demo） V 的核心 CPU 每秒可以编译大约 120 万行代码，这种速度是通过生成的机器代码和强大的模块化来实现的，但是目前仅支持 x64/Mach-O，预计到今年年底才能足够稳定。而在性能表现上，V 可以做到和 C 一样快，且能够翻译整个 C 或 C++ 项目，实现高达 400x 的编译速度。 std::vector&lt;std::string&gt;&nbsp;s;s.push_back(\"V&nbsp;is&nbsp;\");s.push_back(\"awesome\");std::cout&nbsp;&lt;&lt;&nbsp;s.size();mut&nbsp;s&nbsp;:=&nbsp;[]s&nbsp;&lt;&lt;&nbsp;\"V&nbsp;is&nbsp;\"s&nbsp;&lt;&lt;&nbsp;\"awesome\"println(s.len) &nbsp; 目前，整个 V 语言及其标准库小于 400 KB，开发者在 0.4 秒内就可以构建它。并且到今年年底，这个数字还将下降到大约 0.15 秒。 此外，开发者们还在官网上放出了部分示例代码。更多编译器函数介绍可参见官方网站：https://vlang.io/。 1、数据库访问： struct&nbsp;User&nbsp;{&nbsp;/*&nbsp;...&nbsp;*/&nbsp;}struct&nbsp;Post&nbsp;{&nbsp;/*&nbsp;...&nbsp;*/&nbsp;}struct&nbsp;DB&nbsp;&nbsp;&nbsp;{&nbsp;/*&nbsp;...&nbsp;*/&nbsp;}struct&nbsp;Repo&nbsp;&lt;T&gt;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;db&nbsp;DB}fn&nbsp;new_repo&lt;T&gt;(db&nbsp;DB)&nbsp;Repo&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Repo&lt;T&gt;{db:&nbsp;db}}fn&nbsp;(r&nbsp;Repo)&nbsp;find_by_id(id&nbsp;int)&nbsp;T?&nbsp;{&nbsp;//&nbsp;`?`&nbsp;means&nbsp;the&nbsp;function&nbsp;returns&nbsp;an&nbsp;optional&nbsp;&nbsp;&nbsp;&nbsp;table_name&nbsp;:=&nbsp;T.name&nbsp;//&nbsp;in&nbsp;this&nbsp;example&nbsp;getting&nbsp;the&nbsp;name&nbsp;of&nbsp;the&nbsp;type&nbsp;gives&nbsp;us&nbsp;the&nbsp;table&nbsp;name&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;r.db.query_one&lt;T&gt;(\"select&nbsp;*&nbsp;from&nbsp;$table_name&nbsp;where&nbsp;id&nbsp;=&nbsp;?\",&nbsp;id)}fn&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;db&nbsp;:=&nbsp;new_db()&nbsp;&nbsp;&nbsp;&nbsp;users_repo&nbsp;:=&nbsp;new_repo&lt;User&gt;(db)&nbsp;&nbsp;&nbsp;&nbsp;posts_repo&nbsp;:=&nbsp;new_repo&lt;Post&gt;(db)&nbsp;&nbsp;&nbsp;&nbsp;user&nbsp;:=&nbsp;users_repo.find_by_id(1)&nbsp;or&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eprintln(\"User&nbsp;not&nbsp;found\")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;post&nbsp;:=&nbsp;posts_repo.find_by_id(1)&nbsp;or&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eprintln(\"Post&nbsp;not&nbsp;found\")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;}}&nbsp; &nbsp; 2、网络开发： struct&nbsp;Story&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;title&nbsp;string}//&nbsp;Fetches&nbsp;top&nbsp;HN&nbsp;stories&nbsp;in&nbsp;8&nbsp;coroutines&nbsp;fn&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;resp&nbsp;:=&nbsp;http.get(\"https://hacker-news.firebaseio.com/v0/topstories.json\")?&nbsp;&nbsp;&nbsp;&nbsp;ids&nbsp;:=&nbsp;json.decode([]int,&nbsp;resp.body)?&nbsp;&nbsp;&nbsp;&nbsp;mut&nbsp;cursor&nbsp;:=&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;_&nbsp;in&nbsp;0..8&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;go&nbsp;fn()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;{&nbsp;//&nbsp;Without&nbsp;this&nbsp;lock&nbsp;the&nbsp;program&nbsp;will&nbsp;not&nbsp;compile&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;cursor&nbsp;&gt;=&nbsp;ids.len&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id&nbsp;:=&nbsp;ids[cursor]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cursor++&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resp&nbsp;:=&nbsp;http.get(\"https://hacker-news.firebaseio.com/v0/item/$id.json\")?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;story&nbsp;:=&nbsp;json.decode(Story,&nbsp;resp.body)?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(story.title)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}()&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;runtime.wait()&nbsp;//&nbsp;Waits&nbsp;for&nbsp;all&nbsp;coroutines&nbsp;to&nbsp;finish&nbsp;}&nbsp; &nbsp; 当然，目前V 语言的开发仍处于早期阶段，很多方面还不够完善，尤其是内存管理上还面临着与 Go 和 Rust 同样繁琐的生命期管理问题，但对比 C++ 等手动和半自动的管理方式还是更省心一些的。 那么开发者们怎么看？ @三川走刀口：还是要得到开发者认可，但是对于安卓开发好像没用？ @淡定的龙哥：Go语言同父异母的弟弟？ @Heisenber哥：语言特性只是一方面，生态也很重要。 @王的凝视：这个新语言提出来是为了解决什么问题？每种语言都有适合场景，如果没有合适场景迟早也要被淘汰。 @楚小欢：执行效率比C高应该不可能，C现在都被认为是汇编语言，本身语义也十分接近汇编。别的语言只要有高级点的特性，效率就不可能超过C。 &nbsp; 总之，这个新生的 V 语言还是需要不断的发展，得到开发者的广泛应用才能焕发生机，也才能有望助力程序员做到真正的“人剑合一”。 品略图书馆 http://www.pinlue.com/ &nbsp; &nbsp;","categories":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}],"tags":[{"name":"V语言","slug":"v语言","permalink":"https://vlanguage.cn/tags/v语言/"}],"keywords":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}]},{"title":"V 语言强势登顶 GitHub TOP1，欲取 Go 而代之？","slug":"soledadzz_93813596","date":"2019-06-26T00:00:00.000Z","updated":"2019-07-22T05:05:30.158Z","comments":true,"path":"2019/06/26/soledadzz_93813596.html","link":"","permalink":"https://vlanguage.cn/2019/06/26/soledadzz_93813596.html","excerpt":"","text":"这个结合了 Go 和 Rust 特性的新语言 V，正式发布了首个可用版本。 长久以来，编程语言在语法、语义和标准库等方面都存在着千差万别，使得程序员在选择时不得不面临着差异化等难题。自然选择下，就会有旧语言的淘汰（PHP 是个意外，至今还存在）和新语言的诞生。在 JetBrains 最新发布的《2019 开发人员生态系统现状》报告中，Java、Python、C/C#、JavaScript 等主流的编程语言在历经实践考验后依然是开发者们的心头好。 而本文的主角 V 语言，在千呼万唤之后，终于于近日开源了，并正式发布了首个可用版本（预构建的二进制文件也即将推出）！其一经发布，便强势登顶 GitHub TOP1，引来开发者们的热议围观。 （https://github.com/vlang/v/releases/tag/v0.0.12） 根据介绍，V 是一种新型的静态编译型语言，可以“快速编译、安全且和 C/C++ 转换”，其提供了方便、快捷、安全的编程语言和工具包，还能够很好地服务于区块链技术。 V 语言作者 Reishi Saza 就表示，它是一种非常简单的语言，看官方文档 30 分钟就能完全掌握。而且，其编译器只有 400KB，无任何第三方依赖。 （作者展示的应用示例：V 语言建立的 macOS Demo） V 的核心 CPU 每秒可以编译大约 120 万行代码，这种速度是通过生成的机器代码和强大的模块化来实现的，但是目前仅支持 x64/Mach-O，预计到今年年底才能足够稳定。而在性能表现上，V 可以做到和 C 一样快，且能够翻译整个 C 或 C++ 项目，实现高达 400x 的编译速度。 std::vector&lt;std::string&gt;&nbsp;s;s.push_back(\"V&nbsp;is&nbsp;\");s.push_back(\"awesome\");std::cout&nbsp;&lt;&lt;&nbsp;s.size();mut&nbsp;s&nbsp;:=&nbsp;[]s&nbsp;&lt;&lt;&nbsp;'V&nbsp;is&nbsp;'s&nbsp;&lt;&lt;&nbsp;'awesome'println(s.len)s.push_back(\"V&nbsp;is&nbsp;\");s.push_back(\"awesome\");std::cout&nbsp;&lt;&lt;&nbsp;s.size();mut&nbsp;s&nbsp;:=&nbsp;[]s&nbsp;&lt;&lt;&nbsp;'V&nbsp;is&nbsp;'s&nbsp;&lt;&lt;&nbsp;'awesome'println(s.len) 目前，整个 V 语言及其标准库小于 400 KB，开发者在 0.4 秒内就可以构建它。并且到今年年底，这个数字还将下降到大约 0.15 秒。 此外，开发者们还在官网上放出了部分示例代码。更多编译器函数介绍可参见官方网站：https://vlang.io/。 1、数据库访问： struct&nbsp;User&nbsp;{&nbsp;/*&nbsp;...&nbsp;*/&nbsp;}struct&nbsp;Post&nbsp;{&nbsp;/*&nbsp;...&nbsp;*/&nbsp;}struct&nbsp;DB&nbsp;&nbsp;&nbsp;{&nbsp;/*&nbsp;...&nbsp;*/&nbsp;}struct&nbsp;Repo&nbsp;&lt;T&gt;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;db&nbsp;DB}fn&nbsp;new_repo&lt;T&gt;(db&nbsp;DB)&nbsp;Repo&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Repo&lt;T&gt;{db:&nbsp;db}}fn&nbsp;(r&nbsp;Repo)&nbsp;find_by_id(id&nbsp;int)&nbsp;T?&nbsp;{&nbsp;//&nbsp;`?`&nbsp;means&nbsp;the&nbsp;function&nbsp;returns&nbsp;an&nbsp;optional&nbsp;&nbsp;&nbsp;&nbsp;table_name&nbsp;:=&nbsp;T.name&nbsp;//&nbsp;in&nbsp;this&nbsp;example&nbsp;getting&nbsp;the&nbsp;name&nbsp;of&nbsp;the&nbsp;type&nbsp;gives&nbsp;us&nbsp;the&nbsp;table&nbsp;name&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;r.db.query_one&lt;T&gt;('select&nbsp;*&nbsp;from&nbsp;$table_name&nbsp;where&nbsp;id&nbsp;=&nbsp;?',&nbsp;id)}fn&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;db&nbsp;:=&nbsp;new_db()&nbsp;&nbsp;&nbsp;&nbsp;users_repo&nbsp;:=&nbsp;new_repo&lt;User&gt;(db)&nbsp;&nbsp;&nbsp;&nbsp;posts_repo&nbsp;:=&nbsp;new_repo&lt;Post&gt;(db)&nbsp;&nbsp;&nbsp;&nbsp;user&nbsp;:=&nbsp;users_repo.find_by_id(1)&nbsp;or&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eprintln('User&nbsp;not&nbsp;found')&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;post&nbsp;:=&nbsp;posts_repo.find_by_id(1)&nbsp;or&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eprintln('Post&nbsp;not&nbsp;found')&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;}}&nbsp;/*&nbsp;...&nbsp;*/&nbsp;}struct&nbsp;Post&nbsp;{&nbsp;/*&nbsp;...&nbsp;*/&nbsp;}struct&nbsp;DB&nbsp;&nbsp;&nbsp;{&nbsp;/*&nbsp;...&nbsp;*/&nbsp;}struct&nbsp;Repo&nbsp;&lt;T&gt;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;db&nbsp;DB}fn&nbsp;new_repo&lt;T&gt;(db&nbsp;DB)&nbsp;Repo&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Repo&lt;T&gt;{db:&nbsp;db}}fn&nbsp;(r&nbsp;Repo)&nbsp;find_by_id(id&nbsp;int)&nbsp;T?&nbsp;{&nbsp;//&nbsp;`?`&nbsp;means&nbsp;the&nbsp;function&nbsp;returns&nbsp;an&nbsp;optional&nbsp;&nbsp;&nbsp;&nbsp;table_name&nbsp;:=&nbsp;T.name&nbsp;//&nbsp;in&nbsp;this&nbsp;example&nbsp;getting&nbsp;the&nbsp;name&nbsp;of&nbsp;the&nbsp;type&nbsp;gives&nbsp;us&nbsp;the&nbsp;table&nbsp;name&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;r.db.query_one&lt;T&gt;('select&nbsp;*&nbsp;from&nbsp;$table_name&nbsp;where&nbsp;id&nbsp;=&nbsp;?',&nbsp;id)}fn&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;db&nbsp;:=&nbsp;new_db()&nbsp;&nbsp;&nbsp;&nbsp;users_repo&nbsp;:=&nbsp;new_repo&lt;User&gt;(db)&nbsp;&nbsp;&nbsp;&nbsp;posts_repo&nbsp;:=&nbsp;new_repo&lt;Post&gt;(db)&nbsp;&nbsp;&nbsp;&nbsp;user&nbsp;:=&nbsp;users_repo.find_by_id(1)&nbsp;or&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eprintln('User&nbsp;not&nbsp;found')&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;post&nbsp;:=&nbsp;posts_repo.find_by_id(1)&nbsp;or&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eprintln('Post&nbsp;not&nbsp;found')&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;}}&nbsp; 2、网络开发： struct&nbsp;Story&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;title&nbsp;string}//&nbsp;Fetches&nbsp;top&nbsp;HN&nbsp;stories&nbsp;in&nbsp;8&nbsp;coroutines&nbsp;fn&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;resp&nbsp;:=&nbsp;http.get('https://hacker-news.firebaseio.com/v0/topstories.json')?&nbsp;&nbsp;&nbsp;&nbsp;ids&nbsp;:=&nbsp;json.decode([]int,&nbsp;resp.body)?&nbsp;&nbsp;&nbsp;&nbsp;mut&nbsp;cursor&nbsp;:=&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;_&nbsp;in&nbsp;0..8&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;go&nbsp;fn()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;{&nbsp;//&nbsp;Without&nbsp;this&nbsp;lock&nbsp;the&nbsp;program&nbsp;will&nbsp;not&nbsp;compile&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;cursor&nbsp;&gt;=&nbsp;ids.len&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id&nbsp;:=&nbsp;ids[cursor]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cursor++&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resp&nbsp;:=&nbsp;http.get('https://hacker-news.firebaseio.com/v0/item/$id.json')?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;story&nbsp;:=&nbsp;json.decode(Story,&nbsp;resp.body)?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(story.title)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}()&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;runtime.wait()&nbsp;//&nbsp;Waits&nbsp;for&nbsp;all&nbsp;coroutines&nbsp;to&nbsp;finish&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title&nbsp;string}//&nbsp;Fetches&nbsp;top&nbsp;HN&nbsp;stories&nbsp;in&nbsp;8&nbsp;coroutines&nbsp;fn&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;resp&nbsp;:=&nbsp;http.get('https://hacker-news.firebaseio.com/v0/topstories.json')?&nbsp;&nbsp;&nbsp;&nbsp;ids&nbsp;:=&nbsp;json.decode([]int,&nbsp;resp.body)?&nbsp;&nbsp;&nbsp;&nbsp;mut&nbsp;cursor&nbsp;:=&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;_&nbsp;in&nbsp;0..8&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;go&nbsp;fn()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;{&nbsp;//&nbsp;Without&nbsp;this&nbsp;lock&nbsp;the&nbsp;program&nbsp;will&nbsp;not&nbsp;compile&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;cursor&nbsp;&gt;=&nbsp;ids.len&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id&nbsp;:=&nbsp;ids[cursor]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cursor++&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resp&nbsp;:=&nbsp;http.get('https://hacker-news.firebaseio.com/v0/item/$id.json')?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;story&nbsp;:=&nbsp;json.decode(Story,&nbsp;resp.body)?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(story.title)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}()&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;runtime.wait()&nbsp;//&nbsp;Waits&nbsp;for&nbsp;all&nbsp;coroutines&nbsp;to&nbsp;finish&nbsp;}&nbsp; 当然，目前V 语言的开发仍处于早期阶段，很多方面还不够完善，尤其是内存管理上还面临着与 Go 和 Rust 同样繁琐的生命期管理问题，但对比 C++ 等手动和半自动的管理方式还是更省心一些的。 那么开发者们怎么看？ @三川走刀口：还是要得到开发者认可，但是对于安卓开发好像没用？ @淡定的龙哥：Go语言同父异母的弟弟？ @Heisenber哥：语言特性只是一方面，生态也很重要。 @王的凝视：这个新语言提出来是为了解决什么问题？每种语言都有适合场景，如果没有合适场景迟早也要被淘汰。 @楚小欢：执行效率比C高应该不可能，C现在都被认为是汇编语言，本身语义也十分接近汇编。别的语言只要有高级点的特性，效率就不可能超过C。 总之，这个新生的 V 语言还是需要不断的发展，得到开发者的广泛应用才能焕发生机，也才能有望助力程序员做到真正的“人剑合一”。","categories":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}],"tags":[{"name":"V语言","slug":"v语言","permalink":"https://vlanguage.cn/tags/v语言/"}],"keywords":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}]},{"title":"V语言（Vlang）初探","slug":"SchopenhauerZhang_93709649","date":"2019-06-26T00:00:00.000Z","updated":"2019-07-22T05:05:29.976Z","comments":true,"path":"2019/06/26/SchopenhauerZhang_93709649.html","link":"","permalink":"https://vlanguage.cn/2019/06/26/SchopenhauerZhang_93709649.html","excerpt":"","text":"Vlang文档： https://vlang.io/docs github资料地址： https://github.com/vlang-zh/vlang-zh.github.io 持续更新中","categories":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}],"tags":[{"name":"V语言","slug":"v语言","permalink":"https://vlanguage.cn/tags/v语言/"}],"keywords":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}]},{"title":"V 语言强势登顶 GitHub TOP1，欲取 Go 而代之？","slug":"TG229dvt5I93mxaQ5A6U_93805436","date":"2019-06-26T00:00:00.000Z","updated":"2019-07-22T05:05:30.514Z","comments":true,"path":"2019/06/26/TG229dvt5I93mxaQ5A6U_93805436.html","link":"","permalink":"https://vlanguage.cn/2019/06/26/TG229dvt5I93mxaQ5A6U_93805436.html","excerpt":"","text":"这个结合了 Go 和 Rust 特性的新语言 V，正式发布了首个可用版本。 长久以来，编程语言在语法、语义和标准库等方面都存在着千差万别，使得程序员在选择时不得不面临着差异化等难题。自然选择下，就会有旧语言的淘汰（PHP 是个意外，至今还存在）和新语言的诞生。在 JetBrains 最新发布的《2019 开发人员生态系统现状》报告中，Java、Python、C/C#、JavaScript 等主流的编程语言在历经实践考验后依然是开发者们的心头好。 而本文的主角 V 语言，在千呼万唤之后，终于于近日开源了，并正式发布了首个可用版本（预构建的二进制文件也即将推出）！其一经发布，便强势登顶 GitHub TOP1，引来开发者们的热议围观。 （https://github.com/vlang/v/releases/tag/v0.0.12） 根据介绍，V 是一种新型的静态编译型语言，可以“快速编译、安全且和 C/C++ 转换”，其提供了方便、快捷、安全的编程语言和工具包，还能够很好地服务于区块链技术。 V 语言作者 Reishi Saza 就表示，它是一种非常简单的语言，看官方文档 30 分钟就能完全掌握。而且，其编译器只有 400KB，无任何第三方依赖。 （作者展示的应用示例：V 语言建立的 macOS Demo） V 的核心 CPU 每秒可以编译大约 120 万行代码，这种速度是通过生成的机器代码和强大的模块化来实现的，但是目前仅支持 x64/Mach-O，预计到今年年底才能足够稳定。而在性能表现上，V 可以做到和 C 一样快，且能够翻译整个 C 或 C++ 项目，实现高达 400x 的编译速度。 std::vector&lt;std::string&gt;&nbsp;s;s.push_back(\"V&nbsp;is&nbsp;\");s.push_back(\"awesome\");std::cout&nbsp;&lt;&lt;&nbsp;s.size();mut&nbsp;s&nbsp;:=&nbsp;[]s&nbsp;&lt;&lt;&nbsp;'V&nbsp;is&nbsp;'s&nbsp;&lt;&lt;&nbsp;'awesome'println(s.len)s.push_back(\"V&nbsp;is&nbsp;\");s.push_back(\"awesome\");std::cout&nbsp;&lt;&lt;&nbsp;s.size();mut&nbsp;s&nbsp;:=&nbsp;[]s&nbsp;&lt;&lt;&nbsp;'V&nbsp;is&nbsp;'s&nbsp;&lt;&lt;&nbsp;'awesome'println(s.len) 目前，整个 V 语言及其标准库小于 400 KB，开发者在 0.4 秒内就可以构建它。并且到今年年底，这个数字还将下降到大约 0.15 秒。 此外，开发者们还在官网上放出了部分示例代码。更多编译器函数介绍可参见官方网站：https://vlang.io/。 1、数据库访问： struct&nbsp;User&nbsp;{&nbsp;/*&nbsp;...&nbsp;*/&nbsp;}struct&nbsp;Post&nbsp;{&nbsp;/*&nbsp;...&nbsp;*/&nbsp;}struct&nbsp;DB&nbsp;&nbsp;&nbsp;{&nbsp;/*&nbsp;...&nbsp;*/&nbsp;}struct&nbsp;Repo&nbsp;&lt;T&gt;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;db&nbsp;DB}fn&nbsp;new_repo&lt;T&gt;(db&nbsp;DB)&nbsp;Repo&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Repo&lt;T&gt;{db:&nbsp;db}}fn&nbsp;(r&nbsp;Repo)&nbsp;find_by_id(id&nbsp;int)&nbsp;T?&nbsp;{&nbsp;//&nbsp;`?`&nbsp;means&nbsp;the&nbsp;function&nbsp;returns&nbsp;an&nbsp;optional&nbsp;&nbsp;&nbsp;&nbsp;table_name&nbsp;:=&nbsp;T.name&nbsp;//&nbsp;in&nbsp;this&nbsp;example&nbsp;getting&nbsp;the&nbsp;name&nbsp;of&nbsp;the&nbsp;type&nbsp;gives&nbsp;us&nbsp;the&nbsp;table&nbsp;name&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;r.db.query_one&lt;T&gt;('select&nbsp;*&nbsp;from&nbsp;$table_name&nbsp;where&nbsp;id&nbsp;=&nbsp;?',&nbsp;id)}fn&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;db&nbsp;:=&nbsp;new_db()&nbsp;&nbsp;&nbsp;&nbsp;users_repo&nbsp;:=&nbsp;new_repo&lt;User&gt;(db)&nbsp;&nbsp;&nbsp;&nbsp;posts_repo&nbsp;:=&nbsp;new_repo&lt;Post&gt;(db)&nbsp;&nbsp;&nbsp;&nbsp;user&nbsp;:=&nbsp;users_repo.find_by_id(1)&nbsp;or&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eprintln('User&nbsp;not&nbsp;found')&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;post&nbsp;:=&nbsp;posts_repo.find_by_id(1)&nbsp;or&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eprintln('Post&nbsp;not&nbsp;found')&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;}}&nbsp;/*&nbsp;...&nbsp;*/&nbsp;}struct&nbsp;Post&nbsp;{&nbsp;/*&nbsp;...&nbsp;*/&nbsp;}struct&nbsp;DB&nbsp;&nbsp;&nbsp;{&nbsp;/*&nbsp;...&nbsp;*/&nbsp;}struct&nbsp;Repo&nbsp;&lt;T&gt;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;db&nbsp;DB}fn&nbsp;new_repo&lt;T&gt;(db&nbsp;DB)&nbsp;Repo&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Repo&lt;T&gt;{db:&nbsp;db}}fn&nbsp;(r&nbsp;Repo)&nbsp;find_by_id(id&nbsp;int)&nbsp;T?&nbsp;{&nbsp;//&nbsp;`?`&nbsp;means&nbsp;the&nbsp;function&nbsp;returns&nbsp;an&nbsp;optional&nbsp;&nbsp;&nbsp;&nbsp;table_name&nbsp;:=&nbsp;T.name&nbsp;//&nbsp;in&nbsp;this&nbsp;example&nbsp;getting&nbsp;the&nbsp;name&nbsp;of&nbsp;the&nbsp;type&nbsp;gives&nbsp;us&nbsp;the&nbsp;table&nbsp;name&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;r.db.query_one&lt;T&gt;('select&nbsp;*&nbsp;from&nbsp;$table_name&nbsp;where&nbsp;id&nbsp;=&nbsp;?',&nbsp;id)}fn&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;db&nbsp;:=&nbsp;new_db()&nbsp;&nbsp;&nbsp;&nbsp;users_repo&nbsp;:=&nbsp;new_repo&lt;User&gt;(db)&nbsp;&nbsp;&nbsp;&nbsp;posts_repo&nbsp;:=&nbsp;new_repo&lt;Post&gt;(db)&nbsp;&nbsp;&nbsp;&nbsp;user&nbsp;:=&nbsp;users_repo.find_by_id(1)&nbsp;or&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eprintln('User&nbsp;not&nbsp;found')&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;post&nbsp;:=&nbsp;posts_repo.find_by_id(1)&nbsp;or&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eprintln('Post&nbsp;not&nbsp;found')&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;}}&nbsp; 2、网络开发： struct&nbsp;Story&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;title&nbsp;string}//&nbsp;Fetches&nbsp;top&nbsp;HN&nbsp;stories&nbsp;in&nbsp;8&nbsp;coroutines&nbsp;fn&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;resp&nbsp;:=&nbsp;http.get('https://hacker-news.firebaseio.com/v0/topstories.json')?&nbsp;&nbsp;&nbsp;&nbsp;ids&nbsp;:=&nbsp;json.decode([]int,&nbsp;resp.body)?&nbsp;&nbsp;&nbsp;&nbsp;mut&nbsp;cursor&nbsp;:=&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;_&nbsp;in&nbsp;0..8&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;go&nbsp;fn()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;{&nbsp;//&nbsp;Without&nbsp;this&nbsp;lock&nbsp;the&nbsp;program&nbsp;will&nbsp;not&nbsp;compile&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;cursor&nbsp;&gt;=&nbsp;ids.len&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id&nbsp;:=&nbsp;ids[cursor]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cursor++&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resp&nbsp;:=&nbsp;http.get('https://hacker-news.firebaseio.com/v0/item/$id.json')?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;story&nbsp;:=&nbsp;json.decode(Story,&nbsp;resp.body)?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(story.title)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}()&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;runtime.wait()&nbsp;//&nbsp;Waits&nbsp;for&nbsp;all&nbsp;coroutines&nbsp;to&nbsp;finish&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title&nbsp;string}//&nbsp;Fetches&nbsp;top&nbsp;HN&nbsp;stories&nbsp;in&nbsp;8&nbsp;coroutines&nbsp;fn&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;resp&nbsp;:=&nbsp;http.get('https://hacker-news.firebaseio.com/v0/topstories.json')?&nbsp;&nbsp;&nbsp;&nbsp;ids&nbsp;:=&nbsp;json.decode([]int,&nbsp;resp.body)?&nbsp;&nbsp;&nbsp;&nbsp;mut&nbsp;cursor&nbsp;:=&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;_&nbsp;in&nbsp;0..8&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;go&nbsp;fn()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;{&nbsp;//&nbsp;Without&nbsp;this&nbsp;lock&nbsp;the&nbsp;program&nbsp;will&nbsp;not&nbsp;compile&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;cursor&nbsp;&gt;=&nbsp;ids.len&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id&nbsp;:=&nbsp;ids[cursor]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cursor++&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resp&nbsp;:=&nbsp;http.get('https://hacker-news.firebaseio.com/v0/item/$id.json')?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;story&nbsp;:=&nbsp;json.decode(Story,&nbsp;resp.body)?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(story.title)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}()&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;runtime.wait()&nbsp;//&nbsp;Waits&nbsp;for&nbsp;all&nbsp;coroutines&nbsp;to&nbsp;finish&nbsp;}&nbsp; 当然，目前V 语言的开发仍处于早期阶段，很多方面还不够完善，尤其是内存管理上还面临着与 Go 和 Rust 同样繁琐的生命期管理问题，但对比 C++ 等手动和半自动的管理方式还是更省心一些的。 那么开发者们怎么看？ @三川走刀口：还是要得到开发者认可，但是对于安卓开发好像没用？ @淡定的龙哥：Go语言同父异母的弟弟？ @Heisenber哥：语言特性只是一方面，生态也很重要。 @王的凝视：这个新语言提出来是为了解决什么问题？每种语言都有适合场景，如果没有合适场景迟早也要被淘汰。 @楚小欢：执行效率比C高应该不可能，C现在都被认为是汇编语言，本身语义也十分接近汇编。别的语言只要有高级点的特性，效率就不可能超过C。 总之，这个新生的 V 语言还是需要不断的发展，得到开发者的广泛应用才能焕发生机，也才能有望助力程序员做到真正的“人剑合一”。","categories":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}],"tags":[{"name":"V语言","slug":"v语言","permalink":"https://vlanguage.cn/tags/v语言/"}],"keywords":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}]},{"title":"年轻人的第一篇V语言笔记","slug":"zjbyough_93663256","date":"2019-06-25T00:00:00.000Z","updated":"2019-07-22T04:55:19.894Z","comments":true,"path":"2019/06/25/zjbyough_93663256.html","link":"","permalink":"https://vlanguage.cn/2019/06/25/zjbyough_93663256.html","excerpt":"","text":"V语言极限学习 我听说V语言看文档半小时就能完全掌握？？？？以我的智商一小时掌握不了我就给各位科普一下广告法？？？ 宇宙惯例hello world // first v code fn main(){ printIn(\"hello world\") } 不需要行结束符 v函数使用fn声明，和其他语言一样，main函数是程序入口 注释规则和c一样 输出使用内置函数 printIn() 宇宙惯例2. 1+1 fn main(){ a := 1 b := 2 mut name := \"v langue\" name = \"v\" printIn(add(a,b)) } fn add(a int,b int) int { return a+b } 变量名在类型名之前（反人类） 函数和变量都可以提前，也就是可以“先调用，再声明” 变量用:=声明并初始化，变量默认不允许修改，要修改必须加 mut 修改变量用 = v没有全局变量，变量只能在函数中定义 定义的变量必须使用，不允许只定义，不使用，和go像 子代码块中不允许使用父代码块中已经定义的变量,如下面的代码会编译出错 fn main(){ a := 20 if true{ a := 30 } } 基本数据类型 string 在V中，字符串是只读字节数组。 字符串数据使用UTF-8编码。 单引号和双引号都可用于表示字符串（TODO：尚不支持双引号）。 为保持一致性，vfmt将双引号转换为单引号，除非该字符串包含单引号字符。 字符串是不可变的。 这意味着子字符串函数非常有效：不执行复制，不需要额外的分配。 All operators in V must have values of the same type on both sides. This code will not compile if age is an int: println('age = ’ + age) We have to either convert age to a string: println('age = ’ + age.str()) or use string interpolation (preferred): println(‘age = $age’) 翻译 V中的所有运算符必须在两边都具有相同类型的值。如果age是int: println(‘age = ’ + age’)，这段代码将无法编译。我们必须将age转换为一个字符串:println('age = ’ + age.str())或使用字符串插值(preferred): println(‘age = ’ $age’) 数组 fn main(){ a := [1,2,3] printIn(a) } 数组类型由数组第一个元素决定 数组中元素类型必须相同 使用&lt;&lt;在数组末尾插入元素 使用.len返回数组长度 val in array,如果数组array包含val，返回true 字典 mut m := map[string]int{} // Only maps with string keys are allowed for now m['one'] = 1 println(m['one']) // ==&gt; \"1\" 这个字典人家似乎还没有写好，emmmm，一堆TODO，你先写着，咱不急，看下一个 流程控制 if a := 10 b := 20 if a &lt; b { println('$a &lt; $b') } else if a &gt; b { println('$a &gt; $b') } else { println('$a == $b') } 条件没有小括号 始终有大括号 if语句可以作为一个表达式 num := 777 s := if num % 2 == 0 { 'even' } else { 'odd' } println(s) // ==&gt; \"odd\" in 作用： 检查数组中是否含有某个元素 布尔表达式，如： if parser.token == .plus || parser.token == .minus || parser.token == .div || parser.token == .mult { ... } if parser.token in [.plus, .minus, .div, .mult] { ... } 上下两个是等价的，使用下面的语法时，v不会创建数组 for for比较牛逼，因为我看他文档写的比之前的都多…(狗头)，知道为啥吗，应为v只有一种循环，就是for，哈哈哈哈 虽然只有一种循环，但人家for有好几种啊~~~ for in fn main(){ list := ['a','b','c'] for value in list{ printIn(value) } } value-in 如果需要数据的索引，可以用另一种方法 names := ['Sam', 'Peter'] for i, name in names { println('$i) $name') // Output: 0) Sam } // 1) Peter 第二种for(类似于while) mut sum := 0 mut i := 0 for i &lt;= 100 { sum += i i++ } println(sum) // ==&gt; \"5050\" 不写条件将导致死循环 第三种for(类似c) for i := 0; i &lt; 10; i++ { println(i) } 为啥这儿的i不用加mut而可以变化？？别问，文档这么写的！！！ Here i doesn’t need to be declared with mut since it’s always going to be mutable by definition. switch os := 'windows' print('V is running on ') switch os { case 'darwin': println('macOS.') case 'linux': println('Linux.') default: println(os) } 这里的switch和c里的差不多，只不过v中不需要在每个case后面加break 结构体 结构体？？？你可别告诉我你面向过程啊 struct Point { x int y int } p := Point{ x: 10 y: 20 } println(p.x) // Struct fields are accessed using a dot 属性访问用. 结构是在堆栈上分配的。若要在堆上分配结构并获取指向它的指针，请使用&amp;,如 pointer := &amp;Point{10, 10} // 有三个或更少字段的结构体可使用这种替代写法 println(pointer.x) // 用指针访问值和其他一样，都用. 结构体嵌套，目前还不支持，不过快了 // 就直接复制了，他支持了再说（到时候我也不一定看） V doesn't have subclassing, but it supports embedded structs: // TODO: this will be implemented later in June struct Button { Widget title string } button := new_button('Click me') button.set_pos(x, y) // Without embedding we'd have to do button.widget.set_pos(x,y) 访问修饰符 默认的结构体是私有的，不可变的，可以使用访问修饰符pub 和 mut 修改，pub和mut有五种组合（不明白了吧，还有一种pub mut mut）,先把文档复制过来再看是个什么妖魔 struct Foo { a int // private immutable (default) mut: b int // private mutable c int // (you can list multiple fields with the same access modifier) pub: d int // public immmutable (readonly) pub mut: e int // public, but mutable only in parent module pub mut mut: f int // public and mutable both inside and outside parent module } // (not recommended to use, that's why it's so verbose) 访问修饰符 作用 不写（默认） 私有，不可变 mut 私有，可变 pub 公有，不可变 pub mut 公有，仅在父模块可变 pub mut mut 公有，父模块内部外部都可变 一脸懵逼是吧，哈哈哈，依老衲看来，这和c++中的public，private啥的一样，只不过他的变量（不能叫变量吧，先这样叫）默认是常量（const）你定义时需要加一个mut才能变成其他语言的“变量”，加一个pub这个变量就变成公有变量，从结构体外部可以访问了，加一个pub mut他就在结构体内外可以访问，而只能在结构体内部能改变，如字符串结构体中的len，外部可以访问他，但不能改变它，内部才能改变，最后pub mut mut 就是内外都可以访问，都可以修改。 Methods，方法 v没有class 吓死我了，辛亏有方法 一个方法就是一个函数，它带一个特殊的参数（接收器） // 继续粘贴文档代码，CV工程师，年薪百万，啊啊啊啊啊啊啊啊 struct User { age int } fn (u User) can_register() bool { return u.age &gt; 16 } user := User{age: 10} println(user.can_register()) // ==&gt; \"false\" user2 := User{age: 20} println(user2.can_register()) // ==&gt; \"true\" 这里的can_register就是一个方法，他的接收器是u，类型是User，官方说接收器名字最好用简短的，别用self，this啥的，一个字母最好（要不然没特色，开玩笑的） Pure functions by default 英语捉急，无法翻译，大概就是默认的纯函数，应为V没有全局变量，加上变量默认不能改变，哪怕是传参时也一样， 后面开始赋值粘贴了 struct User { mut: is_registered bool } fn (u mut User) register() { u.is_registered = true } mut user := User{} println(user.is_registered) // ==&gt; \"false\" user.register() println(user.is_registered) // ==&gt; \"true\" fn multiply_by_2(arr mut []int) { for i := 0; i &lt; arr.len; i++ { arr[i] *= 2 } } mut nums := [1, 2, 3] multiply_by_2(mut nums) println(nums) // ==&gt; \"[2, 4, 6]\" 注意，在调用此函数时，必须在nums之前添加mut。 这清楚地表明被调用的函数将修改该值。 最好返回值而不是修改参数。修改参数应该只在应用程序的性能关键部分执行，以减少分配和复制。 使用user.register()或user = register(user)代替register(mut user)。 V可以很容易地返回对象的修改版本： fn register(u User) User { return { u | is_registered: true } } user = register(user) 常量const const ( PI = 3.14 World = '世界' ) println(PI) println(World) 常量使用const声明。 它们只能在模块级别(函数之外)定义。 常量名称必须大写。这有助于将它们与变量区分开来。 常数永远不会改变。 V常量比大多数语言更灵活。您可以分配更复杂的值 struct Color { r int g int b int } fn (c Color) str() string { return '{$c.r, $c.g, $c.b}' } fn rgb(r, g, b int) Color { return Color{r: r, g: g, b: b} } const ( Numbers = [1, 2, 3] Red = Color{r: 255, g: 0, b: 0} Blue = rgb(0, 0, 255) ) println(Numbers) println(Red) println(Blue) 不允许使用全局变量，因此这非常有用。 模块化 V是一种非常模块化的语言。鼓励创建可重用模块，而且非常简单。要创建一个新模块，请创建一个目录，其中包含模块的名称和.v文件 cd ~/code/modules mkdir mymodule vim mymodule/mymodule.v // mymodule.v module mymodule // To export a function we have to use `pub` pub fn say_hi() { println('hello from mymodule!') } 你可以在mymodule /中拥有尽可能多的.v文件。 使用v -lib~ / code / modules / mymodule构建它。 就是这样，您现在可以在代码中使用它 module main import mymodule fn main() { mymodule.say_hi() } 注意，每次调用外部函数时都必须指定模块。 模块名称应该简短，不超过10个字符。 不允许循环导入。 您可以在任何地方创建模块。 所有模块都被静态地编译成一个可执行文件。 看了两个小时了，还没看完，以我的智商，算是告别代码界了，再见各位，我自闭了","categories":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}],"tags":[{"name":"V语言","slug":"v语言","permalink":"https://vlanguage.cn/tags/v语言/"}],"keywords":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}]},{"title":"V 语言强势登顶 GitHub TOP1，欲取 Go 而代之？","slug":"csdnsevenn_93679131","date":"2019-06-25T00:00:00.000Z","updated":"2019-07-22T05:05:28.351Z","comments":true,"path":"2019/06/25/csdnsevenn_93679131.html","link":"","permalink":"https://vlanguage.cn/2019/06/25/csdnsevenn_93679131.html","excerpt":"","text":"这个结合了 Go 和 Rust 特性的新语言 V，正式发布了首个可用版本。 整理 | 郭芮 出品 | CSDN（ID：CSDNnews） 长久以来，编程语言在语法、语义和标准库等方面都存在着千差万别，使得程序员在选择时不得不面临着差异化等难题。自然选择下，就会有旧语言的淘汰（PHP 是个意外，至今还存在）和新语言的诞生。在&nbsp;JetBrains 最新发布的《2019 开发人员生态系统现状》报告中，Java、Python、C/C#、JavaScript 等主流的编程语言在历经实践考验后依然是开发者们的心头好。 太嚣张了会Python的人!找工作拿高薪这么简单？ https://edu.csdn.net/topic/python115?utm_source=cxrs_bw 而本文的主角 V 语言，在千呼万唤之后，终于于近日开源了，并正式发布了首个可用版本（预构建的二进制文件也即将推出）！其一经发布，便强势登顶&nbsp;GitHub TOP1，引来开发者们的热议围观。 &nbsp; （https://github.com/vlang/v/releases/tag/v0.0.12） &nbsp; 根据介绍，V 是一种新型的静态编译型语言，可以“快速编译、安全且和 C/C++ 转换”，其提供了方便、快捷、安全的编程语言和工具包，还能够很好地服务于区块链技术。 &nbsp; &nbsp; V 语言作者 Reishi Saza 就表示，它是一种非常简单的语言，看官方文档 30 分钟就能完全掌握。而且，其编译器只有 400KB，无任何第三方依赖。 &nbsp; （作者展示的应用示例：V 语言建立的 macOS Demo） &nbsp; V 的核心 CPU 每秒可以编译大约 120 万行代码，这种速度是通过生成的机器代码和强大的模块化来实现的，但是目前仅支持 x64/Mach-O，预计到今年年底才能足够稳定。而在性能表现上，V 可以做到和 C 一样快，且能够翻译整个 C 或 C++ 项目，实现高达 400x 的编译速度。 &nbsp; &nbsp; std::vector&lt;std::string&gt;&nbsp;s;s.push_back(\"V&nbsp;is&nbsp;\");s.push_back(\"awesome\");std::cout&nbsp;&lt;&lt;&nbsp;s.size();mut&nbsp;s&nbsp;:=&nbsp;[]s&nbsp;&lt;&lt;&nbsp;'V&nbsp;is&nbsp;'s&nbsp;&lt;&lt;&nbsp;'awesome'println(s.len) s.push_back(\"V&nbsp;is&nbsp;\"); s.push_back(\"awesome\"); std::cout&nbsp;&lt;&lt;&nbsp;s.size(); mut&nbsp;s&nbsp;:=&nbsp;[] s&nbsp;&lt;&lt;&nbsp;'V&nbsp;is&nbsp;' s&nbsp;&lt;&lt;&nbsp;'awesome' println(s.len) &nbsp; 目前，整个 V 语言及其标准库小于 400 KB，开发者在 0.4 秒内就可以构建它。并且到今年年底，这个数字还将下降到大约 0.15 秒。 &nbsp; 此外，开发者们还在官网上放出了部分示例代码。更多编译器函数介绍可参见官方网站：https://vlang.io/。 &nbsp; 1、数据库访问： &nbsp; &nbsp; struct&nbsp;User&nbsp;{&nbsp;/*&nbsp;...&nbsp;*/&nbsp;}struct&nbsp;Post&nbsp;{&nbsp;/*&nbsp;...&nbsp;*/&nbsp;}struct&nbsp;DB&nbsp;&nbsp;&nbsp;{&nbsp;/*&nbsp;...&nbsp;*/&nbsp;}struct&nbsp;Repo&nbsp;&lt;T&gt;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;db&nbsp;DB}fn&nbsp;new_repo&lt;T&gt;(db&nbsp;DB)&nbsp;Repo&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Repo&lt;T&gt;{db:&nbsp;db}}fn&nbsp;(r&nbsp;Repo)&nbsp;find_by_id(id&nbsp;int)&nbsp;T?&nbsp;{&nbsp;//&nbsp;`?`&nbsp;means&nbsp;the&nbsp;function&nbsp;returns&nbsp;an&nbsp;optional&nbsp;&nbsp;&nbsp;&nbsp;table_name&nbsp;:=&nbsp;T.name&nbsp;//&nbsp;in&nbsp;this&nbsp;example&nbsp;getting&nbsp;the&nbsp;name&nbsp;of&nbsp;the&nbsp;type&nbsp;gives&nbsp;us&nbsp;the&nbsp;table&nbsp;name&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;r.db.query_one&lt;T&gt;('select&nbsp;*&nbsp;from&nbsp;$table_name&nbsp;where&nbsp;id&nbsp;=&nbsp;?',&nbsp;id)}fn&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;db&nbsp;:=&nbsp;new_db()&nbsp;&nbsp;&nbsp;&nbsp;users_repo&nbsp;:=&nbsp;new_repo&lt;User&gt;(db)&nbsp;&nbsp;&nbsp;&nbsp;posts_repo&nbsp;:=&nbsp;new_repo&lt;Post&gt;(db)&nbsp;&nbsp;&nbsp;&nbsp;user&nbsp;:=&nbsp;users_repo.find_by_id(1)&nbsp;or&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eprintln('User&nbsp;not&nbsp;found')&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;post&nbsp;:=&nbsp;posts_repo.find_by_id(1)&nbsp;or&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eprintln('Post&nbsp;not&nbsp;found')&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;}}&nbsp;/*&nbsp;...&nbsp;*/&nbsp;} struct&nbsp;Post&nbsp;{&nbsp;/*&nbsp;...&nbsp;*/&nbsp;} struct&nbsp;DB&nbsp;&nbsp;&nbsp;{&nbsp;/*&nbsp;...&nbsp;*/&nbsp;} struct&nbsp;Repo&nbsp;&lt;T&gt;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;db&nbsp;DB } fn&nbsp;new_repo&lt;T&gt;(db&nbsp;DB)&nbsp;Repo&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Repo&lt;T&gt;{db:&nbsp;db} } fn&nbsp;(r&nbsp;Repo)&nbsp;find_by_id(id&nbsp;int)&nbsp;T?&nbsp;{&nbsp;//&nbsp;`?`&nbsp;means&nbsp;the&nbsp;function&nbsp;returns&nbsp;an&nbsp;optional &nbsp;&nbsp;&nbsp;&nbsp;table_name&nbsp;:=&nbsp;T.name&nbsp;//&nbsp;in&nbsp;this&nbsp;example&nbsp;getting&nbsp;the&nbsp;name&nbsp;of&nbsp;the&nbsp;type&nbsp;gives&nbsp;us&nbsp;the&nbsp;table&nbsp;name &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;r.db.query_one&lt;T&gt;('select&nbsp;*&nbsp;from&nbsp;$table_name&nbsp;where&nbsp;id&nbsp;=&nbsp;?',&nbsp;id) } fn&nbsp;main()&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;db&nbsp;:=&nbsp;new_db() &nbsp;&nbsp;&nbsp;&nbsp;users_repo&nbsp;:=&nbsp;new_repo&lt;User&gt;(db) &nbsp;&nbsp;&nbsp;&nbsp;posts_repo&nbsp;:=&nbsp;new_repo&lt;Post&gt;(db) &nbsp;&nbsp;&nbsp;&nbsp;user&nbsp;:=&nbsp;users_repo.find_by_id(1)&nbsp;or&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eprintln('User&nbsp;not&nbsp;found') &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;post&nbsp;:=&nbsp;posts_repo.find_by_id(1)&nbsp;or&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eprintln('Post&nbsp;not&nbsp;found') &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return &nbsp;&nbsp;&nbsp;&nbsp;} }&nbsp; &nbsp; 2、网络开发： &nbsp; &nbsp; struct&nbsp;Story&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;title&nbsp;string}//&nbsp;Fetches&nbsp;top&nbsp;HN&nbsp;stories&nbsp;in&nbsp;8&nbsp;coroutines&nbsp;fn&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;resp&nbsp;:=&nbsp;http.get('https://hacker-news.firebaseio.com/v0/topstories.json')?&nbsp;&nbsp;&nbsp;&nbsp;ids&nbsp;:=&nbsp;json.decode([]int,&nbsp;resp.body)?&nbsp;&nbsp;&nbsp;&nbsp;mut&nbsp;cursor&nbsp;:=&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;_&nbsp;in&nbsp;0..8&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;go&nbsp;fn()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;{&nbsp;//&nbsp;Without&nbsp;this&nbsp;lock&nbsp;the&nbsp;program&nbsp;will&nbsp;not&nbsp;compile&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;cursor&nbsp;&gt;=&nbsp;ids.len&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id&nbsp;:=&nbsp;ids[cursor]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cursor++&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resp&nbsp;:=&nbsp;http.get('https://hacker-news.firebaseio.com/v0/item/$id.json')?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;story&nbsp;:=&nbsp;json.decode(Story,&nbsp;resp.body)?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(story.title)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}()&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;runtime.wait()&nbsp;//&nbsp;Waits&nbsp;for&nbsp;all&nbsp;coroutines&nbsp;to&nbsp;finish&nbsp;}&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;title&nbsp;string } //&nbsp;Fetches&nbsp;top&nbsp;HN&nbsp;stories&nbsp;in&nbsp;8&nbsp;coroutines&nbsp; fn&nbsp;main()&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;resp&nbsp;:=&nbsp;http.get('https://hacker-news.firebaseio.com/v0/topstories.json')? &nbsp;&nbsp;&nbsp;&nbsp;ids&nbsp;:=&nbsp;json.decode([]int,&nbsp;resp.body)? &nbsp;&nbsp;&nbsp;&nbsp;mut&nbsp;cursor&nbsp;:=&nbsp;0 &nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;_&nbsp;in&nbsp;0..8&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;go&nbsp;fn()&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;{&nbsp;//&nbsp;Without&nbsp;this&nbsp;lock&nbsp;the&nbsp;program&nbsp;will&nbsp;not&nbsp;compile&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;cursor&nbsp;&gt;=&nbsp;ids.len&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id&nbsp;:=&nbsp;ids[cursor] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cursor++ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resp&nbsp;:=&nbsp;http.get('https://hacker-news.firebaseio.com/v0/item/$id.json')?&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;story&nbsp;:=&nbsp;json.decode(Story,&nbsp;resp.body)? &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(story.title) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}() &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;runtime.wait()&nbsp;//&nbsp;Waits&nbsp;for&nbsp;all&nbsp;coroutines&nbsp;to&nbsp;finish&nbsp; }&nbsp; &nbsp; 当然，目前V 语言的开发仍处于早期阶段，很多方面还不够完善，尤其是内存管理上还面临着与 Go 和 Rust 同样繁琐的生命期管理问题，但对比 C++ 等手动和半自动的管理方式还是更省心一些的。 &nbsp; 那么开发者们怎么看？ &nbsp; &nbsp; @三川走刀口：还是要得到开发者认可，但是对于安卓开发好像没用？ &nbsp; @淡定的龙哥：Go语言同父异母的弟弟？ &nbsp; @Heisenber哥：语言特性只是一方面，生态也很重要。 &nbsp; @王的凝视：这个新语言提出来是为了解决什么问题？每种语言都有适合场景，如果没有合适场景迟早也要被淘汰。 &nbsp; @楚小欢：执行效率比C高应该不可能，C现在都被认为是汇编语言，本身语义也十分接近汇编。别的语言只要有高级点的特性，效率就不可能超过C。 &nbsp; 总之，这个新生的 V 语言还是需要不断的发展，得到开发者的广泛应用才能焕发生机，也才能有望助力程序员做到真正的“人剑合一”。 CSDN 5G 沙龙来啦！ 6 月 29 日，微软（中国）首席技术官韦青、北京邮电大学信息与通信工程学院多媒体技术教研中心主任/博士生导师孙松林、金山云 AIoT 事业部高级研发总监肖江、爱立信中国研发部多天线高级专家朱怀松、爱立信中国研发部主任系统工程师刘阳等行业内顶尖的领军者、资深的技术专家们共聚一堂，共同探讨 5G 在物联网中的巨大潜能。 扫描下方二维码，马上预约直播！ &nbsp;热 文&nbsp;推 荐&nbsp; ☞写代码不严谨，我就不配当程序员？ ☞北邮通信博士万字长文，带你秒懂 4G/5G 区别！ ☞程序员是如何脱单的？| 程序员有话说 ☞5G 时代，微软又走对了一步棋！ ☞LinkedIn最新报告: 区块链成职位需求增长最快领域, 这些地区对区块链人才渴求度最高…… ☞碾压Bert？“屠榜”的XLnet对NLP任务意味着什么 ☞吐血总结！100个Python面试问题集锦（上） ☞2019年技术盘点容器篇（一）：听UCloud谈风生水起的K8S | 程序员硬核评测 ☞17 岁的程序员告诉你关于编程的 7 个重要教训！ ☞“是！互联网从此没有 BAT！” 点击阅读原文，预约直播。 你点的每个“在看”，我都认真当成了喜欢","categories":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}],"tags":[{"name":"V语言","slug":"v语言","permalink":"https://vlanguage.cn/tags/v语言/"}],"keywords":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}]},{"title":"最详细的v语言(vlang)的编译器的安装与运行！","slug":"qq_40815295_93662653","date":"2019-06-25T00:00:00.000Z","updated":"2019-07-22T05:05:29.689Z","comments":true,"path":"2019/06/25/qq_40815295_93662653.html","link":"","permalink":"https://vlanguage.cn/2019/06/25/qq_40815295_93662653.html","excerpt":"","text":"​在这里给有兴趣的人提供最详细的安装过程。 其间过程是艰难的，体验是痛苦的。 &nbsp; 相信大多数人在安装新语言的ide和环境配置的过程中都会遇到的各种各样的坑，一踩就拔不出来了。如下我们开始安装过程。 &nbsp; 再提一句目前window下暂时无法进行v语言的编译，我也没有mac进行编译。所以这里我使用的是虚拟机+Linux进行的编译。等window下能编译后通知各位。 &nbsp; 虚拟机使用的是VMware15 ，Linux使用的Ubuntu。 详细的虚拟机安装教程： https://mp.weixin.qq.com/s/28fb8SQgUz2lcHSCCk_UBg 详细的Ubuntu安装教程： https://mp.weixin.qq.com/s/ti_E6lAiljmVYM4_9TUKwg 其间还需要进行联网，我这网络环境和你们有些不同，联网问题就自行百度吧。 相信很多朋友早就有了以上环境。下面开始我们的正题。 首先进入终端， # You can clone V anywhere git clone https://github.com/vlang/v cd v/compiler make # Or build without make: wget https://vlang.io/v.c # Download the V compiler's source translated to C cc -std=gnu11 -w -o vc v.c # Build it with Clang or GCC ./vc -o v . &amp;&amp; rm vc # Use the resulting V binary to build V from V source, delete the old compiler ./v -o v . # Bootstrap the compiler to make sure it works 然后按命令一行一行的输入，如果是新入Linux的话第一行就出现了问题。 需要安装git！ 输入 sudo apt install git 好了接下来继续，其间会需要你安装各种包，按上面的提示进行安装，然后再进行以上命令，全部命令结束后&nbsp;。 创建环境， sudo ln -s ~/code/v/compiler/v /usr/local/bin/v 开始进行测试，命令行打入，v 如果能进入编译器，那么恭喜你，成功了。 这里有个大坑，不懂什么原因我的ubuntu并没有code这个路径，这里环境变量就需要改下 sudo ln -sf ~/v/compiler/v&nbsp; /usr/local/bin/v 使用以上命令。 $ v V 0.0.12 Use Ctrl-D to exit &gt;&gt;&gt; println('hello world') hello world &gt;&gt;&gt; 如果你也是这样，那么恭喜你。如果还有什么问题可以留言和我探讨下。如果能帮助到你，我很荣幸。 让苍天知道我不认输.jpg(脑补哈哈） 欢迎关注本公众号，持续更新分享vlang知识！谢谢。 欢迎加我好友进行交流。 &nbsp; 官方教程：https://github.com/vlang/v","categories":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}],"tags":[{"name":"V语言","slug":"v语言","permalink":"https://vlanguage.cn/tags/v语言/"}],"keywords":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}]},{"title":"V 语言强势登顶 GitHub TOP1，欲取 Go 而代之？","slug":"csdnnews_93550448","date":"2019-06-24T00:00:00.000Z","updated":"2019-07-22T05:05:27.980Z","comments":true,"path":"2019/06/24/csdnnews_93550448.html","link":"","permalink":"https://vlanguage.cn/2019/06/24/csdnnews_93550448.html","excerpt":"","text":"这个结合了 Go 和 Rust 特性的新语言 V，正式发布了首个可用版本。 整理 | 郭芮 出品 | CSDN（ID：CSDNnews） 长久以来，编程语言在语法、语义和标准库等方面都存在着千差万别，使得程序员在选择时不得不面临着差异化等难题。自然选择下，就会有旧语言的淘汰（PHP 是个意外，至今还存在）和新语言的诞生。在&nbsp;JetBrains 最新发布的《2019 开发人员生态系统现状》报告中，Java、Python、C/C#、JavaScript 等主流的编程语言在历经实践考验后依然是开发者们的心头好。 &nbsp; 而本文的主角 V 语言，在千呼万唤之后，终于于近日开源了，并正式发布了首个可用版本（预构建的二进制文件也即将推出）！其一经发布，便强势登顶&nbsp;GitHub TOP1，引来开发者们的热议围观。 &nbsp; （https://github.com/vlang/v/releases/tag/v0.0.12） &nbsp; 根据介绍，V 是一种新型的静态编译型语言，可以“快速编译、安全且和 C/C++ 转换”，其提供了方便、快捷、安全的编程语言和工具包，还能够很好地服务于区块链技术。 &nbsp; &nbsp; V 语言作者 Reishi Saza 就表示，它是一种非常简单的语言，看官方文档 30 分钟就能完全掌握。而且，其编译器只有 400KB，无任何第三方依赖。 &nbsp; （作者展示的应用示例：V 语言建立的 macOS Demo） &nbsp; V 的核心 CPU 每秒可以编译大约 120 万行代码，这种速度是通过生成的机器代码和强大的模块化来实现的，但是目前仅支持 x64/Mach-O，预计到今年年底才能足够稳定。而在性能表现上，V 可以做到和 C 一样快，且能够翻译整个 C 或 C++ 项目，实现高达 400x 的编译速度。 &nbsp; &nbsp; std::vector&lt;std::string&gt;&nbsp;s;s.push_back(\"V&nbsp;is&nbsp;\");s.push_back(\"awesome\");std::cout&nbsp;&lt;&lt;&nbsp;s.size();mut&nbsp;s&nbsp;:=&nbsp;[]s&nbsp;&lt;&lt;&nbsp;'V&nbsp;is&nbsp;'s&nbsp;&lt;&lt;&nbsp;'awesome'println(s.len) s.push_back(\"V&nbsp;is&nbsp;\"); s.push_back(\"awesome\"); std::cout&nbsp;&lt;&lt;&nbsp;s.size(); mut&nbsp;s&nbsp;:=&nbsp;[] s&nbsp;&lt;&lt;&nbsp;'V&nbsp;is&nbsp;' s&nbsp;&lt;&lt;&nbsp;'awesome' println(s.len) &nbsp; 目前，整个 V 语言及其标准库小于 400 KB，开发者在 0.4 秒内就可以构建它。并且到今年年底，这个数字还将下降到大约 0.15 秒。 &nbsp; 此外，开发者们还在官网上放出了部分示例代码。更多编译器函数介绍可参见官方网站：https://vlang.io/。 &nbsp; 1、数据库访问： &nbsp; &nbsp; struct&nbsp;User&nbsp;{&nbsp;/*&nbsp;...&nbsp;*/&nbsp;}struct&nbsp;Post&nbsp;{&nbsp;/*&nbsp;...&nbsp;*/&nbsp;}struct&nbsp;DB&nbsp;&nbsp;&nbsp;{&nbsp;/*&nbsp;...&nbsp;*/&nbsp;}struct&nbsp;Repo&nbsp;&lt;T&gt;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;db&nbsp;DB}fn&nbsp;new_repo&lt;T&gt;(db&nbsp;DB)&nbsp;Repo&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Repo&lt;T&gt;{db:&nbsp;db}}fn&nbsp;(r&nbsp;Repo)&nbsp;find_by_id(id&nbsp;int)&nbsp;T?&nbsp;{&nbsp;//&nbsp;`?`&nbsp;means&nbsp;the&nbsp;function&nbsp;returns&nbsp;an&nbsp;optional&nbsp;&nbsp;&nbsp;&nbsp;table_name&nbsp;:=&nbsp;T.name&nbsp;//&nbsp;in&nbsp;this&nbsp;example&nbsp;getting&nbsp;the&nbsp;name&nbsp;of&nbsp;the&nbsp;type&nbsp;gives&nbsp;us&nbsp;the&nbsp;table&nbsp;name&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;r.db.query_one&lt;T&gt;('select&nbsp;*&nbsp;from&nbsp;$table_name&nbsp;where&nbsp;id&nbsp;=&nbsp;?',&nbsp;id)}fn&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;db&nbsp;:=&nbsp;new_db()&nbsp;&nbsp;&nbsp;&nbsp;users_repo&nbsp;:=&nbsp;new_repo&lt;User&gt;(db)&nbsp;&nbsp;&nbsp;&nbsp;posts_repo&nbsp;:=&nbsp;new_repo&lt;Post&gt;(db)&nbsp;&nbsp;&nbsp;&nbsp;user&nbsp;:=&nbsp;users_repo.find_by_id(1)&nbsp;or&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eprintln('User&nbsp;not&nbsp;found')&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;post&nbsp;:=&nbsp;posts_repo.find_by_id(1)&nbsp;or&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eprintln('Post&nbsp;not&nbsp;found')&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;}}&nbsp;/*&nbsp;...&nbsp;*/&nbsp;} struct&nbsp;Post&nbsp;{&nbsp;/*&nbsp;...&nbsp;*/&nbsp;} struct&nbsp;DB&nbsp;&nbsp;&nbsp;{&nbsp;/*&nbsp;...&nbsp;*/&nbsp;} struct&nbsp;Repo&nbsp;&lt;T&gt;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;db&nbsp;DB } fn&nbsp;new_repo&lt;T&gt;(db&nbsp;DB)&nbsp;Repo&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Repo&lt;T&gt;{db:&nbsp;db} } fn&nbsp;(r&nbsp;Repo)&nbsp;find_by_id(id&nbsp;int)&nbsp;T?&nbsp;{&nbsp;//&nbsp;`?`&nbsp;means&nbsp;the&nbsp;function&nbsp;returns&nbsp;an&nbsp;optional &nbsp;&nbsp;&nbsp;&nbsp;table_name&nbsp;:=&nbsp;T.name&nbsp;//&nbsp;in&nbsp;this&nbsp;example&nbsp;getting&nbsp;the&nbsp;name&nbsp;of&nbsp;the&nbsp;type&nbsp;gives&nbsp;us&nbsp;the&nbsp;table&nbsp;name &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;r.db.query_one&lt;T&gt;('select&nbsp;*&nbsp;from&nbsp;$table_name&nbsp;where&nbsp;id&nbsp;=&nbsp;?',&nbsp;id) } fn&nbsp;main()&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;db&nbsp;:=&nbsp;new_db() &nbsp;&nbsp;&nbsp;&nbsp;users_repo&nbsp;:=&nbsp;new_repo&lt;User&gt;(db) &nbsp;&nbsp;&nbsp;&nbsp;posts_repo&nbsp;:=&nbsp;new_repo&lt;Post&gt;(db) &nbsp;&nbsp;&nbsp;&nbsp;user&nbsp;:=&nbsp;users_repo.find_by_id(1)&nbsp;or&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eprintln('User&nbsp;not&nbsp;found') &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;post&nbsp;:=&nbsp;posts_repo.find_by_id(1)&nbsp;or&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eprintln('Post&nbsp;not&nbsp;found') &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return &nbsp;&nbsp;&nbsp;&nbsp;} }&nbsp; &nbsp; 2、网络开发： &nbsp; &nbsp; struct&nbsp;Story&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;title&nbsp;string}//&nbsp;Fetches&nbsp;top&nbsp;HN&nbsp;stories&nbsp;in&nbsp;8&nbsp;coroutines&nbsp;fn&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;resp&nbsp;:=&nbsp;http.get('https://hacker-news.firebaseio.com/v0/topstories.json')?&nbsp;&nbsp;&nbsp;&nbsp;ids&nbsp;:=&nbsp;json.decode([]int,&nbsp;resp.body)?&nbsp;&nbsp;&nbsp;&nbsp;mut&nbsp;cursor&nbsp;:=&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;_&nbsp;in&nbsp;0..8&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;go&nbsp;fn()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;{&nbsp;//&nbsp;Without&nbsp;this&nbsp;lock&nbsp;the&nbsp;program&nbsp;will&nbsp;not&nbsp;compile&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;cursor&nbsp;&gt;=&nbsp;ids.len&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id&nbsp;:=&nbsp;ids[cursor]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cursor++&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resp&nbsp;:=&nbsp;http.get('https://hacker-news.firebaseio.com/v0/item/$id.json')?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;story&nbsp;:=&nbsp;json.decode(Story,&nbsp;resp.body)?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(story.title)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}()&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;runtime.wait()&nbsp;//&nbsp;Waits&nbsp;for&nbsp;all&nbsp;coroutines&nbsp;to&nbsp;finish&nbsp;}&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;title&nbsp;string } //&nbsp;Fetches&nbsp;top&nbsp;HN&nbsp;stories&nbsp;in&nbsp;8&nbsp;coroutines&nbsp; fn&nbsp;main()&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;resp&nbsp;:=&nbsp;http.get('https://hacker-news.firebaseio.com/v0/topstories.json')? &nbsp;&nbsp;&nbsp;&nbsp;ids&nbsp;:=&nbsp;json.decode([]int,&nbsp;resp.body)? &nbsp;&nbsp;&nbsp;&nbsp;mut&nbsp;cursor&nbsp;:=&nbsp;0 &nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;_&nbsp;in&nbsp;0..8&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;go&nbsp;fn()&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;{&nbsp;//&nbsp;Without&nbsp;this&nbsp;lock&nbsp;the&nbsp;program&nbsp;will&nbsp;not&nbsp;compile&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;cursor&nbsp;&gt;=&nbsp;ids.len&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id&nbsp;:=&nbsp;ids[cursor] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cursor++ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resp&nbsp;:=&nbsp;http.get('https://hacker-news.firebaseio.com/v0/item/$id.json')?&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;story&nbsp;:=&nbsp;json.decode(Story,&nbsp;resp.body)? &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(story.title) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}() &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;runtime.wait()&nbsp;//&nbsp;Waits&nbsp;for&nbsp;all&nbsp;coroutines&nbsp;to&nbsp;finish&nbsp; }&nbsp; &nbsp; 当然，目前V 语言的开发仍处于早期阶段，很多方面还不够完善，尤其是内存管理上还面临着与 Go 和 Rust 同样繁琐的生命期管理问题，但对比 C++ 等手动和半自动的管理方式还是更省心一些的。 &nbsp; 那么开发者们怎么看？ &nbsp; &nbsp; @三川走刀口：还是要得到开发者认可，但是对于安卓开发好像没用？ &nbsp; @淡定的龙哥：Go语言同父异母的弟弟？ &nbsp; @Heisenber哥：语言特性只是一方面，生态也很重要。 &nbsp; @王的凝视：这个新语言提出来是为了解决什么问题？每种语言都有适合场景，如果没有合适场景迟早也要被淘汰。 &nbsp; @楚小欢：执行效率比C高应该不可能，C现在都被认为是汇编语言，本身语义也十分接近汇编。别的语言只要有高级点的特性，效率就不可能超过C。 25岁转行人工智能靠谱吗？ https://edu.csdn.net/topic/ai30?utm_source=csdn_bw 总之，这个新生的 V 语言还是需要不断的发展，得到开发者的广泛应用才能焕发生机，也才能有望助力程序员做到真正的“人剑合一”。 【END】 &nbsp;热 文&nbsp;推 荐&nbsp; ☞小程序技术演进史 ☞5G 兴起，物联网安全危机四伏 ☞写代码不严谨，我就不配当程序员？ ☞华为最强自研 NPU 问世，麒麟 810 “抛弃”寒武纪 ☞LinkedIn最新报告: 区块链成职位需求增长最快领域, 这些地区对区块链人才渴求度最高…… ☞中文NLP的分词真有必要吗？李纪为团队四项任务评测一探究竟 | ACL 2019 ☞6月技术福利限时免费领 ☞搞不懂SDN？那是因为你没看这个小故事… ☞她说：程序员离开电脑就是 “废物” ！ 点击阅读原文，输入关键词，搜索CSDN文章。 你点的每个“在看”，我都认真当成了喜欢","categories":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}],"tags":[{"name":"V语言","slug":"v语言","permalink":"https://vlanguage.cn/tags/v语言/"}],"keywords":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}]},{"title":"全新语言-v语言","slug":"itpika_93473857","date":"2019-06-24T00:00:00.000Z","updated":"2019-07-22T05:05:28.810Z","comments":true,"path":"2019/06/24/itpika_93473857.html","link":"","permalink":"https://vlanguage.cn/2019/06/24/itpika_93473857.html","excerpt":"","text":"2019/6/23，v语言的首个可用0.0.12版本发布了。这是一名全新的语言，集合了go的简单和rust的安全的特性；用于开发可维护软件的简单、快速、安全的编译语言。不过它的整体风格和go类似，代码风格简单，熟悉的go的朋友可以很快上手。不过刚发布，还需要很长一段时间的温养。 官方地址：https://vlang.io github地址：https://github.com/vlang/v&nbsp;(安装方法github首页有详细说明) 中文网已经出来了：https://www.v-lang.cn/ 简单说一下V的特性： 快速编译 &nbsp;&nbsp;V每CPU核心每秒编译约120万行代码。 &nbsp;&nbsp;V也可以调用C，编译速度下降到≈100k行/秒/CPU。 安全 &nbsp;&nbsp;没有空 &nbsp;&nbsp;没有全局变量(意味着变量都是在函数体中声明) &nbsp;&nbsp;没有未定义的行为 &nbsp;&nbsp;没有变量跟踪 &nbsp;&nbsp;边界检查 可选的结果类型 支持泛型 默认不可变的变量 默认纯函数 默认不可变的结构体 性能： 和C一样快 操作C没有任何成本 没有运行时反射的内置序列化 最少量的分配 可以编译程序到没有任何依赖关系的本地二进制文件:一个简单的web服务器只有65 KB 用于构建可维护程序的简单语 您可以在半小时内浏览文档来学习整个语言。(目前提供的标准库还不多，毕竟刚发布) 尽管很简单，但是它为开发人员提供了很多功能。任何你能用其他语言做的事情，你都可以用V来做。(这句话，貌似每个语言都会这么讲....) &nbsp; 400kb编译器，零在制品依赖 整个语言及其标准库都小于400kb。V是用V写的，你可以在0。4秒内完成。(到今年年底，这个数字将降至≈0.15秒。) 热代码重载 立即获得更改，而无需重新编译。 由于您也不必在每次编译之后都进入正在处理的状态，这可以节省大量宝贵的开发时间。 &nbsp; 强大的图形库 构建在GDI+/Cocoa绘图之上的跨平台绘图库，以及一个基于OpenGL的图形库，用于更复杂的2D/3D应用程序，它还具有以下特性: 加载复杂的三维对象与纹理在制品 摄像头(移动，环顾四周)wip 骨骼动画在制品 计划使用DirectX、Vulkan和Metal支持。（图形库的一个简单例子是tetris.v（就是俄罗斯方块） 本机跨平台GUI库 容易交叉编译 交叉编译您的软件只需运行v -os windows。或者v -os linux。不需要额外的步骤，即使是GUI和图形应用程序!(目前只在macOS上编译macOS软件。) 无痛部署和依赖关系管理 大致特性就是这些，不过等这些功能完善，还是需要不少时间，这些特性也可以说是V以后的目标。 V语言还比较新，目前稍微关注一下，功能完善和生态发展等都还需要时间 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;","categories":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}],"tags":[{"name":"V语言","slug":"v语言","permalink":"https://vlanguage.cn/tags/v语言/"}],"keywords":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}]},{"title":"vlang,v语言","slug":"wyyyh9458_93377612","date":"2019-06-23T00:00:00.000Z","updated":"2019-07-22T04:55:19.545Z","comments":true,"path":"2019/06/23/wyyyh9458_93377612.html","link":"","permalink":"https://vlanguage.cn/2019/06/23/wyyyh9458_93377612.html","excerpt":"","text":"AD: http://a.scwy.net/ 无意中看到．https://vlang.io/，还有网友很积极的来了个中文网 https://www.v-lang.cn/ 安装： mkdir -p ~/code &amp;&amp; cd ~/code # ~/code directory has to be used (it's a temporary limitation) git clone https://github.com/vlang/v cd v/compiler wget https://vlang.io/v.c # Download the V compiler's source translated to C cc -w -o vc v.c # Build it with Clang or GCC ./vc -o v . # Use the resulting V binary to build V from V source 文档：https://vlang.io/docs 学起来还是满快，类golang．代码够简，只是这个库太少，生态不够．发展尚需时日． 特点据说是：编(译)得快，安全，高性能，编译器小(400kb)，０依赖，翻译为C语言，代码热载，强大图形库，通用图形界面库，交叉编译． 当我重新再次编译的时候出现：段错误 (核心已转储)．它在用户目录建立了.vlang0.0.12,删除它，依然不行..... 看来必须用code目录，这个有点搞笑了....重编译好后，将v目录移到其它目录，它将出现库不存在等问题（依然在找code目录) 删之，表示稍微关注. -------------------------------------------------------------------------------------------------- 就统计看到的访问数据，还有比较多人（浏览器？）来关注这个v．路漫漫...不过还是多鼓励，少放气．优点还是有的，假以时日或许也会有一定使用者．生态很重要． 这里还有网友的评论：V 语言强势登顶 GitHub TOP1，欲取 Go 而代之 －＞https://blog.csdn.net/csdnnews/article/details/93550448 &nbsp; ---------------------------------------------------------------------------------------------------- https://vlang.ide.judge0.com/&nbsp; 在线编辑运行","categories":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}],"tags":[{"name":"V语言","slug":"v语言","permalink":"https://vlanguage.cn/tags/v语言/"}],"keywords":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}]},{"title":"V语言正式开源","slug":"chai2010_93377522","date":"2019-06-22T00:00:00.000Z","updated":"2019-07-22T04:55:18.833Z","comments":true,"path":"2019/06/22/chai2010_93377522.html","link":"","permalink":"https://vlanguage.cn/2019/06/22/chai2010_93377522.html","excerpt":"","text":"V语言今天正式，欢迎访问V语言中文网：https://vlang-zh.cn/ Hello, world 在线运行：https://vlang.io/play fn&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;areas&nbsp;:=&nbsp;['game',&nbsp;'web',&nbsp;'tools',&nbsp;'science',&nbsp;'systems',&nbsp;'GUI',&nbsp;'mobile']&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;area&nbsp;in&nbsp;areas&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println('Hello,&nbsp;$area&nbsp;developers!')&nbsp;&nbsp;&nbsp;&nbsp;}}&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;area&nbsp;in&nbsp;areas&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println('Hello,&nbsp;$area&nbsp;developers!')&nbsp;&nbsp;&nbsp;&nbsp;}} 扫码加入V语言微信群 注：如果二维码过期，可以通过“光谷码农”微信公众号底部菜单扫码进入。 开发状态 V语言还处于非常早期的开发阶段。很多特性都标记为开发中状态（WIP，work in progress）。不过此页面相关的内容和代码都会在2019年6月22号开源。如果所有的WIP开发工作都完成，那么将是发布V1.0的时候。 V语言的特色 快速编译 在Intel i5-7500 @ 3.40GHz, SM0256L SSD没有优化的环境，每秒钟可以编译120万行V代码。这是通过模块化和直接输出机器码来实现快速编译的。 V语言编译器也可以直接输出C语言代码，但是输出的性能将下降到10行每秒钟。 注：直接输出机器码还处于非常早期的阶段，目前只支持X64环境的Mach-O格式的目标文件。因此目前必须先输出C代码再进行编译。 安全 性能 用于构建可维护程序的简洁语言 你可以在半个小说读完全部的自带文档。虽然简洁，但是不简单！你可以用V语言做任何其它语言可以做的事情！ 编译器400KB，零依赖 语言的标准库小雨400KB。V语言已经自举，用V语言编写，可以在0.4秒内构建（到今年地，时间继续降到0.15秒）。 时间对比： 语言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内存大小&nbsp;&nbsp;&nbsp;&nbsp;编译时间Go&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;525&nbsp;MB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1m&nbsp;33sRust&nbsp;&nbsp;&nbsp;&nbsp;30&nbsp;GB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;45mGCC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;GB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;50mClang&nbsp;&nbsp;&nbsp;90&nbsp;GB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;25mSwift&nbsp;&nbsp;&nbsp;70&nbsp;GB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;90mV&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.4&nbsp;MB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.4sGo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;525&nbsp;MB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1m&nbsp;33sRust&nbsp;&nbsp;&nbsp;&nbsp;30&nbsp;GB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;45mGCC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;GB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;50mClang&nbsp;&nbsp;&nbsp;90&nbsp;GB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;25mSwift&nbsp;&nbsp;&nbsp;70&nbsp;GB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;90mV&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.4&nbsp;MB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.4s 目前V语言只依赖C语言编译器，用于启动。一旦语言完备，就可以不再需要C语言编译器。 先在0.4秒内构建V，然后使用生成的编译器再次构建自己： C/C++代码到V代码 V可以翻译整个C/C++代码到V代码，以享受带来的安全性、简单性和高达400x的编译速度。 比如C++代码： std::vector&lt;std::string&gt;&nbsp;s;s.push_back(\"V&nbsp;is&nbsp;\");s.push_back(\"awesome\");std::cout&nbsp;&lt;&lt;&nbsp;s.size();vector&lt;std::string&gt;&nbsp;s;s.push_back(\"V&nbsp;is&nbsp;\");s.push_back(\"awesome\");std::cout&nbsp;&lt;&lt;&nbsp;s.size(); 将翻译为以下V代码： mut&nbsp;s&nbsp;:=&nbsp;[]s&nbsp;&lt;&lt;&nbsp;'V&nbsp;is&nbsp;'s&nbsp;&lt;&lt;&nbsp;'awesome'println(s.len)s&nbsp;&lt;&lt;&nbsp;'awesome'println(s.len) 关于翻译DOOM的博客文章即将发布。 翻译几乎支持全部的C语言标准，但是对C++对支持还处于早期阶段。上面是简单的例子，复杂的C++代码可能有困难。C++是一个比较复杂的语言，我们希望今年年底能完成这个工作。 更多的信息请访问V语言中文网：https://vlang-zh.cn/","categories":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}],"tags":[{"name":"V语言","slug":"v语言","permalink":"https://vlanguage.cn/tags/v语言/"}],"keywords":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}]},{"title":"atitit 编程语言课程 v1 t55.docx 1. 编程语言概念（what 5 1.1. 自然语言与编程语言的关系 5 1.2. 开发中常用的编程语言 5 1.3. 编程语言代际 5 1.4","slug":"attilax_90416843","date":"2019-05-21T00:00:00.000Z","updated":"2019-07-22T05:05:27.127Z","comments":true,"path":"2019/05/21/attilax_90416843.html","link":"","permalink":"https://vlanguage.cn/2019/05/21/attilax_90416843.html","excerpt":"","text":"atitit 编程语言课程 v1 t55.docx &nbsp; &nbsp; 1. 编程语言概念（what 5 1.1. 自然语言与编程语言的关系 5 1.2. 开发中常用的编程语言 5 1.3. 编程语言代际 5 1.4. 编程语言能力模型金字塔 6 2. 学习编程语言的用途 7 2.1. 词法分析，语法分析 语义分析 7 2.2. 数据挖掘提取抽取 7 2.3. 大力提升可读 提升开法效率 7 2.4. other 7 3. 怎么（how）去了解一门编程语言 7 3.1. 语法角度 7 3.2. 运行时环境vm runtime角度 7 3.3. 核心类库标准库角度 7 3.4. 外部库 7 4. 编程语言种类 7 4.1. 命令式语言（特点是一条条语句 7 4.2. 函数式语言.（sql 8 4.3. 声明式语言（h5 xml css等 8 4.4. 逻辑式语言,,不必考虑实现过程而只需考虑定义和结果 8 4.5. 标签式语言（h5 xml 8 4.6. 通用语言与dsl 8 4.7. 全功能语言与弱功能表达式语言 8 5. 编程语言常见内部构成与概念 9 5.1. 基础语法&nbsp;标识符与保留字 9 5.2. 注释&nbsp;与 运算符 9 5.3. 变量6属性 三大流程 10 5.4. 异常控制流程 10 5.5. 表达式（中缀前缀表达式 10 5.6. 运算符 10 5.7. 数据类型 10 5.8. 函数 and 返回值 10 5.9. 5.13.循环(loop), 5.14. 递归(recursion), 5.15.遍历(traversal), 5.16.迭代(iterate). 11 5.10. 泛型 11 5.11. 类型系统（强类型 &nbsp;弱类型 11 6. 编译 11 6.1. 词法分析 语法分析 语义分析 11 6.2. Ast语法树 11 6.3. 预编译头机制&nbsp;&nbsp;import模式 11 6.4. 前端编译 11 6.5. JIT 后端编译/即时(JIT)编译 12 6.6. 静态提前编译（Ahead Of Time，AOT编译） 12 6.7. 增量编译&nbsp;vs 全量编译 13 6.8. 编译模式 忽略模式 恢复模式 vs停止模式 13 6.9. 编译api 14 6.10. 动态执行java文件源码 14 7. 一些原则理论 14 8. 语言实现 14 9. 类与对象实现 章节 15 9.1. class模板 15 9.2. dock type 15 9.3. 动态对象 15 9.4. 对象持久性（object persistence 15 10. 内部数据结构章节 16 10.1. Map &nbsp;字典(Dictionary) 16 10.2. List &nbsp;&nbsp;Set 自定义对象 16 10.3. Sql语言常用的表结构，行，字段 16 11. 函数式 章节 16 12. dsl 章节 17 13. 核心类库 语言标准库 18 13.1. 数学函数&nbsp;&nbsp;字符串 时间日期 18 13.2. Io（显示器 文件等 18 13.3. 基本数据结构Collect集合等 18 13.4. 表达式支持&nbsp;正则表达式 18 13.5. 注解反射等元数据api &nbsp;Anno reflect 18 14. 运行环境高级功能 18 14.1. 并发与锁机制 章节 18 14.2. api设计 章节 19 14.3. gc资源释放 章节 19 14.4. 调试技术 章节 20 14.5. 反射 章节 20 14.6. 动态类加载 20 14.7. 异常处理 章节 20 14.8. 事件机制 章节 21 15. 常见类库api=---------------- 21 15.1. 标准库 章节 21 15.2. io输入输出 章节 21 15.3. 重构 章节&nbsp;章节 22 15.4. 开发规范 章节 22 15.5. 序列化 章节 22 16. ioc 章节 22 17. 性能提升 章节 22 18. gui 章节 22 19. other 章节 23 20. mvc 章节 23 21. ide 章节 23 22. exop互操作接口 章节 23 22.1. 源码组织管理 章节 23 23. 常用协议 章节 23 24. 常用web服务器 章节 23 25. 代码管理与同步 章节 23 26. 安全与加密 章节 23 27. 架构知识 章节 24 28. 文字处理 章节 25 28.1. 汉字处理 25 28.2. 正则表达式 25 28.3. auth 25 28.4. 全文检索 25 28.5. tie树 25 28.6. 规则查询 25 28.7. 参见图像处理知识图谱 25 29. 图像处理 章节 25 30. uml 章节 26 31. web体系 章节 26 32. 简单的图像处理 章节 26 33. vm 章节 26 34. 字符编码 章节 26 35. bug管理 章节 26 36. api标准化 章节 27 37. 常用算法 章节 27 38. 软件工程 章节 27 39. 设计模式 章节 27 40. 标准化 章节 27 40.1. 40.1.ecma标准&nbsp;&nbsp;40.2.iso标准&nbsp;40.3.apache fund 28 40.2. 40.4.jcp jsr&nbsp;40.5.gbk&nbsp;40.6.rfc&nbsp;40.7.w3c 28 40.3. 40.8.ansi&nbsp;40.9.omg 28 40.4. BCP，即Best Current Practice 28 41. 语言高级机制------------------ 28 41.1. event对象 &nbsp;事件机制 28 41.2. xml序列化 29 41.3. php hash序列化 29 41.4. json序列化 29 41.5. 二进制序列化 29 41.6. 循环引用解决 29 41.7. base64 29 41.8. bin2txt 29 42. 编程原则准则 章节 30 42.1. S.O.L.I.D原则(oo fp) 3 30 42.2. 3.1. Single Responsibility Principle (SRP)–职责单一原则 3 30 42.3. 3.2. Open/Closed Principle (OCP)–开闭原则 3 30 42.4. 3.3. Liskov substitution principle (LSP)–里氏代换原则 3 30 42.5. 3.4. Interface Segregation Principle (ISP)–接口隔离原则 3 30 42.6. 3.5. Dependency Inversion Principle(DIP)–依赖倒置原则 3 31 42.7. 4. Dky法则 dry kiss yagni 3 31 42.8. 5. Other原则 4 31 42.9. 5.1. 可读性优先原则 4 31 42.10. 5.2. 拥抱变化原则 &nbsp;扩展性 4 31 42.11. 5.3. &nbsp;：迪米特法则最少知识原则”（Principle of Least Knowledge） 4 31 42.12. 5.4. 迪米特法则（Law?ofDemeter,?LOD） 4 32 42.13. 5.5. Don’t Repeat Yourself(DRY) 4 32 42.14. 5.6. Keep It Simple, Stupid (KISS) 4 32 42.15. 5.7. Program to an interface, not an implementation4 32 42.16. 5.8. You Ain’t Gonna Need It(YAGNI) 4 32 42.17. 5.9. 最小惊讶原则 遵守标准约定注释说什么代码就做什么 5 32 42.18. 5.10. 最小化耦合原则与最大内聚 5 33 42.19. 5.11. 隐藏实现细节原则 5 33 42.20. 5.12. 避免过早优化原则 5 33 42.21. 5.13. 得墨忒耳定律 5 33 42.22. 5.14. Common Closure Principle（CCP）–共同封闭原则 5 33 42.23. 5.15. Common Reuse Principle (CRP)–共同重用原则 5 33 42.24. 5.16. Hollywood Principle–好莱坞原则 5 34 42.25. 5.17. High Cohesion &amp; Low/Loose coupling &amp; –高内聚，低耦合6 34 42.26. 5.18. Convention over Configuration（CoC）–惯例优于配置原则 惯例优先原则6 34 42.27. 5.19. Acyclic Dependencies Principle (ADP)–无环依赖原则 6 34 42.28. 5.20. Postel's law伯斯塔尔法则 &nbsp;后向兼容性设计 6 35 42.29. 5.21. 软件，就像所有技术一样，具有天然的政治性。代码必然会反映作者的选择、偏见和期望。 6 35 42.30. 5.22. 首先为人类设计，其次为机器设计。 6 35 42.31. 5.23. 抽象原则 6 35 42.32. 6. 《编程法则》二十一条 6 35 43. datastruts数据结构 章节 35 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 编程语言概念（what 自然语言与编程语言的关系 &nbsp; 特点对比 特点 自然语言 程序语言 长度对比 冗长 精简&nbsp;高度抽象化 精确度 不精确 精确 界限 不明确 界限是明确 语句数量 有限的 无限 语法 宽松 严格的语法（Syntax）规则 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 形式语言有严格的语法（Syntax）规则，例如，3+3=6是一个语法正确的数学等式，而3=+6$则不是，H2O是一个正确的分子式，而2Zz则不是。语法规则是由关于符号（Token）和结构（Structure）的规则所组成的。Token的概念相当于自然语言中的单词和标点、数学式中的数和运算符、化学分子式中的元素名和数字。关于Token的规则称为词法（Lexical）规则，而关于语句结构的规则称为语法（Grammar）规则。&nbsp;[2]&nbsp; 开发中常用的编程语言 Js python sql xml html css java 正则表达式 工作流&nbsp;注解&nbsp;shell&nbsp;json &nbsp; 编程语言代际 1g&gt;&gt;2g&gt;&gt;3g(java c#) &gt;&gt;3.5g( 脚本类js python 等）&gt;&gt;&gt;4g( sql h5 正则表达式等）&gt;&gt;5g( 自然语言或类似人工智能语言 &nbsp; &nbsp; 编程语言能力模型金字塔 &nbsp; 形式语言的概念到了诺姆·乔姆斯基，就形成了一个新的理论（乔姆斯基谱系）。这个谱系把形式语言分成四种： 文法 语言 自动机 产生式规则 0-型 递归可枚举语言 图灵机 无限制 1-型 上下文相关语言 线性有界非确定图灵机 αAβ -&gt; αγβ 2-型 上下文无关语言 非确定下推自动机 A&nbsp;-&gt; γ 3-型 正规语言 有限状态自动机 A&nbsp;-&gt; aB A&nbsp;-&gt; a 这四种语言中，从上到下的语言是变得越来越容易用公式表达，但是表达能力也越来越弱。到了最后一种语言，已经变成最普通的正规语言了。 计算机编程语言是属于2-型，即上下文无关语言(context-free grammar)。只有这种语言，才可以用我们现在研究出来的编译器进行编译，也只有用这种语言写出来的代码，才可以经过编译器的解释之后被电脑理解。 &nbsp; 学习编程语言的用途 词法分析，语法分析 语义分析 数据挖掘提取抽取 大力提升可读 提升开法效率 other 怎么（how）去了解一门编程语言 语法角度 运行时环境vm runtime角度 同样都是java ，android和pc版本的不同 同样都是js语言 ，浏览器端和后端node运行环境的不同 核心类库标准库角度 外部库 编程语言种类&nbsp; 命令式语言（特点是一条条语句 缺点：细节化，对于层次结构表达不明显 函数式语言.（sql&nbsp; 声明式语言（h5 xml css等 逻辑式语言,,不必考虑实现过程而只需考虑定义和结果 注解 meta &nbsp;标签式语言（h5 xml 通用语言与dsl 全功能语言与弱功能表达式语言 &nbsp; 3.编程语言的主要的种类 逻辑式语言..函数式语言...命令式语言 &nbsp; 在FAQ3里说过，世界上有C和LISP两种编程语言，你现在学了C，以后学了C++、Java、.NET 等等，也仍然只认识了半个世界。LISP和 Haskell构成了另外半个世 &nbsp; &nbsp; 4.命令式语言主要组成（运算符与控制结构，if，foreach） 5.函数式语言（全部是函数） &nbsp; 6.逻辑式语言,,不必考虑实现过程而只需考虑定义和结果 &nbsp; 例如著名的 prolog。逻辑式语言一般依据成熟的逻辑体系来设计，比如 first-order logic（用于 prolog），因为这样有几点好处： 1）可以进行严密的逻辑推理； 2）可以方便有效地定义 knowledge base，这在专家系统中很重要； 3）开发者不必考虑实现过程而只需考虑定义和结果。这符合专家系统的设计理念。 &nbsp; 作者::&nbsp;老哇的爪子&nbsp;Attilax&nbsp;艾龙，&nbsp;&nbsp;EMAIL:1466519819@qq.com 转载请注明来源：&nbsp;http://blog.csdn.net/attilax &nbsp; 6.1.控制结构将消失,select ,foreach 等...表格将取代select结构 &nbsp; 只需考虑定义和结果,表格将取代select结构... &nbsp; 7.第五代语言 第五代语言就是自然语言又被称为知识库语言或人工智能语言，人工智能语言主要有LISP、Prolog &nbsp; 人们可能会问，用人工智能语言解决问题与传统的方法有什么区别呢？&nbsp; 传统方法通常把问题的全部知识以各种的模型表达在固定程序中，问题的求解完全在程序制导下按着预先安排好的步骤一步一步（逐条）执行。解决问题的思路与冯.诺依曼式计算机结构相吻合。当前大型数据库法、数学模型法、统计方法等都是严格结构化的方法。&nbsp; 对于人工智能技术要解决的问题，往往无法把全部知识都体现在固定的程序中。通常需要建立一个知识库（包含事实和推理规则），程序根据 环境和所给的输入信息以及所要解决的问题来决定自己的行动，所以它是在环境模式的制导下的推理过程。这种方法有极大的灵活性、对话能力、有自我解释能力和 学习能力。这种方法对解决一些条件和目标不大明确或不完备，（即不能很好地形式化，不好描述）的非结构化问题比传统方法好，它通常采用启发式、试探法策略 来解决问题。 &nbsp; &nbsp; 其实，每种编程语言的设计都有 独到之处，体现了每种语言的精髓，在融汇百家之后积累下来的正是方法论。 &nbsp; &nbsp; &nbsp;编程语言常见内部构成与概念&nbsp; 基础语法&nbsp;标识符与保留字 &nbsp;标识符由字母、数字、下划线组成 注释&nbsp;与 运算符 &nbsp; 算术运算符 比较（关系）运算符 赋值运算符 逻辑运算符 位运算符 &nbsp; 变量6属性 三大流程 名字/别名 地址/左值 值/右值 类型 作用域 生存期/生命期 &nbsp; &nbsp; &nbsp; &nbsp; 异常控制流程 流程图（Flow Chart 多分支结构 表达式（中缀前缀表达式 运算符 数据类型 Lambda 表达式 方法引用 生命周期 Cohesion 耦合Coupling 过程 函数 and 返回值 &nbsp; 5.13.循环(loop), 5.14. 递归(recursion), 5.15.遍历(traversal), 5.16.迭代(iterate). &nbsp; &nbsp; &nbsp; 泛型 环境变量 s-exp 类型系统（强类型 &nbsp;弱类型 &nbsp; 弱类型优点是简单快捷。。Map和自定义bean类型。。对比 &nbsp; &nbsp; 编译 词法分析 语法分析 语义分析 Ast语法树 预编译头机制&nbsp;&nbsp;import模式&nbsp; 前端编译 把Java源码文件（.java）编译成Class文件(.class)的过程； JIT 后端编译/即时(JIT)编译 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过Java虚拟机（JVM）内置的即时编译器（Just In Time Compiler，JIT编译器）；在运行时把Class文件字节码编译成本地机器码的过程； \"热点代码\"（Hot Spot Code）编译成与本地平台相关的机器码，并进行各种层次的优化； 静态提前编译（Ahead Of Time，AOT编译） &nbsp;程序运行前，直接把Java源码文件（.java）编译成本地机器码的过程； &nbsp; 增量编译&nbsp;vs 全量编译 编译模式 忽略模式 恢复模式 vs停止模式 编译api 动态执行java文件源码 &nbsp; 一些原则理论 &nbsp; solid原则 语言实现&nbsp; 词法分析 fsm状态机 正则表达式 词性标注 语法分析 ast 语义分析 内部DSL实现模式 外部DSL 生成AST BNF 正则表达式表的词法分析器 递归下降法语法解析器 解释器 表达式生成器 嵌套函数 方法级联 状态机fsm &nbsp; 类与对象实现 章节 class模板 dock type is-a has-a mix in oo三大特性 solid原则 抽象方法 抽象类和 单根继承 单例 动态绑定（dynamic binding 动态对象 对象持久性（object persistence 对象实现 多继承 多态 反射api加载 方法重载 访问方法（accessor method）和 封装 覆盖（Overriding 构造方法 构造函数 环境变量 基于原型 继承 接口用interface 类加载 菱形继承 魔术方法 魔术属性 设置方法(mutator method) 实例 属性读写 外部文件加载 析勾方法 消息 消息传递 延迟绑定方法 自动语句加载 字节数组加载 &nbsp;","categories":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}],"tags":[{"name":"V语言","slug":"v语言","permalink":"https://vlanguage.cn/tags/v语言/"}],"keywords":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}]},{"title":"编译器自举","slug":"tangyaya8_88090018","date":"2019-03-03T00:00:00.000Z","updated":"2019-07-22T05:05:30.305Z","comments":true,"path":"2019/03/03/tangyaya8_88090018.html","link":"","permalink":"https://vlanguage.cn/2019/03/03/tangyaya8_88090018.html","excerpt":"","text":"语言的编译器自举是某个语言成熟标志 今天看到一个新词：自举 在知乎上看到轮子哥的解答，很清楚： 你想创造一门V语言而且用V语言来写V编译器的话，你得按照下面的方法做：1、用C++把那个编译器（A）写出来，顺便留下很多测试用例。2、用V语言把那个编译器写（B）出来，用A.exe来编译B，修改直到所有测试用例都通过为止。3、B.exe来编译B自己得到B2.exe，修改直到B2.exe所有测试用例都通过为止。这是为了保证，就算B本身有很多bug，至少编译自己是没有bug的，从而你就可以走到第四步。4、当你觉得有信心了，用A.exe把B编译一遍，就得到了B.exe。然后A的代码和A.exe都在也不需要存在了，删掉他们。以后你就不断的用B.exe来编译下一个版本的B就好了。就自举了。","categories":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}],"tags":[{"name":"V语言","slug":"v语言","permalink":"https://vlanguage.cn/tags/v语言/"}],"keywords":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}]},{"title":"RISC-V嵌入式开发入门篇2：RISC-V汇编语言程序设计（下）","slug":"zoomdy_84138295","date":"2018-11-16T00:00:00.000Z","updated":"2019-07-22T05:05:31.868Z","comments":true,"path":"2018/11/16/zoomdy_84138295.html","link":"","permalink":"https://vlanguage.cn/2018/11/16/zoomdy_84138295.html","excerpt":"","text":"原文出处：https://mp.weixin.qq.com/s/Ln4qBYvSsgRvdiK1IJqI6Q 随着国内第一本RISC-V中文书籍《手把手教你设计CPU——RISC-V处理器篇》正式上市，越来越多的爱好者开始使用开源的蜂鸟E203 RISC-V处理核，很多初学者留言询问有关RISC-V工具链使用的问题，因此本公众号将开始陆续发表若干篇有关RISC-V软件工具链使用的文章，包括： RISC-V嵌入式开发准备篇1：编译过程简介 RISC-V嵌入式开发准备篇2：嵌入式开发的特点介绍 RISC-V嵌入式开发入门篇1：RISC-V GCC工具链的介绍 RISC-V嵌入式开发入门篇2：RISC-V汇编语言程序设计（上） RISC-V嵌入式开发入门篇2：RISC-V汇编语言程序设计（中） RISC-V嵌入式开发入门篇2：RISC-V汇编语言程序设计（下） RISC-V嵌入式开发上手篇：基于HBird-E-SDK平台的软件开发与运行 RISC-V嵌入式开发实践篇：运行开源蜂鸟E200 MCU更多示例程序 RISC-V嵌入式开发新奇篇：基于Windows Eclipse IDE的软件开发与运行 RISC-V嵌入式开发升华篇：基于开源蜂鸟E200 MCU移植RTOS 在本号之前发表的文章《编译过程简介》中介绍了C/C++语言如何被编译成为汇编语言，而本文将介绍如何直接使用RISC-V架构的汇编语言进行程序设计。 《RISC-V汇编语言程序设计》——分成上中下三篇，本篇是下篇。继续关注公众号可查询上中两篇的内容。 上篇：RISC-V嵌入式开发入门篇2：RISC-V汇编语言程序设计（上） 中篇：RISC-V嵌入式开发入门篇2：RISC-V汇编语言程序设计（中） 注：本文节选自《RISC-V架构与嵌入式开发快速入门》（即将出版）。 1.6.1 GCC内联汇编简述 由于本文介绍的是GCC的RISC-V工具链，因此在C/C++程序中嵌入汇编程序遵循GCC内联汇编（inline asm ）语法规则，其格式有如下部分组成： 分别简述如下： “关键字asm”，为GCC的关键字，表示进行内联汇编操作。 注意：也可以使用前后各带两个下划线的asm__，_asm_是GCC 关键字asm 的宏定义。 “关键字volatile”，或者_volatile_。_volatile_或volatile 是可选的，如果添加了该关键字，则要求编译器对后续括号内添加汇编程序不进行任何优化以保持其原状；如果没有添加此关键字，则编译器可能会将某些汇编指令优化掉。 注意：也可以使用_volatile_，__volatile是GCC 关键字volatile 的宏定义。 “汇编指令列表”，即需要嵌入的汇编指令，每条指令必须被双引号括起来（作为字符串），两条指令之前必须以“\\n”或者“；”作为分隔符，如果没有添加分隔符的两个字符串将会被合并成为一个字符串。 注意：“汇编指令列表”中的编写语法和普通的汇编程序编写一样，可以在其中定义标签（Label）、定义对齐(.align n )、定义段(.section name )等。 “输出操作数”，用来指定当前内联汇编程序的输出操作符列表。 有关“输出操作数”部分的详细介绍，请参见第1.6.2节。 “输入操作数”，用来指定当前内联汇编语句的输入操作符列表。 有关“输入操作数”部分的详细介绍，请参见第1.6.2节。 “可能影响的寄存器或存储器”，用于告知编译器当前内联汇编语句可能会对某些寄存器或内存进行修改，使得编译器在优化时将其因素考虑进去。 有关“可能影响的寄存器或存储器”部分的详细介绍，请参见第1.6.3节。 综上，一个典型的完整内联汇编程序格式如下： 后续章节将进行进一步详述。 1.6.2 GCC内联汇编“输出操作数”和“输入操作数”部分 由于C/C++中使用的是抽象层次较高的变量或者表达式，如下所示： 而汇编指令中直接操作的是寄存器，以RISC-V指令集为例，一个加法指令的汇编指令如下： 那么，当在C/C++程序中添加了汇编程序之时，程序员如何将其所需要操作的C/C++变量与汇编指令的操作数对应起来呢？那就需要使用到GCC内联汇编的“输出操作数”和“输入操作数”部分来指定。 GCC内联汇编语法的“输入操作数”和“输出操作数”部分用来指定当前内联汇编程序的输入和输出操作符列表。其遵循如下语法： 每一个输入或者输出操作符都由3部分组成，分别为： （1）方括号[]中的符号名，用于将内联汇编程序中使用的操作数（由%[字符]指定）和此操作符（由[字符]指定）通过同名“字符”绑定起来。 — 除了使用“%[字符]”中明确的符号命名指定之外，还可以使用“%数字”的方式进行隐含指定。“数字”从0开始，依次表示输出操作数和输入操作数。譬如：假设包含“输出操作数”列表中有2个操作数，“输入操作数”列表中有2个操作数，则汇编程序中%0表示第一个输出操作数，%1表示第二个输出操作数，%2表示第一个输入操作数，%3表示第二个输入操作数。 （2）引号中的限制字符串，用于约束此操作数变量的属性，常用的约束如： — 字母“r”代表使用编译器自动分配的寄存器来存储该操作数变量；字母“m”代表使用内存地址来存储该操作数变量。如果同时指明“rm”则编译器自动选择最优方案。 — 对于“输出操作数”而言，等号“=”代表输出变量用作输出，原来的值会被新值替换；加号“+”代表输出变量不仅作为输出，还作为输入。注意：此约束对不适用于“输入操作数”。 （3）圆括号（）中的C/C++变量或者表达式。 输出操作符之间需使用逗号分割。 为了便于读者理解上述语法，请读者参见第1.6.4节和1.6.5中的实例。 1.6.3 GCC内联汇编“可能影响的寄存器或存储器”部分 如果内联汇编中的某个指令会更新某些寄存器的值，则必须在asm中第三个冒号后的“可能影响的寄存器或存储器”中显示的指定出这些寄存器，从而通知GCC编译器让其不再假定之前存入这些寄存器中的值依然合法。指定出这些寄存器由逗号分隔开，每个寄存器由引号包含住，如下所示： 注意：对于那些已经由“输入操作数”和“输出操作数”部分约束指定了的变量，由于编译器自动分配寄存器，因此编译器知道哪些寄存器会被更新，所有程序员无需担心这部分寄存器，不用在“可能影响的寄存器或存储器”进行显示的指定。 如果内联汇编中的某个指令会以无法预料的形式修改了存储器中的值，则必须在asm中第三个冒号后的“可能影响的寄存器或存储器”中显示的加上“memory”，从而通知GCC编译器不要将存储器中的值暂存在处理器的通用寄存器中。 为了便于读者理解上述语法，请读者参见第1.6.4节和1.6.5节中的实例。 1.6.4 GCC内联汇编参考实例一 以下结合第1.6.2节中描述的“add”汇编示例给出一个完整的实例，代码如下： 从上述示例可以看出，通过使用“输出操作数”和“输入操作数”部分的指定，可以将C/C++中的变量或者表达式映射到汇编指令中充当操作数进行操作。在此过程中，程序员无需关心真正执行的汇编指令具体使用的寄存器索引是什么（譬如到底是x1，还是x2等等），编译器会根据引号中指定的操作数约束按照编译优化的原则来分配合理的寄存器索引号。因此，程序员仅仅需要关心操作数和变量的映射，无需关心操作数会映射到处理器具体的哪个通用寄存器，使得软件程序员能够从底层硬件的细节中被解放出来。 1.6.5 GCC内联汇编参考实例二 RISC-V架构中定义的CSR寄存器由于需要使用特殊的CSR指令进行访问，如果在C/C++程序中需要使用CSR寄存器，只能够采用内嵌汇编（CSR指令）的方式才能够对CSR寄存器进行操作。以下是在C语言中调用RISC-V的CSR读或者写汇编指令访问CSR寄存器的一个实例，代码如下： 1.6.6 小结 GCC内联汇编语法的规则比较复杂，信息量很大。本文由于限于篇幅，仅对其最基本的语法和示例进行介绍，以帮助读者能够看懂并且编写简单的C/C++内联汇编程序。感兴趣的读者可以自行查阅完整的GNU C/C++内联汇编语法手册了解更多详情。 1.7 在汇编中调用C/C++函数 除了在C/C++程序中内嵌汇编程序之外，还可以在汇编程序中调用C/C++函数。这种情形在实际的工程中使用也很常见，由于C/C++语言构造的函数非常普遍，在某些以汇编程序为主体的程序中也会调用C/C++的函数。 在介绍C/C++函数调用之前，需要先介绍应用程序二进制接口（Abstract Binary Interface，ABI），ABI描述了应用程序和操作系统之间，应用和它的库之间，或者应用的组成部分之间的接口。ABI涵盖了各种细节，如： 数据类型的大小、布局和对齐; 函数调用约定（控制着函数的参数如何传送以及如何接受返回值），例如，是所有的参数都通过栈传递，还是部分参数通过寄存器传递；哪个寄存器用于哪个函数参数；通过栈传递的第一个函数参数是最先push到栈上还是最后； 系统调用的编码和一个应用如何向操作系统进行系统调用； 以及在一个完整的操作系统ABI中，目标文件的二进制格式、程序库等等。 其中，函数调用约定决定了函数调用时参数传递和函数返回结果的规则，有关RISC-V架构ABI的函数调用约定，请参见附录A中的图A-1。 对于RISC-V汇编程序而言，在汇编程序中调用C/C++语言函数，必须遵照ABI所定义的函数调用规则，即，函数参数由寄存器a0-a7所传递，函数返回由寄存器a0-a1所指定，一个具体的示例代码如下： 1.8 总结 汇编语言由于是一种低级语言，因此抽象层次较低，程序编写难度较大，在实际的工作中，更多的情形是能够阅读理解某些现有的汇编代码，或者编写比较简单的汇编程序。 由于本文介绍的RISC-V工具链基于的是GCC工具链，因此RISC-V汇编程序也遵循GNU汇编语法规则，完整的GNU汇编语法手册长达数百页，介绍了大量的伪操作和语法，但是大多数的语法并不常用。本文由于限于篇幅，仅对RISC-V汇编常用的语法进行简要介绍，以帮助读者初步认识RISC-V汇编语言程序、能够看懂并且编写简单而基本的汇编程序。如果对于RISC-V汇编编程进阶感兴趣的读者可以自行查阅RISC-V汇编语言的完整的GNU汇编语法手册了解更多详情。 《RISC-V汇编语言程序设计》——分成上中下三篇，本篇是下篇。继续关注公众号可查询上中两篇的内容。 上篇：RISC-V嵌入式开发入门篇2：RISC-V汇编语言程序设计（上） 中篇：RISC-V嵌入式开发入门篇2：RISC-V汇编语言程序设计（中） 更多信息 感兴趣的读者可以通过下面二维码关注公众号“硅农亚历山大”，了解Verilog、IC设计、CPU、RISC-V和人工智能AI相关的更多设计技巧和经验分享，注意：由于干货太多，请自备茶水。","categories":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}],"tags":[{"name":"V语言","slug":"v语言","permalink":"https://vlanguage.cn/tags/v语言/"}],"keywords":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}]},{"title":"Atitit 编程语言的分类 v2 目录 1.1. 基于代数划分 第一代。。。第三代。。4gl。。5gl自然语言 1 1.2. 按照编程范式分类 . 命令式语言 .函数式语言...逻辑式语言","slug":"attilax_83996805","date":"2018-11-12T00:00:00.000Z","updated":"2019-07-22T05:05:27.009Z","comments":true,"path":"2018/11/12/attilax_83996805.html","link":"","permalink":"https://vlanguage.cn/2018/11/12/attilax_83996805.html","excerpt":"","text":"Atitit 编程语言的分类 v2 &nbsp; 目录 1.1. 基于代数划分 &nbsp;&nbsp;第一代。。。第三代。。4gl。。5gl自然语言 1 1.2. 按照编程范式分类 &nbsp;. 命令式语言&nbsp;.函数式语言...逻辑式语言 1 1.3. 命令式&nbsp;&nbsp;vs 声明式（dsl 函数式） 3 1.4. 按照是否编译&nbsp;编译型语言 &nbsp;解释性语言 3 1.5. 面向对象”&nbsp;&nbsp;“面向过程” 3 1.6. 可视化语言&nbsp;vs 文本代码 3 1.7. 标记语言&nbsp;标签式语言&nbsp;vs &nbsp;非标记性语言 3 1.8. 领域专用语言(DSL)&nbsp;vs 通用语言 3 1.9. 表达式语言(Expression Language)简称EL 3 2. ref 3 &nbsp; 基于代数划分 &nbsp;&nbsp;第一代。。。第三代。。4gl。。5gl自然语言 &nbsp; &nbsp; 按照编程范式分类 &nbsp;. 命令式语言&nbsp;.函数式语言...逻辑式语言 命令式语言 &nbsp; 计算机体系结构是影响语言设计的一个重要因素，目前的大多数语言都是围绕着冯诺依曼结构设计的，这些语言称为“命令式语言”。 命令式语言的核心特征： （1）变量（冯诺依曼结构的存储单元） （2）赋值语句（数据传输） （3）迭代形式的循环（冯诺依曼结构中实现循环的最高效形式） 函数式程序语言的目的是尽可能的模拟数学函数。 函数式语言的核心特征： （1）以“函数”为首，如同命令式语言中的“变量”，函数可以赋值给其他变量，可以作为其他函数的参数，或者作为其他函数的返回值。 （2）不修改变量的值 （3）只有表达式，没有语句。此处的语句指的是没有返回值得某些操作。 （4）引用透明（Referential transparency），函数的运行不依赖与外部变量或“状态”，简单的说就是，同一个输入（参数），总是会产生同一个输出（返回值），这与数学函数的特征很一致。命令式语言因为全局变量等的存在，就无法做到这一点。 （5）对比命令式语言，递归形式的循环 逻辑程序设计语言：基于逻辑符号逻辑的语言称为逻辑程序设计语言，或者声明性语言 逻辑程序设计：用一种符号逻辑作为程序设计语言来进行程序设计，通常称为逻辑程序设计 逻辑式编程语言是基于规则的编程语言，程序是事实和规则集，通过符号逻辑来表示程序，并使用逻辑推导过程来生成结果。 命令式&nbsp;&nbsp;vs 声明式（dsl 函数式） 按照是否编译&nbsp;编译型语言 &nbsp;解释性语言 &nbsp; 面向对象”&nbsp;&nbsp;“面向过程” 可视化语言&nbsp;vs 文本代码 标记语言&nbsp;标签式语言&nbsp;vs &nbsp;非标记性语言&nbsp; （3）标记语言（markup language）（HTML、XML等） 这种语言，不算做编程语言； 但是某些标记语言（比如HTML和XML）的扩展中，也加入了一些程序设计的功能——标记与程序设计混合语言（比如JSP标准标签库中的JSTL） 领域专用语言(DSL)&nbsp;vs 通用语言 表达式语言(Expression Language)简称EL ref 函数式编程语言-布布扣-bubuko.com.html","categories":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}],"tags":[{"name":"V语言","slug":"v语言","permalink":"https://vlanguage.cn/tags/v语言/"}],"keywords":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}]},{"title":"RISC-V嵌入式开发入门篇2：RISC-V汇编语言程序设计（上）","slug":"zoomdy_83620580","date":"2018-11-01T00:00:00.000Z","updated":"2019-07-22T05:05:31.738Z","comments":true,"path":"2018/11/01/zoomdy_83620580.html","link":"","permalink":"https://vlanguage.cn/2018/11/01/zoomdy_83620580.html","excerpt":"","text":"原文出处：https://mp.weixin.qq.com/s/jyI-SSm_5Gg-KQyjKsIj5Q 随着国内第一本RISC-V中文书籍《手把手教你设计CPU——RISC-V处理器篇》正式上市，越来越多的爱好者开始使用开源的蜂鸟E203 RISC-V处理核，很多初学者留言询问有关RISC-V工具链使用的问题，因此本公众号将开始陆续发表若干篇有关RISC-V软件工具链使用的文章，包括： RISC-V嵌入式开发准备篇1：编译过程简介 RISC-V嵌入式开发准备篇2：嵌入式开发的特点介绍 RISC-V嵌入式开发入门篇1：RISC-V GCC工具链的介绍 RISC-V嵌入式开发入门篇2：RISC-V汇编语言程序设计（上） RISC-V嵌入式开发入门篇2：RISC-V汇编语言程序设计（中） RISC-V嵌入式开发入门篇2：RISC-V汇编语言程序设计（下） RISC-V嵌入式开发上手篇：基于HBird-E-SDK平台的软件开发与运行 RISC-V嵌入式开发实践篇：运行开源蜂鸟E200 MCU更多示例程序 RISC-V嵌入式开发新奇篇：基于Windows Eclipse IDE的软件开发与运行 RISC-V嵌入式开发升华篇：基于开源蜂鸟E200 MCU移植RTOS 在本号之前发表的文章《编译过程简介》中介绍了C/C++语言如何被编译成为汇编语言，而本文将介绍如何直接使用RISC-V架构的汇编语言进行程序设计。 《RISC-V汇编语言程序设计》——分成上中下三篇，本篇是上篇。继续关注公众号可查询中下两篇的内容。 注：本文节选自《RISC-V架构与嵌入式开发快速入门》（即将出版）。 1.1 汇编语言简介 汇编语言（Assembly Language）是一种“低级”语言，汇编语言一听就不高兴了：凭什么说我是低级语言，我哪里低级了。 其实此“低级”非彼“低级”，之所以说汇编语言是一种低级的语言，是因为其面向的是最底层的硬件，直接使用的是处理器的基本指令。因此，相对于抽象层次更高的C/C++语言，汇编语言确实是一门“低级”的语言，此“低级”是指其抽象层次比较低。 由于汇编语言的“低级”属性，它有如下缺点： 由于汇编语言直接接触最底层的硬件，需要对底层硬件非常熟悉才能编写出高效的汇编程序，因此，汇编语言是一门比较难以使用的语言，故而有“汇编语言不会编”的说法。 由于汇编语言的抽象层次很低，因此使用汇编语言设计程序无法像高级语言那样写出灵活多样的程序，并且其程序代码很难阅读和维护。 由于汇编语言使用的是处理器的基本指令，而处理器指令与其处理器架构一一对应，所以，不同架构处理器的汇编程序必然是无法直接移植，所以汇编程序的可移植性和通用性很差。 但是每一枚硬币皆有其两面，汇编语言也有其优点： 由于汇编的过程即为汇编器将汇编指令直接翻译成二进制的机器码（处理器指令），因此程序员可以对生成的二进制代码进行完全的掌控，不会受到编译器的影响。 由于汇编语言直接面向最底层的硬件，因此其可以对处理器进行直接的控制，可以最大化的挖掘硬件的特性和潜能，可以开发出最佳优化的代码。 综上，虽然现在大多数的程序设计已经不再使用汇编语言，但是在一些特殊的场合，譬如底层驱动、引导程序、高性能算法库等领域，汇编语言还经常扮演着重要的角色。尤其对于嵌入式软件开发人员而言，即便无法娴熟地编写复杂的汇编语言，但是能够阅读理解并且编写简单地汇编程序可以说是嵌入式软件人员必备的技能。 1.2 RISC-V汇编程序概述 汇编程序的最基本元素是指令，指令集是处理器架构的最基本要素。因此RISC-V汇编语言的最基本元素自然是一条条的RISC-V指令。 除了指令之外，由于本号之前发表文章《RISC-V嵌入式开发入门篇1：RISC-V GCC工具链的介绍》介绍的RISC-V工具链是GCC工具链，因此，一般的GNU汇编语法也能够被GCC的汇编器识别，所以GNU汇编语法中定义的伪操作、操作符、标签等语法规则均可以在RISC-V汇编语言中使用。因此，一个完整的RISC-V汇编程序由RISC-V指令和GNU汇编规则定义的伪操作、操作符、标签等组成。 一条典型的RISC-V汇编语句由4部分组成，包含如下字段： 标签：表示当前指令的位置标记，请参见第1.5.1节了解具体使用实例 。 操作码：操作码可以是如下任意一种： RISC-V指令的指令名称，譬如addi指令、lw指令等。有关RISC-V指令的完整列表和详情请参见中文书《手把手教你设计CPU——RISC-V处理器篇》附录A。 汇编语言的伪操作，请参见第1.4节了解更多信息。 用户自定义的宏，请参见第1.5.2节了解具体使用实例。 操作数：操作数是操作码所需的参数，与操作码之间以空格分开。 操作数：可以是符号、常量、或者由符号和常量组成的表达式。 注释：注释即为了使的程序代码便于理解而添加的信息，注释并不发挥实际功能，仅仅起到注解作用。注释是可选的，如果添加注释，需要： 以“；”或者“#”作为分隔号，以分隔号开始的本行之后部分到本行结束都会被当做注释。 或者使用类似C语言的注释语法//和/* */对单行或者大段程序进行注释。 一段典型的RISC-V汇编程序如下所示： 上述汇编程序中使用到的汇编语法将在本文后续章节分别进行介绍。 1.3 RISC-V汇编指令 汇编程序的最基本元素是指令，指令集是处理器架构的最基本要素。因此RISC-V汇编语言的最基本元素便是一条条的RISC-V指令。请参见中文书《手把手教你设计CPU——RISC-V处理器篇》的附录A了解RISC-V指令集的详细信息。 除了普通的指令，RISC-V还定义了伪指令以便于用户编写汇编程序，本文第1.5.3和1.5.4节给出了使用伪指令的汇编程序实例。请参见中文书《手把手教你设计CPU——RISC-V处理器篇》的附录A.15节了解RISC-V伪指令的详细信息。 1.4 RISC-V汇编程序伪操作 在汇编语言中，有一些特殊的操作助记符，这些操作的助记符通常被称为伪操作（Pseudo Ops），伪操作在汇编程序中的作用是指导汇编器处理汇编程序的行为，这些伪操作仅在汇编过程中起作用，一旦汇编结束，伪操作的使命就此结束。 由于本文介绍的RISC-V工具链是GCC工具链，因此，一般的GNU汇编语法中定义的伪操作均可在RISC-V汇编语言中使用。经过不断的增加，目前GNU汇编中定义的伪操作数目众多，感兴趣的读者可以自行查阅完整的GNU汇编语法手册了解详情。本节将仅简介若干常见的伪操作。 .file filename .file伪操作用指示汇编器该汇编程序的逻辑文件名。 .global symbol_name或者.globl symbol_name .global和.globl伪操作用于定义一个全局的符号，使得链接器能够全局识别它，即一个程序文件中定义的符号能够被所有其他程序文件可见。 .local symbol_name .local伪操作用于定义局部符号，使得此符号不能够被其他程序文件可见。 .weak symbol_name 在汇编程序中，符号的默认属性为强（strong），.weak伪操作则用于设置符号的属性为弱（weak），如果此符号之前没有定义过，则同时创建此符号并定义其属性为weak。 如果符号的属性为weak，那么它无需定义具体的内容。在链接的过程中，另外一个属性为strong的同名符号可以将此weak符号的内容强制覆盖。利用此特性，.weak伪操作常用于预先预留一个空符号，使得其能够通过汇编器语法检查，但是在后续的程序中定义符号的真正实体，并且在链接阶段将空符号覆盖并链接。 .type name , type description .type伪操作用于定义符号的类型。譬如“.type symbol,@function”即将名为symbol的符号定义为一个函数（function）。 .align integer .align伪操作用于将当前PC地址推进到“2的integer次方个字节”对齐的位置。譬如“.align 3”即表示将当前PC地址推进到8个字节对齐的位置处。 .balign integer .balign伪操作用于将当前PC地址推进到“integer个字节”对齐的位置。 .zero integer .zero伪操作将从当前PC地址处开始分配integer个字节空间并且用0值填充。譬如“.zero 3”即表示分配三个字节的0值。 .byte expression [, expression]* .byte伪操作将从当前PC地址处开始分配若干个字节（byte）的空间，每个字节填充的值由分号分隔开的expression指定。 .2byte expression [, expression]* .2byte伪操作将从当前PC地址处开始分配若干个双字节（2 bytes）的空间，每个双字节填充的值由分号分隔开的expression指定。空间分配的地址可以与双字节非对齐。 .4byte expression [, expression]* .4byte伪操作将从当前PC地址处开始分配若干个四字节（4 bytes）的空间，每个四字节填充的值由分号分隔开的expression指定。空间分配的地址可以与四字节非对齐。 .8byte expression [, expression]* .8byte伪操作将从当前PC地址处开始分配若干个八字节（8 bytes）的空间，每个八字节填充的值由分号分隔开的expression指定。空间分配的地址可以与八字节非对齐。 .half expression [, expression]* .half伪操作将从当前PC地址处开始分配若干个半字（half-word）的空间，每个半字填充的值由分号分隔开的expression指定。空间分配的地址一定与半字对齐（half-word aligned）。 .word expression [, expression]* .word伪操作将从当前PC地址处开始分配若干个字（word）的空间，每个字填充的值由分号分隔开的expression指定。空间分配的地址一定与字对齐（word aligned）。 .dword expression [, expression]* .dword伪操作将从当前PC地址处开始分配若干个双字（double-word）的空间，每个双字填充的值由分号分隔开的expression指定。空间分配的地址一定与双字对齐（double-word aligned）。 .string “string” .string伪操作将从当前PC地址处开始分配若干个字节空间用于存放“string”字符串。字节的个数取决于字符串的长度。 .float 或者 .double expression [, expression]* .float伪操作将从当前PC地址处开始分配若干个单精度浮点数（32位）的空间，每个单精度浮点数填充的值由分号分隔开的expression指定。空间分配的地址一定与32位对齐。 .double伪操作将从当前PC地址处开始分配若干个双精度浮点数（64位）的空间，每个双精度浮点数填充的值由分号分隔开的expression指定。空间分配的地址一定与64位对齐。 若干.float和.double伪操作的示例如下： .comm或者.common name, length .comm和.common伪操作用于声明一个名为name的未初始化存储区间，区间大小为length个字节。由于是未初始化存储区间，在链接阶段会将其链接到.bss段中。有关链接后ELF文件常见段.text、.data、.rodata、.bss请参见本号之前发表文章《编译过程简介》节了解更多信息。 .option {rvc,norvc,push,pop} .option伪操作用于设定某些架构特定的选项，使得汇编器能够识别此选项并按照选项的定义采取相应的行为。 rvc、norvc是RISC-V架构特有的选项，用于控制是否生成16位宽的压缩指令： “.option rvc”伪操作表示接下来的汇编程序可以被汇编生成16位宽的压缩指令。 “.option norvc”伪操作表示接下来的汇编程序不可以被汇编生成16位宽的压缩指令。 push、pop用于临时性的保存或者恢复.option伪操作指定的选项： “.option push”伪操作暂时将当前的选项设置保存起来，从而允许之后使用.option伪操作指定新的选项；而“.option pop”伪操作将最近保存的选项设置恢复出来重新生效。 通过“.option push”和“.option pop”的组合，便可以在汇编程序中在不影响全局选项设置的情况下，为其中嵌入的某一段代码特别地设置不同的选项。 .section name [, subsection] .section伪操作指明将接下来的代码汇编链接到名为name的段（Section）当中，还可以指定可选的子段（Subsection）。常见的段如.text、.data、.rodata、.bss： “.section .text”伪操作将接下来的代码汇编链接到.text段。 “.section .data”伪操作将接下来的代码汇编链接到.data段。 “.section .rodata”伪操作将接下来的代码汇编链接到.rodata段。 “.section .bss”伪操作将接下来的代码汇编链接到.bss段。 .text .text伪操作基本等效于“.section .text”。 .data .data伪操作基本等效于“.section .data”。 .rodata .rodata伪操作基本等效于“.section .rodata”。 .bss .bss伪操作基本等效于“.section .bss”。 .pushsection name 和.popsection .pushsection伪操作将之前的段设置保存起来，并且将当前的段设置改为名为name的段。即，指明将接下来的代码汇编链接到名为name的段中。 .popsection伪操作将最近保存的段设置恢复出来。 通过“.pushsection”和“.popsection”的组合，便可以在汇编程序的编写过程中，在某一个段的汇编代码中特别的插入另外一个段的代码。这种编写方式在某些情况下会给代码编写带来极大的方便，示例代码如下： .macro和.endm .macro和.emdm伪操作用于将一串汇编代码定义成为一个宏。 “.macro name arg1 [, argn]”用于定义名为name的宏，并且可以传入若干由分号分隔的参数。 “.endm”用于结束宏定义。 .equ name, value .equ伪操作用于将名为name的符号赋值为value的值。 《RISC-V汇编语言程序设计》——分成上中下三篇，本篇是上篇。继续关注公众号可查询中下两篇的内容。 （未完待续：请参见《RISC-V嵌入式开发入门篇2：RISC-V汇编语言程序设计（中）、《RISC-V嵌入式开发入门篇2：RISC-V汇编语言程序设计（下）》） 更多信息 感兴趣的读者可以通过下面二维码关注公众号“硅农亚历山大”，了解Verilog、IC设计、CPU、RISC-V和人工智能AI相关的更多设计技巧和经验分享，注意：由于干货太多，请自备茶水。","categories":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}],"tags":[{"name":"V语言","slug":"v语言","permalink":"https://vlanguage.cn/tags/v语言/"}],"keywords":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}]},{"title":"【C语言】【unix c】信号量集（system v ipc）","slug":"weixin_38239856_78255781","date":"2017-10-16T00:00:00.000Z","updated":"2019-07-22T05:05:30.862Z","comments":true,"path":"2017/10/16/weixin_38239856_78255781.html","link":"","permalink":"https://vlanguage.cn/2017/10/16/weixin_38239856_78255781.html","excerpt":"","text":"二、信号量集（system v ipc） 信号量集就是数组，数组里的每个元素都是信号量的类型 1、获取键值 ftok(3) 2、使用键值获取信号量集的id semget(2) #include &lt;sys/types.h&gt; #include &lt;sys/ipc.h&gt; #include &lt;sys/sem.h&gt; int semget(key_t key, int nsems, int semflg); 功能：获取信号量集的id 参数： key：ftok（3）的返回值 nsems：指定了信号量集中的元素的个数 semflg： IPC_CREAT IPC_EXCL mode：指定信号量集的权限 返回值：非负整数 是信号量集的id -1 错误errno被设置 3、设置信号量集中的信号量的初值或者获取信号量的值 semctl(2) #include &lt;sys/types.h&gt; #include &lt;sys/ipc.h&gt; #include &lt;sys/sem.h&gt; int semctl(int semid, int semnum, int cmd, ...); 功能：信号量的控制操作（得到一个信号量集标识符或创建一个信号量集对象并返回信号量集标识符） 参数： semid:指定了信号量集 semnum:指定了信号量在数组中的下标 cmd：指定了对信号量的控制操作命令 GETVAL：第几个信号的semval值 SETVAL:设置第几个信号量的semval值为arg，val。 0 ...:这个参数有没有，多少个取决于cmd 返回值：成功 返回一个正数 失败 -1 errno返回 需要自定义： union semun { int val; /* Value for SETVAL */ struct semid_ds *buf; /* Buffer for IPC_STAT, IPC_SET */ unsigned short *array; /* Array for GETALL, SETALL */ struct seminfo *__buf; /* Buffer for IPC_INFO (Linux-specific) */ }; 4、对指定的信号量对指定的信号量加法或者减法操作 semop(2) #include &lt;sys/types.h&gt; #include &lt;sys/ipc.h&gt; #include &lt;sys/sem.h&gt; int semop(int semid, struct sembuf *sops, unsigned nsops); 功能：信号量操作 参数： semid：指定了信号量集 sops：指定了对某个信号量的具体操作 nsops：指定了要操作的信号量的个数 返回值：0 成功 -1 错误 errno被设置 操作定义在这个结构体中： struct sembuf{ unsigned short sem_num; /* semaphore number */ short sem_op; /* semaphore operation */ short sem_flg; /* operation flags */ } sem_flg： SEM_UNDO：进程终止自动撤销 IPC_NOWAIT： sem_num：指定了要操作的信号量在数组的下标 sem_op：指定了操作的类型 操作类型分为3种： &gt;0: semval+sem_op demval做加法 =0： &lt;0： semval&gt;|sem_op|:这个操作立即执行， semval&lt;|sem_op| 申请的资源数&gt;可用资源数，IPC_NOWAIT 非阻塞 sem_flg=0 阻塞等待资源时间 举例说明：使用信号量集实现进程间的通信 两个进程 PA.C(设置信号量的值，每隔3s semval的值减一) PB.C（每隔1s获取信号量的值） PA.c: #include &lt;stdio.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/ipc.h&gt; #include &lt;sys/sem.h&gt; typedef union semun{ int val; }semun_t; int main(void){ key_t key; struct sembuf sb={0,-1,IPC_NOWAIT}; semun_t arg; //获取键值 key=ftok(\".\",31); if(key==-1){ perror(\"ftok\"); return -1; } //使用键值获取信号量集的id int semid=semget(key,1,IPC_CREAT|0664); if(semid==-1){ perror(\"semget\"); return -1; } arg.val=5; //设置信号量的初值 int ctl=semctl(semid,0,SETVAL,arg); if(ctl==-1){ perror(\"semctl\"); return -1; } //每隔三秒第一个信号量的值减1 while(1){ sleep(3); int op=semop(semid,&amp;sb,1); if(op==-1){ perror(\"semop\"); return -1; } } return 0; } PB.c: #include &lt;stdio.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/ipc.h&gt; #include &lt;sys/sem.h&gt; int main(void){ key_t key; //获取键值 key=ftok(\".\",31); if(key==-1){ perror(\"ftok\"); return -1; } //使用键值获取信号量集的id int semid=semget(key,1,IPC_CREAT|0664); if(semid==-1){ perror(\"semget\"); return -1; } //每隔一秒取一次信号量的值 while(1){ sleep(1); int val=semctl(semid,0,GETVAL); if(val==-1){ perror(\"semctl\"); return -1; } printf(\"semval=%d\\n\",val); } return 0; }","categories":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}],"tags":[{"name":"V语言","slug":"v语言","permalink":"https://vlanguage.cn/tags/v语言/"}],"keywords":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}]},{"title":"phpcms v9 切换 英文语言包","slug":"lqs745920569_51282333","date":"2016-04-29T00:00:00.000Z","updated":"2019-07-22T05:05:29.126Z","comments":true,"path":"2016/04/29/lqs745920569_51282333.html","link":"","permalink":"https://vlanguage.cn/2016/04/29/lqs745920569_51282333.html","excerpt":"","text":"caches\\configs\\system.php 'lang' =&gt; 'en', &nbsp;//网站语言 直接原来的zh-cn 改成 en就可以了。前台页面全部更换成英文语言包。 如果想改后台的界面，改成英语的，是在网站后台》我的面板》修改个人信息，设置一下就好了。","categories":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}],"tags":[{"name":"V语言","slug":"v语言","permalink":"https://vlanguage.cn/tags/v语言/"}],"keywords":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}]},{"title":"phpcms v9教程：语言包详解","slug":"buzhang1314_50681557","date":"2016-02-17T00:00:00.000Z","updated":"2019-07-22T05:05:27.650Z","comments":true,"path":"2016/02/17/buzhang1314_50681557.html","link":"","permalink":"https://vlanguage.cn/2016/02/17/buzhang1314_50681557.html","excerpt":"","text":"phpcms v9语言包位置 1、phpcms\\languages\\zh-cn&nbsp;&nbsp;&nbsp; 中文语言包 2、phpcms\\languages\\en&nbsp;&nbsp;&nbsp; 英文语言包 phpcms v9语言包建立 在phpcms v9二次开发之模型类的应用，讲到了足球等级的模型类的应用，现在为其添加一个中文语言包，其步骤如下： 1、phpcms\\languages\\zh-cn&nbsp; 目录下新建一个文件level.lang.php，注意“level”与模块名称相对应。 2、在level.lang.php写上如下代码： &lt;?php $LANG['level_name']&nbsp;&nbsp; = '等级'; $LANG['edit_level']&nbsp;&nbsp;&nbsp; = '编辑等级'; $LANG['operations_manage']&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp;&nbsp;&nbsp;&nbsp; '管理操作'; $LANG['allselect']&nbsp;&nbsp;&nbsp; = '全选'; $LANG['level_deleted']&nbsp;&nbsp; = '等级批量删除完成！'; ?&gt; 到此，一个语言包就建立完了，真的很简单，接下来我我来看一下它的应用。 phpcms v9语言包应用 模块语言包一般是用在与之相应的模块的 phpcms v9模板 上，好比一个局部变量，系统语言包适用所有模块模板，就像全局变量一样。下面是足球级别后台列表模板代码片断： &lt;thead&gt; &nbsp; &lt;tr&gt; &nbsp;&nbsp;&nbsp; &lt;th width=\"50\" align=\"center\"&gt;&lt;input type=\"checkbox\" value=\"\" id=\"check_box\" οnclick=\"selectall('id[]');\"&gt;&lt;?php echo L('allselect')?&gt;&lt;/th&gt; &nbsp;&nbsp;&nbsp; &lt;th&nbsp; align=\"center\"&gt;id&lt;/th&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &lt;th&nbsp; align=\"center\"&gt;&lt;?php echo L('level_name')?&gt;&lt;/th&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &lt;th&nbsp; align=\"center\"&gt;&lt;?php echo L('operations_manage')?&gt;&lt;/th&gt; &nbsp; &lt;/tr&gt; &lt;/thead&gt; 我们上面定义的语言包中\"$LANG['level_name'] = '等级';\"，就是作为函数“ L('level_name')”的参数，其输出的数据为“等级”。 如上面的列表模板片断其对应的网页如截图红色框： 当然，我们也不一定非要建立语言包，非正式的话也可以直接赋与参数，如： “&lt;th&nbsp; align=\"center\"&gt;&lt;?php echo L('level_name')?&gt;&lt;/th&gt;”，可以写成“&lt;th&nbsp; align=\"center\"&gt;&lt;?php echo L(\"等级\")?&gt;&lt;/th&gt;”,甚至可以更直接写成&lt;th&nbsp; align=\"center\"&gt;等级&lt;/th&gt; phpcms v9语言包的作用 上面说过，语包的写法和其它替代写法，当然，参数字节小的话可以直接给L()函数赋与参数，但是如果参数字节太大呢？这样在模板上就显得凌乱了。语言包一经定义，可以重复在多个模板上使用。前面也提到，甚至可以不用语言包和“L()\"函，直接写，不过不建议这样，一般来说不会有什么问题，但我在调试过程中偶尔也会出现一些意想不到的乱码。显然语言的作用有： 1、开发国际版CMS 2、使模板整洁美观 3、方便模板修改，减少工作量 4、杜绝因为编码而引起的乱码问题 联系qq-2：1006511390(点击进行咨询)","categories":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}],"tags":[{"name":"V语言","slug":"v语言","permalink":"https://vlanguage.cn/tags/v语言/"}],"keywords":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}]},{"title":"SPIR-V 研究：编译器基本原理（一）","slug":"qwertyu1234_50163847","date":"2015-12-03T00:00:00.000Z","updated":"2019-07-22T05:05:29.816Z","comments":true,"path":"2015/12/03/qwertyu1234_50163847.html","link":"","permalink":"https://vlanguage.cn/2015/12/03/qwertyu1234_50163847.html","excerpt":"","text":"SPIR-V 研究：编译器基本原理（一） 前面转过两篇关于SPIR-V 中间语言的介绍；接下来笔者准备深入学习一下SPIR-V的标准。根据标准，SPIR-V是以一种二进制格式存在的，并且函数还是以控制流图CFG的形式存在；数据结构也保留了高级语言里的层级关系。（https://en.wikipedia.org/wiki/Standard_Portable_Intermediate_Representation） 这样做的目的是为了更好的在目标平台上进行优化；同时Khronos也放出了官方标准的开源编译器Glslang。 所以，为了更好的了解SPIR-V，我们有必要先温习一下编译器的基本原理，特别是前端的词法分析、语法分析、语义分析和中间语言生成。 编译器基本结构 下图是一个一般编译器的编译高级语言的过程。 基本上就是预处理（比如C/C++里宏汇编），编译并汇编（每个源码文件都生成对应的.o文件，这时的代码是relocatable的），链接生成可执行文件（linker，把许多.o文件以及用到的库函数.lib文件合并并作全局优化），最后OS的加载器会加载可执行文件并运行之（Windows上是PE格式，Linux上市ELF格式）。具体细节可以参考Linkers and Loaders 这本书。 下面我们重点看编译器的结构。 这是一般编译器的结构，主要分前端和后端，以中间语言生成为界限。前端主要是分析语法语义并生成代码的中间表示，这主要包括lexer 和 parser，以及语义分析；后端主要是生成目标机器代码，包括分析并优化，寄存器分配等。 下图是编译器的主要编译过程（phase）。 这里我们研究的目标SPIR-V就是一种标准化的中间语言表示。所以我们更关心的是前端的研究，这也是编译器里比较成熟，相对简单的部分。以前的OpenGL里，GLSL写成的Shader是高级语言（相当于C++)，OpenGL的驱动会把它编译成显卡GPU对应的机器码。所以各家会有不同的中间表示；Vulkan会统一标准用SPIR-V了。 计算机语言 计算机科学里的语言可以看作是一个字母表（alphabet ）上的某些有限长字符串的集合；这一般可以包含无限多个字符串，也就是无限集合（Infinite Sets）。这里有限长字符串就是“sentences”；sentences是word（或token）组成，它有一定的结构；token则是letter由一定规则组成；letter个数是有限的，它们全部取自字母表（alphabet ）。 这是个有层次的定义。 Layer 分析对象 组成元素 词法（Lexical structure ） token letter 语法（Syntactic structure） sentences token 语义（Semantics） 语法树 语言是有一定的语法规则的（grammar）。而grammar是一组有限的规则的集合；计算机语言里的grammar是不同于一般自然语言的语法，它可以构造出所有可能的sentences。所以这是一个利用有限规则来产生无限的合法语句的问题。 而grammar又可以用正则表达式来定义；比如GLSL的语法glslang.y。","categories":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}],"tags":[{"name":"V语言","slug":"v语言","permalink":"https://vlanguage.cn/tags/v语言/"}],"keywords":[{"name":"博文","slug":"博文","permalink":"https://vlanguage.cn/categories/博文/"}]}]}